# Critic Input for CVE-2020-10966



# Original Analyzer Input
## Vulnerability Description
In the Password Reset Module in VESTA Control Panel through 0.9.8-25 and Hestia Control Panel before 1.1.1, **Host header manipulation** leads to account takeover because the victim receives a reset URL containing an attacker-controlled server name.

### Vulnerability Description Key Phrases
- **rootcause:** **Host header manipulation**
- **impact:** account takeover
- **vector:** receiving reset URL with attacker-controlled server name
- **product:** VESTA Control Panel and Hestia Control Panel
- **version:** through 0.9.8-25 and before 1.1.1
- **component:** Password Reset Module

## CVE Reference Links Content Summary
Based on the provided content, here's a breakdown of the vulnerability described in CVE-2020-10966:

**Root Cause of Vulnerability:**

*   The vulnerability stems from the use of the `$_SERVER['HTTP_HOST']` value without proper validation in the password reset module of VESTA Control Panel and Hestia Control Panel. This value is directly incorporated into the password reset URL sent to the user via email.

**Weaknesses/Vulnerabilities Present:**

*   **Host Header Injection:** The application does not validate or sanitize the `Host` header from the HTTP request. This allows an attacker to inject a malicious hostname into the `HTTP_HOST` variable.
*   **Unvalidated Input:** The injected hostname is then used to construct the password reset link, without verification, resulting in the generation of a malicious reset URL.
*   **Lack of Context-Aware Encoding:** The application lacks proper encoding or escaping when using the HTTP Host value within the password reset email, allowing for arbitrary URL injection.

**Impact of Exploitation:**

*   **Account Takeover:** By manipulating the `Host` header, an attacker can inject a malicious domain name into the password reset email. If a user clicks on the crafted link, they will be redirected to the attacker's server instead of the legitimate password reset page. This allows the attacker to steal the reset token/code and subsequently reset the user's password and take over their account.
*   **Phishing:** Although the email is sent from the legitimate server, the malicious link can be crafted to mimic a legitimate login page, potentially tricking users into revealing their credentials.

**Attack Vectors:**

*   **Network-based:** An attacker can remotely send an HTTP request to the vulnerable password reset endpoint.
*   **HTTP Header Manipulation:** The attacker manipulates the `Host` header of the HTTP request to inject a malicious domain.

**Required Attacker Capabilities/Position:**

*   **Network Access:** The attacker needs network access to send an HTTP request to the vulnerable application.
*   **No Authentication Required:** The attacker does not need any prior authentication or access to exploit the vulnerability.
*   **User Interaction:** The attacker requires the victim user to click on the manipulated password reset link in the email.

**Additional Details from the Content:**

*   The vulnerability affects VESTA Control Panel through version 0.9.8-25 and Hestia Control Panel before version 1.1.1.
*   The fix implemented involved replacing the usage of `$_SERVER['HTTP_HOST']` with a validated hostname.
*   The provided issue report includes a detailed description of how the vulnerability can be exploited using a crafted `Host` header.
*   The fix was initially implemented without considering the port in the URL and was later corrected.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage | Combined Score | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|---------------|------------|-------------------|
| 1 | CWE-471 | Modification of Assumed-Immutable Data (MAID) | Base | Allowed | 0.4938 | sparse, graph | sparse: 0.343, graph: 0.832 |
| 2 | CWE-79 | Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting') | Base | Allowed | 0.4425 | sparse, graph | sparse: 0.191, graph: 0.932 |
| 3 | CWE-89 | Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection') | Base | Allowed | 0.4127 | sparse, graph | sparse: 0.170, graph: 0.882 |
| 4 | CWE-113 | Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Request/Response Splitting') | Variant | Allowed | 0.3896 | sparse, graph | sparse: 0.169, graph: 0.911 |
| 5 | CWE-620 | Unverified Password Change | Base | Allowed | 0.3352 | dense, sparse | dense: 0.492, sparse: 0.155 |
| 6 | CWE-290 | Authentication Bypass by Spoofing | Base | Allowed | 0.3255 | sparse, graph | sparse: 0.167, graph: 0.644 |
| 7 | CWE-291 | Reliance on IP Address for Authentication | Variant | Allowed | 0.2779 | dense, sparse | dense: 0.426, sparse: 0.154 |
| 8 | CWE-306 | Missing Authentication for Critical Function | Base | Allowed | 0.0944 | sparse | sparse: 0.165 |
| 9 | CWE-93 | Improper Neutralization of CRLF Sequences ('CRLF Injection') | Base | Allowed | 0.0938 | sparse | sparse: 0.164 |
| 10 | CWE-266 | Incorrect Privilege Assignment | Base | Allowed | 0.0937 | sparse | sparse: 0.164 |



# Analysis to Review
# Summary
| CWE ID  | CWE Name                                                                           | Confidence | CWE Abstraction Level | CWE Vulnerability Mapping Label | CWE-Vulnerability Mapping Notes |
|---------|------------------------------------------------------------------------------------|------------|-----------------------|---------------------------------|---------------------------------|
| CWE-113 | Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Request/Response Splitting') | 0.85       | Variant               | Primary CWE                     | Allowed                        |
| CWE-93  | Improper Neutralization of CRLF Sequences ('CRLF Injection')                       | 0.65       | Base                  | Secondary Candidate             | Allowed                        |
| CWE-471 | Modification of Assumed-Immutable Data (MAID)                                    | 0.55       | Base                  | Secondary Candidate             | Allowed                        |

## Evidence and Confidence

*   **Confidence Score:** 0.80
*   **Evidence Strength:** HIGH

- **Analysis and Justification:**
  - *Explanation:* "The vulnerability description details how **Host header manipulation** allows an attacker to inject a malicious server name into password reset URLs. This falls under CWE-113 (Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Request/Response Splitting')) because the **root cause** is the lack of proper validation and sanitization of the `Host` header, which is then used to construct the password reset link. The `Host` header is an HTTP header, and the injection leads to an attacker-controlled URL. This aligns directly with the CWE description and its common attack patterns. CWE-113 is a Variant, and therefore more specific than its parent class CWE-20."

  - *Relationship Analysis:* "CWE-113 is a variant of CWE-20 (Improper Input Validation) and is related to CWE-93 (Improper Neutralization of CRLF Sequences). The vulnerability description indicates that the application does not neutralize or incorrectly neutralizes CR and LF characters before including the data in outgoing HTTP headers, specifically the `Host` header. This manipulation can lead to HTTP Request/Response Splitting, further enabling account takeover. It CanPrecede CWE-79."

- **Confidence Score:**
  - Confidence: 0.85 (High evidence from technical description and CVE reference materials)

---

- **Analysis and Justification:**
  - *Explanation:* "CWE-93 (Improper Neutralization of CRLF Sequences ('CRLF Injection')) is considered as a secondary candidate. The `Host` header could potentially contain CRLF sequences, leading to further injection vulnerabilities. Although CWE-113 covers the primary attack vector of `Host` header injection, the potential for CRLF injection within the header justifies considering CWE-93. It is less direct than CWE-113."

  - *Relationship Analysis:* "CWE-93 is a base level CWE and is related to CWE-113 as it could be a vector for the host header manipulation. CWE-93 is a child of CWE-74 (Improper Neutralization of Special Elements) and a parent of CWE-113."

- **Confidence Score:**
  - Confidence: 0.65 (Supporting evidence from the potential for CRLF sequences in the Host header.)

---

- **Analysis and Justification:**
  - *Explanation:* "CWE-471 (Modification of Assumed-Immutable Data (MAID)) is another secondary candidate. The `HTTP_HOST` server variable is assumed to be immutable, but the vulnerability description highlights that an attacker can manipulate it. The application's failure to protect this variable from external modification aligns with the description of CWE-471. This is less direct than CWE-113 because the core issue is how the manipulated data is used."

  - *Relationship Analysis:* "CWE-471 deals with the modification of assumed-immutable data. In this case, the `$HTTP_HOST` variable is being modified. It is a base level weakness. CWE-471 can precede the occurrence of CWE-113 in the vulnerability chain."

- **Confidence Score:**
  - Confidence: 0.55 (Supporting evidence based on the modifiable nature of the HTTP_HOST variable.)

# CWE Examples from Database


## Known Examples for CWE-74: Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')
### Observed Examples
- **CVE-2024-5184** [https://www.cve.org/CVERecord?id=CVE-2024-5184](https://www.cve.org/CVERecord?id=CVE-2024-5184): API service using a large generative AI model allows direct prompt injection to leak hard-coded system prompts or execute other prompts.
- **CVE-2022-36069** [https://www.cve.org/CVERecord?id=CVE-2022-36069](https://www.cve.org/CVERecord?id=CVE-2022-36069): Python-based dependency management tool avoids OS command injection when generating Git commands but allows injection of optional arguments with input beginning with a dash (CWE-88), potentially allowing for code execution.
- **CVE-1999-0067** [https://www.cve.org/CVERecord?id=CVE-1999-0067](https://www.cve.org/CVERecord?id=CVE-1999-0067): Canonical example of OS command injection. CGI program does not neutralize "|" metacharacter when invoking a phonebook program.
- **CVE-2022-1509** [https://www.cve.org/CVERecord?id=CVE-2022-1509](https://www.cve.org/CVERecord?id=CVE-2022-1509): injection of sed script syntax ("sed injection")
- **CVE-2020-9054** [https://www.cve.org/CVERecord?id=CVE-2020-9054](https://www.cve.org/CVERecord?id=CVE-2020-9054): Chain: improper input validation (CWE-20) in username parameter, leading to OS command injection (CWE-78), as exploited in the wild per CISA KEV.
- **CVE-2021-44228** [https://www.cve.org/CVERecord?id=CVE-2021-44228](https://www.cve.org/CVERecord?id=CVE-2021-44228): Product does not neutralize ${xyz} style expressions, allowing remote code execution. (log4shell vulnerability)
### Top 25 Examples
- **CVE-2021-29676**: IBM Security Verify (IBM Security Verify Privilege Vault 10.9.66) is vulnerable to link injection. By persuading a victim to click on a specially-crafted URL link, a remote attacker could exploit this vulnerability to conduct various attacks against the vulnerable system, including cross-site scripting, cache poisoning or session hijacking
- **CVE-2021-38458**: A path traversal vulnerability in the Moxa MXview Network Management software Versions 3.x to 3.2.2 may allow an attacker to create or overwrite critical files used to execute code, such as programs or libraries.
- **CVE-2021-21137**: Inappropriate implementation in DevTools in Google Chrome prior to 88.0.4324.96 allowed a remote attacker to obtain potentially sensitive information from disk via a crafted HTML page.
- **CVE-2021-27614**: SAP Business One Hana Chef Cookbook, versions - 8.82, 9.0, 9.1, 9.2, 9.3, 10.0, used to install SAP Business One on SAP HANA, allows an attacker to inject code that can be executed by the application. An attacker could thereby control the behaviour of the application thereby highly impacting the integrity and availability of the application.


# Relevant CWE Specifications

## CWE-74: Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')
**Abstraction:** Class
**Status:** Incomplete

### Description
The product constructs all or part of a command, data structure, or record using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify how it is parsed or interpreted when it is sent to a downstream component.

### Extended Description
Software or other automated logic has certain assumptions about what constitutes data and control respectively. It is the lack of verification of these assumptions for user-controlled input that leads to injection problems. Injection problems encompass a wide variety of issues -- all mitigated in very different ways and usually attempted in order to alter the control flow of the process. For this reason, the most effective way to discuss these weaknesses is to note the distinct features that classify them as injection weaknesses. The most important issue to note is that all injection problems share one thing in common -- i.e., they allow for the injection of control plane data into the user-controlled data plane. This means that the execution of the process may be altered by sending code in through legitimate data channels, using no other mechanism. While buffer overflows, and many other flaws, involve the use of some further issue to gain execution, injection problems need only for the data to be parsed.

### Alternative Terms
None

### Relationships
ChildOf -> CWE-707
CanFollow -> CWE-116
ParentOf -> CWE-1236
CanFollow -> CWE-20
ParentOf -> CWE-75
ParentOf -> CWE-77
ParentOf -> CWE-78
ParentOf -> CWE-79
ParentOf -> CWE-88
ParentOf -> CWE-89
ParentOf -> CWE-91
ParentOf -> CWE-917
ParentOf -> CWE-93
ParentOf -> CWE-94
ParentOf -> CWE-943
ParentOf -> CWE-99

### Mapping Guidance
**Usage:** Discouraged
**Rationale:** CWE-74 is high-level and often misused when lower-level weaknesses are more appropriate.
**Comments:** Examine the children and descendants of this entry to find a more precise mapping.
**Reasons:**
- Frequent Misuse
- Abstraction


### Potential Mitigations
**Mitigation 1:**
- **Phase:** Requirements
- **Description:** Programming languages and supporting technologies might be chosen which are not subject to these issues.

**Mitigation 2:**
- **Phase:** Implementation
- **Description:** Utilize an appropriate mix of allowlist and denylist parsing to filter control-plane syntax from all input.



### Additional Notes
**[Theoretical]** Many people treat injection only as an input validation problem (CWE-20) because many people do not distinguish between the consequence/attack (injection) and the protection mechanism that prevents the attack from succeeding. However, input validation is only one potential protection mechanism (output encoding is another), and there is a chaining relationship between improper input validation and the improper enforcement of the structure of messages to other components. Other issues not directly related to input validation, such as race conditions, could similarly impact message structure.



### Observed Examples
- **CVE-2024-5184:** API service using a large generative AI model allows direct prompt injection to leak hard-coded system prompts or execute other prompts.
- **CVE-2022-36069:** Python-based dependency management tool avoids OS command injection when generating Git commands but allows injection of optional arguments with input beginning with a dash (CWE-88), potentially allowing for code execution.
- **CVE-1999-0067:** Canonical example of OS command injection. CGI program does not neutralize "|" metacharacter when invoking a phonebook program.



## CWE-20: Improper Input Validation
**Abstraction:** Class
**Status:** Stable

### Description
The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.

### Extended Description


Input validation is a frequently-used technique for checking potentially dangerous inputs in order to ensure that the inputs are safe for processing within the code, or when communicating with other components. When software does not validate input properly, an attacker is able to craft the input in a form that is not expected by the rest of the application. This will lead to parts of the system receiving unintended input, which may result in altered control flow, arbitrary control of a resource, or arbitrary code execution.


Input validation is not the only technique for processing input, however. Other techniques attempt to transform potentially-dangerous input into something safe, such as filtering (CWE-790) - which attempts to remove dangerous inputs - or encoding/escaping (CWE-116), which attempts to ensure that the input is not misinterpreted when it is included in output to another component. Other techniques exist as well (see CWE-138 for more examples.)


Input validation can be applied to:


  - raw data - strings, numbers, parameters, file contents, etc.

  - metadata - information about the raw data, such as headers or size

Data can be simple or structured. Structured data can be composed of many nested layers, composed of combinations of metadata and raw data, with other simple or structured data.

Many properties of raw data or metadata may need to be validated upon entry into the code, such as:


  - specified quantities such as size, length, frequency, price, rate, number of operations, time, etc.

  - implied or derived quantities, such as the actual size of a file instead of a specified size

  - indexes, offsets, or positions into more complex data structures

  - symbolic keys or other elements into hash tables, associative arrays, etc.

  - well-formedness, i.e. syntactic correctness - compliance with expected syntax 

  - lexical token correctness - compliance with rules for what is treated as a token

  - specified or derived type - the actual type of the input (or what the input appears to be)

  - consistency - between individual data elements, between raw data and metadata, between references, etc.

  - conformance to domain-specific rules, e.g. business logic 

  - equivalence - ensuring that equivalent inputs are treated the same

  - authenticity, ownership, or other attestations about the input, e.g. a cryptographic signature to prove the source of the data

Implied or derived properties of data must often be calculated or inferred by the code itself. Errors in deriving properties may be considered a contributing factor to improper input validation. 

Note that "input validation" has very different meanings to different people, or within different classification schemes. Caution must be used when referencing this CWE entry or mapping to it. For example, some weaknesses might involve inadvertently giving control to an attacker over an input when they should not be able to provide an input at all, but sometimes this is referred to as input validation.


Finally, it is important to emphasize that the distinctions between input validation and output escaping are often blurred, and developers must be careful to understand the difference, including how input validation is not always sufficient to prevent vulnerabilities, especially when less stringent data types must be supported, such as free-form text. Consider a SQL injection scenario in which a person's last name is inserted into a query. The name "O'Reilly" would likely pass the validation step since it is a common last name in the English language. However, this valid name cannot be directly inserted into the database because it contains the "'" apostrophe character, which would need to be escaped or otherwise transformed. In this case, removing the apostrophe might reduce the risk of SQL injection, but it would produce incorrect behavior because the wrong name would be recorded.


### Alternative Terms
None

### Relationships
ChildOf -> CWE-707
PeerOf -> CWE-345
CanPrecede -> CWE-22
CanPrecede -> CWE-41
CanPrecede -> CWE-74
CanPrecede -> CWE-119
CanPrecede -> CWE-770
ParentOf -> CWE-102
ParentOf -> CWE-103
ParentOf -> CWE-104
ParentOf -> CWE-105
ParentOf -> CWE-106
ParentOf -> CWE-107
ParentOf -> CWE-108
ParentOf -> CWE-109
ParentOf -> CWE-110
ParentOf -> CWE-111
ParentOf -> CWE-112
ParentOf -> CWE-113
ParentOf -> CWE-114
ParentOf -> CWE-117
ParentOf -> CWE-1173
ParentOf -> CWE-119
ParentOf -> CWE-120
ParentOf -> CWE-1284
ParentOf -> CWE-1285
ParentOf -> CWE-1286
ParentOf -> CWE-1287
ParentOf -> CWE-1288
ParentOf -> CWE-1289
ParentOf -> CWE-129
ParentOf -> CWE-134
ParentOf -> CWE-15
ParentOf -> CWE-170
ParentOf -> CWE-179
ParentOf -> CWE-190
ParentOf -> CWE-466
ParentOf -> CWE-470
ParentOf -> CWE-622
ParentOf -> CWE-73
ParentOf -> CWE-785

### Mapping Guidance
**Usage:** Discouraged
**Rationale:** CWE-20 is commonly misused in low-information vulnerability reports when lower-level CWEs could be used instead, or when more details about the vulnerability are available [REF-1287]. It is not useful for trend analysis. It is also a level-1 Class (i.e., a child of a Pillar).
**Comments:** Consider lower-level children such as Improper Use of Validation Framework (CWE-1173) or improper validation involving specific types or properties of input such as Specified Quantity (CWE-1284); Specified Index, Position, or Offset (CWE-1285); Syntactic Correctness (CWE-1286); Specified Type (CWE-1287); Consistency within Input (CWE-1288); or Unsafe Equivalence (CWE-1289).
**Reasons:**
- Frequent Misuse
**Suggested Alternatives:**
- CWE-1284: Specified Quantity
- CWE-1285: Specified Index, Position, or Offset
- CWE-1286: Syntactic Correctness
- CWE-1287: Specified Type
- CWE-1288: Consistency within Input
- CWE-1289: Unsafe Equivalence
- CWE-116: Improper Encoding or Escaping of Output


### Potential Mitigations
**Mitigation 1:**
- **Phase:** Architecture and Design
- **Strategy:** Attack Surface Reduction
- **Description:** Consider using language-theoretic security (LangSec) techniques that characterize inputs using a formal language and build "recognizers" for that language. This effectively requires parsing to be a distinct layer that effectively enforces a boundary between raw input and internal data representations, instead of allowing parser code to be scattered throughout the program, where it could be subject to errors or inconsistencies that create weaknesses. [REF-1109] [REF-1110] [REF-1111]

**Mitigation 2:**
- **Phase:** Architecture and Design
- **Strategy:** Libraries or Frameworks
- **Description:** Use an input validation framework such as Struts or the OWASP ESAPI Validation API. Note that using a framework does not automatically address all input validation problems; be mindful of weaknesses that could arise from misusing the framework itself (CWE-1173).

**Mitigation 3:**
- **Phase:** Architecture and Design, Implementation
- **Strategy:** Attack Surface Reduction
- **Description:** Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, filenames, databases, and any external systems that provide data to the application. Remember that such inputs may be obtained indirectly through API calls.



### Additional Notes
**[Relationship]** 

CWE-116 and CWE-20 have a close association because, depending on the nature of the structured message, proper input validation can indirectly prevent special characters from changing the meaning of a structured message. For example, by validating that a numeric ID field should only contain the 0-9 characters, the programmer effectively prevents injection attacks.


**[Maintenance]** As of 2020, this entry is used more often than preferred, and it is a source of frequent confusion. It is being actively modified for CWE 4.1 and subsequent versions.

**[Maintenance]** Concepts such as validation, data transformation, and neutralization are being refined, so relationships between CWE-20 and other entries such as CWE-707 may change in future versions, along with an update to the Vulnerability Theory document.

**[Maintenance]** Input validation - whether missing or incorrect - is such an essential and widespread part of secure development that it is implicit in many different weaknesses. Traditionally, problems such as buffer overflows and XSS have been classified as input validation problems by many security professionals. However, input validation is not necessarily the only protection mechanism available for avoiding such problems, and in some cases it is not even sufficient. The CWE team has begun capturing these subtleties in chains within the Research Concepts view (CWE-1000), but more work is needed.

**[Terminology]** 

The "input validation" term is extremely common, but it is used in many different ways. In some cases its usage can obscure the real underlying weakness or otherwise hide chaining and composite relationships.


Some people use "input validation" as a general term that covers many different neutralization techniques for ensuring that input is appropriate, such as filtering, canonicalization, and escaping. Others use the term in a more narrow context to simply mean "checking if an input conforms to expectations without changing it." CWE uses this more narrow interpretation.




### Observed Examples
- **CVE-2024-37032:** Large language model (LLM) management tool does not validate the format of a digest value (CWE-1287) from a private, untrusted model registry, enabling relative path traversal (CWE-23), a.k.a. Probllama
- **CVE-2022-45918:** Chain: a learning management tool debugger uses external input to locate previous session logs (CWE-73) and does not properly validate the given path (CWE-20), allowing for filesystem path traversal using "../" sequences (CWE-24)
- **CVE-2021-30860:** Chain: improper input validation (CWE-20) leads to integer overflow (CWE-190) in mobile OS, as exploited in the wild per CISA KEV.



## CWE-471: Modification of Assumed-Immutable Data (MAID)
**Abstraction:** Base
**Status:** Draft

### Description
The product does not properly protect an assumed-immutable element from being modified by an attacker.

### Extended Description
This occurs when a particular input is critical enough to the functioning of the application that it should not be modifiable at all, but it is. Certain resources are often assumed to be immutable when they are not, such as hidden form fields in web applications, cookies, and reverse DNS lookups.

### Alternative Terms
None

### Relationships
ChildOf -> CWE-664
CanFollow -> CWE-1282
CanFollow -> CWE-1321
ParentOf -> CWE-291
CanFollow -> CWE-425
ParentOf -> CWE-472
ParentOf -> CWE-473
CanFollow -> CWE-602
ParentOf -> CWE-607
CanFollow -> CWE-621

### Mapping Guidance
**Usage:** Allowed
**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.
**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.
**Reasons:**
- Acceptable-Use


### Potential Mitigations
**Mitigation 1:**
- **Phase:** Architecture and Design, Operation, Implementation
- **Description:** When the data is stored or transmitted through untrusted sources that could modify the data, implement integrity checks to detect unauthorized modification, or store/transmit the data in a trusted location that is free from external influence.



### Additional Notes
**[Relationship]** MAID issues can be primary to many other weaknesses, and they are a major factor in languages that provide easy access to internal program constructs, such as PHP's register_globals and similar features. However, MAID issues can also be resultant from weaknesses that modify internal state; for example, a program might validate some data and store it in memory, but a buffer overflow could overwrite that validated data, leading to a change in program logic.

**[Theoretical]** There are many examples where the MUTABILITY property is a major factor in a vulnerability.



### Observed Examples
- **CVE-2002-1757:** Relies on $PHP_SELF variable for authentication.
- **CVE-2005-1905:** Gain privileges by modifying assumed-immutable code addresses that are accessed by a driver.



## CWE-113: Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Request/Response Splitting')
**Abstraction:** Variant
**Status:** Incomplete

### Description
The product receives data from an HTTP agent/component (e.g., web server, proxy, browser, etc.), but it does not neutralize or incorrectly neutralizes CR and LF characters before the data is included in outgoing HTTP headers.

### Extended Description


 HTTP agents or components may include a web server, load balancer, reverse proxy, web caching proxy, application firewall, web browser, etc. Regardless of the role, they are expected to maintain coherent, consistent HTTP communication state across all components. However, including unexpected data in an HTTP header allows an attacker to specify the entirety of the HTTP message that is rendered by the client HTTP agent (e.g., web browser) or back-end HTTP agent (e.g., web server), whether the message is part of a request or a response. 


When an HTTP request contains unexpected CR and LF characters, the server may respond with an output stream that is interpreted as "splitting" the stream into two different HTTP messages instead of one. CR is carriage return, also given by %0d or \r, and LF is line feed, also given by %0a or \n.


In addition to CR and LF characters, other valid/RFC compliant special characters and unique character encodings can be utilized, such as HT (horizontal tab, also given by %09 or \t) and SP (space, also given as + sign or %20).


These types of unvalidated and unexpected data in HTTP message headers allow an attacker to control the second "split" message to mount attacks such as server-side request forgery, cross-site scripting, and cache poisoning attacks.


HTTP response splitting weaknesses may be present when:


  1. Data enters a web application through an untrusted source, most frequently an HTTP request.

  1. The data is included in an HTTP response header sent to a web user without neutralizing malicious characters that can be interpreted as separator characters for headers.



### Alternative Terms
HTTP Request Splitting
HTTP Response Splitting

### Relationships
ChildOf -> CWE-93
CanPrecede -> CWE-79
ChildOf -> CWE-20
ChildOf -> CWE-436

### Mapping Guidance
**Usage:** Allowed
**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.
**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.
**Reasons:**
- Acceptable-Use


### Potential Mitigations
**Mitigation 1:**
- **Phase:** Implementation
- **Strategy:** Input Validation
- **Description:** Construct HTTP headers very carefully, avoiding the use of non-validated input data.

**Mitigation 2:**
- **Phase:** Implementation
- **Strategy:** Input Validation
- **Description:** 

Assume all input is malicious. Use an "accept known good" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. If an input does not strictly conform to specifications, reject it or transform it into something that conforms.


When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, "boat" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as "red" or "blue."


Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.


**Mitigation 3:**
- **Phase:** Implementation
- **Strategy:** Output Encoding
- **Description:** Use and specify an output encoding that can be handled by the downstream component that is reading the output. Common encodings include ISO-8859-1, UTF-7, and UTF-8. When an encoding is not specified, a downstream component may choose a different encoding, either by assuming a default encoding or automatically inferring which encoding is being used, which can be erroneous. When the encodings are inconsistent, the downstream component might treat some character or byte sequences as special, even if they are not special in the original encoding. Attackers might then be able to exploit this discrepancy and conduct injection attacks; they even might be able to bypass protection mechanisms that assume the original encoding is also being used by the downstream component.




### Observed Examples
- **CVE-2020-15811:** Chain: Proxy uses a substring search instead of parsing the Transfer-Encoding header (CWE-697), allowing request splitting (CWE-113) and cache poisoning
- **CVE-2021-41084:** Scala-based HTTP interface allows request splitting and response splitting through header names, header values, status reasons, and URIs
- **CVE-2018-12116:** Javascript-based framework allows request splitting through a path option of an HTTP request



## CWE-93: Improper Neutralization of CRLF Sequences ('CRLF Injection')
**Abstraction:** Base
**Status:** Draft

### Description
The product uses CRLF (carriage return line feeds) as a special element, e.g. to separate lines or records, but it does not neutralize or incorrectly neutralizes CRLF sequences from inputs.

### Extended Description
Not provided

### Alternative Terms
None

### Relationships
ChildOf -> CWE-74
CanPrecede -> CWE-117
ParentOf -> CWE-113

### Mapping Guidance
**Usage:** Allowed
**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.
**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.
**Reasons:**
- Acceptable-Use


### Potential Mitigations
**Mitigation 1:**
- **Phase:** Implementation
- **Description:** Avoid using CRLF as a special sequence.

**Mitigation 2:**
- **Phase:** Implementation
- **Description:** Appropriately filter or quote CRLF sequences in user-controlled input.




### Observed Examples
- **CVE-2002-1771:** CRLF injection enables spam proxy (add mail headers) using email address or name.
- **CVE-2002-1783:** CRLF injection in API function arguments modify headers for outgoing requests.
- **CVE-2004-1513:** Spoofed entries in web server log file via carriage returns



## CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')
**Abstraction:** Base
**Status:** Stable

### Description
The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.

### Extended Description


Cross-site scripting (XSS) vulnerabilities occur when:


  1. Untrusted data enters a web application, typically from a web request.

  1. The web application dynamically generates a web page that contains this untrusted data.

  1. During page generation, the application does not prevent the data from containing content that is executable by a web browser, such as JavaScript, HTML tags, HTML attributes, mouse events, Flash, ActiveX, etc.

  1. A victim visits the generated web page through a web browser, which contains malicious script that was injected using the untrusted data.

  1. Since the script comes from a web page that was sent by the web server, the victim's web browser executes the malicious script in the context of the web server's domain.

  1. This effectively violates the intention of the web browser's same-origin policy, which states that scripts in one domain should not be able to access resources or run code in a different domain.

There are three main kinds of XSS:

  -  **Type 1: Reflected XSS (or Non-Persistent)**  - The server reads data directly from the HTTP request and reflects it back in the HTTP response. Reflected XSS exploits occur when an attacker causes a victim to supply dangerous content to a vulnerable web application, which is then reflected back to the victim and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or e-mailed directly to the victim. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces a victim to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the victim, the content is executed by the victim's browser.

  -  **Type 2: Stored XSS (or Persistent)**  - The application stores dangerous data in a database, message forum, visitor log, or other trusted data store. At a later time, the dangerous data is subsequently read back into the application and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user. For example, the attacker might inject XSS into a log message, which might not be handled properly when an administrator views the logs. 

  -  **Type 0: DOM-Based XSS**  - In DOM-based XSS, the client performs the injection of XSS into the page; in the other types, the server performs the injection. DOM-based XSS generally involves server-controlled, trusted script that is sent to the client, such as Javascript that performs sanity checks on a form before the user submits it. If the server-supplied script processes user-supplied data and then injects it back into the web page (such as with dynamic HTML), then DOM-based XSS is possible. 

Once the malicious script is injected, the attacker can perform a variety of malicious activities. The attacker could transfer private information, such as cookies that may include session information, from the victim's machine to the attacker. The attacker could send malicious requests to a web site on behalf of the victim, which could be especially dangerous to the site if the victim has administrator privileges to manage that site. Phishing attacks could be used to emulate trusted web sites and trick the victim into entering a password, allowing the attacker to compromise the victim's account on that web site. Finally, the script could exploit a vulnerability in the web browser itself possibly taking over the victim's machine, sometimes referred to as "drive-by hacking."

In many cases, the attack can be launched without the victim even being aware of it. Even with careful users, attackers frequently use a variety of methods to encode the malicious portion of the attack, such as URL encoding or Unicode, so the request looks less suspicious.


### Alternative Terms
XSS: A common abbreviation for Cross-Site Scripting.
HTML Injection: Used as a synonym of stored (Type 2) XSS.
CSS: In the early years after initial discovery of XSS, "CSS" was a commonly-used acronym. However, this would cause confusion with "Cascading Style Sheets," so usage of this acronym has declined significantly.

### Relationships
ChildOf -> CWE-74
ChildOf -> CWE-74
CanPrecede -> CWE-494
PeerOf -> CWE-352
CanFollow -> CWE-113
CanFollow -> CWE-184
ParentOf -> CWE-80
ParentOf -> CWE-81
ParentOf -> CWE-83
ParentOf -> CWE-84
ParentOf -> CWE-85
ParentOf -> CWE-86
ParentOf -> CWE-87

### Mapping Guidance
**Usage:** Allowed
**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.
**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.
**Reasons:**
- Acceptable-Use


### Potential Mitigations
**Mitigation 1:**
- **Phase:** Architecture and Design
- **Strategy:** Libraries or Frameworks
- **Description:** 

Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.


Examples of libraries and frameworks that make it easier to generate properly encoded output include Microsoft's Anti-XSS library, the OWASP ESAPI Encoding module, and Apache Wicket.


**Mitigation 2:**
- **Phase:** Implementation, Architecture and Design
- **Description:** 

Understand the context in which your data will be used and the encoding that will be expected. This is especially important when transmitting data between different components, or when generating outputs that can contain multiple encodings at the same time, such as web pages or multi-part mail messages. Study all expected communication protocols and data representations to determine the required encoding strategies.


For any data that will be output to another web page, especially any data that was received from external inputs, use the appropriate encoding on all non-alphanumeric characters.


Parts of the same output document may require different encodings, which will vary depending on whether the output is in the:


  - HTML body

  - Element attributes (such as src="XYZ")

  - URIs

  - JavaScript sections

  - Cascading Style Sheets and style property

etc. Note that HTML Entity Encoding is only appropriate for the HTML body.

Consult the XSS Prevention Cheat Sheet [REF-724] for more details on the types of encoding and escaping that are needed.


**Mitigation 3:**
- **Phase:** Architecture and Design, Implementation
- **Effectiveness:** Limited
- **Strategy:** Attack Surface Reduction
- **Description:** Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, filenames, databases, and any external systems that provide data to the application. Remember that such inputs may be obtained indirectly through API calls.



### Additional Notes
**[Relationship]** 

There can be a close relationship between XSS and CSRF (CWE-352). An attacker might use CSRF in order to trick the victim into submitting requests to the server in which the requests contain an XSS payload. A well-known example of this was the Samy worm on MySpace [REF-956]. The worm used XSS to insert malicious HTML sequences into a user's profile and add the attacker as a MySpace friend. MySpace friends of that victim would then execute the payload to modify their own profiles, causing the worm to propagate exponentially. Since the victims did not intentionally insert the malicious script themselves, CSRF was a root cause.


**[Applicable Platform]** 

XSS flaws are very common in web applications, since they require a great deal of developer discipline to avoid them.




### Observed Examples
- **CVE-2021-25926:** Python Library Manager did not sufficiently neutralize a user-supplied search term, allowing reflected XSS.
- **CVE-2021-25963:** Python-based e-commerce platform did not escape returned content on error pages, allowing for reflected Cross-Site Scripting attacks.
- **CVE-2021-1879:** Universal XSS in mobile operating system, as exploited in the wild per CISA KEV.

