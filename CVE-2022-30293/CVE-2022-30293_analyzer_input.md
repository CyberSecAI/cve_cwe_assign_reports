# Vulnerability Information: CVE-2022-30293

## Vulnerability Description
In WebKitGTK through 2.36.0 (and WPE WebKit), there is a **heap-based buffer overflow** in WebCoreTextureMapperLayersetContentsLayer in WebCore/platform/graphics/texmap/TextureMapperLayer.cpp.

### Vulnerability Description Key Phrases
- **weakness:** **heap-based buffer overflow**
- **product:** WebKitGTK
- **version:** through 2.36.0
- **component:** WebCoreTextureMapperLayersetContentsLayer in WebCore/platform/graphics/texmap/TextureMapperLayer.cpp

## CVE Reference Links Content Summary
Based on the provided information, here's a breakdown of the vulnerability associated with CVE-2022-30293:

**Root Cause:**
A memory corruption issue, specifically a heap-buffer-overflow, in the `WebCore::TextureMapperLayer::setContentsLayer` function. This occurs due to a race condition where a `TextureMapperPlatformLayerProxyGL` is destroyed, but `invalidate` has not been called, leaving a dangling pointer to a released layer, leading to a use-after-free when the proxy is later accessed.

**Weaknesses/Vulnerabilities:**
- Heap-buffer-overflow
- Use-after-free

**Impact of Exploitation:**
- Arbitrary code execution
- Denial of Service (application crash)

**Attack Vectors:**
- Processing maliciously crafted web content

**Required Attacker Capabilities/Position:**
- Ability to craft malicious web content.
- Victim must load the malicious web content in a vulnerable browser or application using WebKitGTK or WPE WebKit.

**Technical Details:**
The vulnerability occurs when a `WebGLRenderingContext` instance is created and destroyed. This context is attached to a `CoordinatedGraphicsLayer` as its `PlatformLayer`. The compositor thread uses a proxy for this `PlatformLayer` which is activated by the `TextureMapperLayer`. Normally, when a `WebGLRenderingContext` is destroyed the associated `CoordinatedGraphicsLayer` is also destroyed and the compositor calls `invalidate` on the proxy. However, under certain conditions (likely due to a race condition), the `PlatformLayer` is detached from the `CoordinatedGraphicsLayer` while the associated `GraphicsLayer` remains alive. This results in the compositor not calling `invalidate`. The proxy's reference is overwritten when the scene state is updated with a null `PlatformLayer`, losing the chance to call `invalidate`.  If the `TextureMapperLayer` is deleted before the proxy the use after free occurs during proxy deletion. A heap-buffer-overflow occurs within `setContentsLayer`

**Additional Notes:**
- The vulnerability is present in WebKitGTK and WPE WebKit before versions 2.36.1.
- The issue is triggered by detaching the `PlatformLayer` from the `CoordinatedGraphicsLayer` while keeping the `GraphicsLayer` alive, leading to a race condition during the destruction of layers and their proxies.
- The vulnerability can be triggered within 3-4 seconds after loading the malicious HTML page.
- The patch involves ensuring that the invalidate function is called on the proxy before it is deallocated
- This issue does not affect Apple platforms as it is specific to the WPE and GTK ports of WebKit
- Both CVE-2022-30293 and CVE-2022-30294 refer to the same underlying issue.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage | Combined Score | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|---------------|------------|-------------------|
| 1 | CWE-193 | Off-by-one Error | Base | Allowed | 0.6733 | dense, sparse, graph | dense: 0.539, sparse: 0.133, graph: 0.915 |
| 2 | CWE-190 | Integer Overflow or Wraparound | Base | Allowed | 0.6324 | dense, sparse, graph | dense: 0.561, sparse: 0.141, graph: 0.759 |
| 3 | CWE-124 | Buffer Underwrite ('Buffer Underflow') | Base | Allowed | 0.6187 | dense, sparse, graph | dense: 0.576, sparse: 0.112, graph: 0.745 |
| 4 | CWE-126 | Buffer Over-read | Variant | Allowed | 0.6021 | dense, sparse, graph | dense: 0.586, sparse: 0.137, graph: 0.784 |
| 5 | CWE-125 | Out-of-bounds Read | Base | Allowed | 0.5976 | dense, sparse, graph | dense: 0.554, sparse: 0.129, graph: 0.690 |
| 6 | CWE-681 | Incorrect Conversion between Numeric Types | Base | Allowed | 0.3965 | sparse, graph | sparse: 0.144, graph: 0.878 |
| 7 | CWE-122 | Heap-based Buffer Overflow | Variant | Allowed | 0.3696 | dense, sparse | dense: 0.604, sparse: 0.171 |
| 8 | CWE-839 | Numeric Range Comparison Without Minimum Check | Base | Allowed | 0.3477 | sparse, graph | sparse: 0.115, graph: 0.789 |
| 9 | CWE-131 | Incorrect Calculation of Buffer Size | Base | Allowed | 0.3426 | dense, sparse | dense: 0.543, sparse: 0.124 |
| 10 | CWE-120 | Buffer Copy without Checking Size of Input ('Classic Buffer Overflow') | Base | Allowed-with-Review | 0.3368 | sparse, graph | sparse: 0.113, graph: 0.807 |

