# Critic Input for CVE-2021-34549



# Original Analyzer Input
## Vulnerability Description
An issue was discovered in Tor before 0.4.6.5, aka TROVE-2021-005. Hashing is mishandled for certain retrieval of circuit data. Consequently. an attacker can trigger the use of an attacker-chosen circuit ID to cause algorithm inefficiency.

### Vulnerability Description Key Phrases
- **rootcause:** **mishandling of hashing**
- **impact:** algorithm inefficiency
- **vector:** retrieval of circuit data
- **attacker:** attacker
- **product:** Tor
- **version:** before 0.4.6.5

## CVE Reference Links Content Summary
```
{
  "vulnerability": {
    "root_cause": "The `chanid_circid_entry_hash()` function used in the circuit muxinfo hashtable employs an unsafe hash function, making it vulnerable to HashDoS attacks.",
    "weaknesses": [
      "The hash function `chanid_circid_entry_hash()` does not use SipHash, which is designed to prevent HashDoS attacks. This allows an attacker to create hash collisions."
    ],
    "impact": "An attacker can cause a denial-of-service (DoS) by creating many hash collisions, leading to excessive CPU usage by the Tor relay. Additionally, a timing oracle exists that can leak information about the number of circuits established by a relay.",
    "attack_vectors": [
      "An attacker needs to connect directly to an Onion Router.",
      "The attacker needs to craft specific circuit IDs to create hash collisions."
    ],
    "required_capabilities": "The attacker must know the number of channels established by the target Tor instance (or use the timing oracle to discover it). The attacker also needs the ability to connect to an Onion Router and send traffic to it."
  },
  "additional_information": {
    "timing_oracle": "A timing oracle exists where a ~3ms timing delta (amplified when queries are batched) reveals whether a Tor relay has established a specific number of channels.",
    "dos_traffic": "The DoS attack requires the attacker to send ~1.3 Mbit/s of traffic to the relay, potentially reaching 100% CPU utilization. The test program needed ~2.8 Mbits/s.",
        "mitigation": "The vulnerability is addressed by using SipHash instead of the naive hash function for circuit lookups in the circuitmux object. This change was included in Tor versions 0.3.5.15, 0.4.4.9, 0.4.5.9, and 0.4.6.5."
  }
}
```

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage | Combined Score | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|---------------|------------|-------------------|
| 1 | CWE-328 | Use of Weak Hash | Base | Allowed | 0.6124 | dense, sparse, graph | dense: 0.552, sparse: 0.201, graph: 0.619 |
| 2 | CWE-916 | Use of Password Hash With Insufficient Computational Effort | Base | Allowed | 0.5804 | dense, sparse, graph | dense: 0.512, sparse: 0.183, graph: 0.613 |
| 3 | CWE-321 | Use of Hard-coded Cryptographic Key | Variant | Allowed | 0.4694 | dense, sparse, graph | dense: 0.518, sparse: 0.162, graph: 0.439 |
| 4 | CWE-131 | Incorrect Calculation of Buffer Size | Base | Allowed | 0.3405 | dense, sparse | dense: 0.490, sparse: 0.166 |
| 5 | CWE-327 | Use of a Broken or Risky Cryptographic Algorithm | Class | Allowed-with-Review | 0.3147 | dense, sparse, graph | dense: 0.498, sparse: 0.186, graph: 0.503 |
| 6 | CWE-407 | Inefficient Algorithmic Complexity | Class | Allowed-with-Review | 0.2549 | dense, sparse | dense: 0.511, sparse: 0.311 |
| 7 | CWE-330 | Use of Insufficiently Random Values | Class | Discouraged | 0.2154 | dense, sparse, graph | dense: 0.489, sparse: 0.178, graph: 0.377 |
| 8 | CWE-617 | Reachable Assertion | Base | Allowed | 0.0994 | sparse | sparse: 0.174 |
| 9 | CWE-290 | Authentication Bypass by Spoofing | Base | Allowed | 0.0979 | sparse | sparse: 0.171 |
| 10 | CWE-347 | Improper Verification of Cryptographic Signature | Base | Allowed | 0.0974 | sparse | sparse: 0.170 |



# Analysis to Review
# Summary
| CWE ID | CWE Name | Confidence | CWE Abstraction Level | CWE Vulnerability Mapping Label | CWE-Vulnerability Mapping Notes |
|---|---|---|---|---|---|
| CWE-328 | Use of Weak Hash | 0.9 | Base | Allowed | Primary CWE: The vulnerability stems from mishandling hashing, making it vulnerable to HashDoS attacks due to the use of an unsafe hash function. |
| CWE-407 | Inefficient Algorithmic Complexity | 0.7 | Class | Allowed-with-Review | Secondary Candidate: The impact of the vulnerability is algorithm inefficiency, which can lead to denial of service. |

## Evidence and Confidence

*   **Confidence Score:** 0.8
*   **Evidence Strength:** HIGH

- **Analysis and Justification:**  
  - *Explanation:* The vulnerability description highlights a **mishandling of hashing** that leads to algorithm inefficiency. The CVE Reference Links Content Summary confirms that the `chanid_circid_entry_hash()` function employs an unsafe hash function, making it vulnerable to HashDoS attacks. This aligns with CWE-328 (Use of Weak Hash), which describes the use of an algorithm that produces a digest that does not meet security expectations for a hash function. The provided MITRE mapping guidance for CWE-328 indicates that its usage is ALLOWED, making it a suitable choice. Additionally, the **impact** of the vulnerability, algorithm inefficiency, can be related to CWE-407 (Inefficient Algorithmic Complexity), though this is less direct and more of a consequence of the weak hash. CWE-328 is chosen as the primary CWE due to its direct connection to the **root cause**, while CWE-407 is a secondary factor related to the **impact**.

  - *Relationship Analysis:* CWE-328 is a Base-level CWE, which is preferred according to the MITRE mapping guidance. It is also related to CWE-916 (Use of Password Hash With Insufficient Computational Effort). CWE-407 is a Class-level CWE, and while less specific, it represents the inefficiency caused by the weak hashing algorithm.

- **Confidence Score:**  
  - Confidence: 0.9 (High confidence due to the clear technical description and CVE reference materials supporting the mapping to CWE-328, with CWE-407 as a relevant secondary factor).

---

# CWE Examples from Database


## Known Examples for CWE-916: Use of Password Hash With Insufficient Computational Effort
### Observed Examples
- **CVE-2008-1526** [https://www.cve.org/CVERecord?id=CVE-2008-1526](https://www.cve.org/CVERecord?id=CVE-2008-1526): Router does not use a salt with a hash, making it easier to crack passwords.
- **CVE-2006-1058** [https://www.cve.org/CVERecord?id=CVE-2006-1058](https://www.cve.org/CVERecord?id=CVE-2006-1058): Router does not use a salt with a hash, making it easier to crack passwords.
- **CVE-2008-4905** [https://www.cve.org/CVERecord?id=CVE-2008-4905](https://www.cve.org/CVERecord?id=CVE-2008-4905): Blogging software uses a hard-coded salt when calculating a password hash.
- **CVE-2002-1657** [https://www.cve.org/CVERecord?id=CVE-2002-1657](https://www.cve.org/CVERecord?id=CVE-2002-1657): Database server uses the username for a salt when encrypting passwords, simplifying brute force attacks.
- **CVE-2001-0967** [https://www.cve.org/CVERecord?id=CVE-2001-0967](https://www.cve.org/CVERecord?id=CVE-2001-0967): Server uses a constant salt when encrypting passwords, simplifying brute force attacks.
- **CVE-2005-0408** [https://www.cve.org/CVERecord?id=CVE-2005-0408](https://www.cve.org/CVERecord?id=CVE-2005-0408): chain: product generates predictable MD5 hashes using a constant value combined with username, allowing authentication bypass.
### Top 25 Examples
- **CVE-2020-25754**: An issue was discovered on Enphase Envoy R3.x and D4.x devices. There is a custom PAM module for user authentication that circumvents traditional user authentication. This module uses a password derived from the MD5 hash of the username and serial number. The serial number can be retrieved by an unauthenticated user at /info.xml. Attempts to change the user password via passwd or other tools have no effect.
- **CVE-2021-22741**: Use of Password Hash with Insufficient Computational Effort vulnerability exists in ClearSCADA (all versions), EcoStruxure Geo SCADA Expert 2019 (all versions), and EcoStruxure Geo SCADA Expert 2020 (V83.7742.1 and prior), which could cause the revealing of account credentials when server database files are available. Exposure of these files to an attacker can make the system vulnerable to password decryption attacks. Note that “.sde” configuration export files do not contain user account password hashes.
- **CVE-2021-32519**: Use of password hash with insufficient computational effort vulnerability in QSAN Storage Manager, XEVO, SANOS allows remote attackers to recover the plain-text password by brute-forcing the MD5 hash. The referred vulnerability has been solved with the updated version of QSAN Storage Manager v3.3.2, QSAN XEVO v2.1.0, and QSAN SANOS v2.1.0.
- **CVE-2021-33003**: Delta Electronics DIAEnergie Version 1.7.5 and prior may allow an attacker to retrieve passwords in cleartext due to a weak hashing algorithm.


# Relevant CWE Specifications

## CWE-916: Use of Password Hash With Insufficient Computational Effort
**Abstraction:** Base
**Status:** Incomplete

### Description
The product generates a hash for a password, but it uses a scheme that does not provide a sufficient level of computational effort that would make password cracking attacks infeasible or expensive.

### Extended Description


Many password storage mechanisms compute a hash and store the hash, instead of storing the original password in plaintext. In this design, authentication involves accepting an incoming password, computing its hash, and comparing it to the stored hash.


Many hash algorithms are designed to execute quickly with minimal overhead, even cryptographic hashes. However, this efficiency is a problem for password storage, because it can reduce an attacker's workload for brute-force password cracking. If an attacker can obtain the hashes through some other method (such as SQL injection on a database that stores hashes), then the attacker can store the hashes offline and use various techniques to crack the passwords by computing hashes efficiently. Without a built-in workload, modern attacks can compute large numbers of hashes, or even exhaust the entire space of all possible passwords, within a very short amount of time, using massively-parallel computing (such as cloud computing) and GPU, ASIC, or FPGA hardware. In such a scenario, an efficient hash algorithm helps the attacker.


There are several properties of a hash scheme that are relevant to its strength against an offline, massively-parallel attack:


  - The amount of CPU time required to compute the hash ("stretching")

  - The amount of memory required to compute the hash ("memory-hard" operations)

  - Including a random value, along with the password, as input to the hash computation ("salting")

  - Given a hash, there is no known way of determining an input (e.g., a password) that produces this hash value, other than by guessing possible inputs ("one-way" hashing)

  - Relative to the number of all possible hashes that can be generated by the scheme, there is a low likelihood of producing the same hash for multiple different inputs ("collision resistance")

Note that the security requirements for the product may vary depending on the environment and the value of the passwords. Different schemes might not provide all of these properties, yet may still provide sufficient security for the environment. Conversely, a solution might be very strong in preserving one property, which still being very weak for an attack against another property, or it might not be able to significantly reduce the efficiency of a massively-parallel attack.

### Alternative Terms
None

### Relationships
ChildOf -> CWE-328
ChildOf -> CWE-327
ParentOf -> CWE-759
ParentOf -> CWE-760

### Mapping Guidance
**Usage:** Allowed
**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.
**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.
**Reasons:**
- Acceptable-Use


### Potential Mitigations
**Mitigation 1:**
- **Phase:** Architecture and Design
- **Effectiveness:** High
- **Description:** 

Use an adaptive hash function that can be configured to change the amount of computational effort needed to compute the hash, such as the number of iterations ("stretching") or the amount of memory required. Some hash functions perform salting automatically. These functions can significantly increase the overhead for a brute force attack compared to intentionally-fast functions such as MD5. For example, rainbow table attacks can become infeasible due to the high computing overhead. Finally, since computing power gets faster and cheaper over time, the technique can be reconfigured to increase the workload without forcing an entire replacement of the algorithm in use.


Some hash functions that have one or more of these desired properties include bcrypt [REF-291], scrypt [REF-292], and PBKDF2 [REF-293]. While there is active debate about which of these is the most effective, they are all stronger than using salts with hash functions with very little computing overhead.


Note that using these functions can have an impact on performance, so they require special consideration to avoid denial-of-service attacks. However, their configurability provides finer control over how much CPU and memory is used, so it could be adjusted to suit the environment's needs.


**Mitigation 2:**
- **Phase:** Implementation, Architecture and Design
- **Description:** When using industry-approved techniques, use them correctly. Don't cut corners by skipping resource-intensive steps (CWE-325). These steps are often essential for preventing common attacks.




### Observed Examples
- **CVE-2008-1526:** Router does not use a salt with a hash, making it easier to crack passwords.
- **CVE-2006-1058:** Router does not use a salt with a hash, making it easier to crack passwords.
- **CVE-2008-4905:** Blogging software uses a hard-coded salt when calculating a password hash.



## CWE-328: Use of Weak Hash
**Abstraction:** Base
**Status:** Draft

### Description
The product uses an algorithm that produces a digest (output value) that does not meet security expectations for a hash function that allows an adversary to reasonably determine the original input (preimage attack), find another input that can produce the same hash (2nd preimage attack), or find multiple inputs that evaluate to the same hash (birthday attack).

### Extended Description


A hash function is defined as an algorithm that maps arbitrarily sized data into a fixed-sized digest (output) such that the following properties hold:


  1. The algorithm is not invertible (also called "one-way" or "not reversible")

  1. The algorithm is deterministic; the same input produces the same digest every time

 Building on this definition, a cryptographic hash function must also ensure that a malicious actor cannot leverage the hash function to have a reasonable chance of success at determining any of the following:

  1. the original input (preimage attack), given only the digest

  1. another input that can produce the same digest (2nd preimage attack), given the original input

  1. a set of two or more inputs that evaluate to the same digest (birthday attack), given the actor can arbitrarily choose the inputs to be hashed and can do so a reasonable amount of times

What is regarded as "reasonable" varies by context and threat model, but in general, "reasonable" could cover any attack that is more efficient than brute force (i.e., on average, attempting half of all possible combinations). Note that some attacks might be more efficient than brute force but are still not regarded as achievable in the real world.

Any algorithm that does not meet the above conditions will generally be considered weak for general use in hashing.


In addition to algorithmic weaknesses, a hash function can be made weak by using the hash in a security context that breaks its security guarantees. For example, using a hash function without a salt for storing passwords (that are sufficiently short) could enable an adversary to create a "rainbow table" [REF-637] to recover the password under certain conditions; this attack works against such hash functions as MD5, SHA-1, and SHA-2.


### Alternative Terms
None

### Relationships
ChildOf -> CWE-326
ChildOf -> CWE-327
ParentOf -> CWE-916

### Mapping Guidance
**Usage:** Allowed
**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.
**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.
**Reasons:**
- Acceptable-Use


### Potential Mitigations
**Mitigation 1:**
- **Phase:** Architecture and Design
- **Effectiveness:** High
- **Description:** 

Use an adaptive hash function that can be configured to change the amount of computational effort needed to compute the hash, such as the number of iterations ("stretching") or the amount of memory required. Some hash functions perform salting automatically. These functions can significantly increase the overhead for a brute force attack compared to intentionally-fast functions such as MD5. For example, rainbow table attacks can become infeasible due to the high computing overhead. Finally, since computing power gets faster and cheaper over time, the technique can be reconfigured to increase the workload without forcing an entire replacement of the algorithm in use.


Some hash functions that have one or more of these desired properties include bcrypt [REF-291], scrypt [REF-292], and PBKDF2 [REF-293]. While there is active debate about which of these is the most effective, they are all stronger than using salts with hash functions with very little computing overhead.


Note that using these functions can have an impact on performance, so they require special consideration to avoid denial-of-service attacks. However, their configurability provides finer control over how much CPU and memory is used, so it could be adjusted to suit the environment's needs.




### Additional Notes
**[Maintenance]** Since CWE 4.4, various cryptography-related entries including CWE-328 have been slated for extensive research, analysis, and community consultation to define consistent terminology, improve relationships, and reduce overlap or duplication. As of CWE 4.6, this work is still ongoing.



### Observed Examples
- **CVE-2022-30320:** Programmable Logic Controller (PLC) uses a protocol with a cryptographically insecure hashing algorithm for passwords.
- **CVE-2005-4900:** SHA-1 algorithm is not collision-resistant.
- **CVE-2020-25685:** DNS product uses a weak hash (CRC32 or SHA-1) of the query name, allowing attacker to forge responses by computing domain names with the same hash.



## CWE-407: Inefficient Algorithmic Complexity
**Abstraction:** Class
**Status:** Incomplete

### Description
An algorithm in a product has an inefficient worst-case computational complexity that may be detrimental to system performance and can be triggered by an attacker, typically using crafted manipulations that ensure that the worst case is being reached.

### Extended Description
Not provided

### Alternative Terms
Quadratic Complexity: Used when the algorithmic complexity is related to the square of the number of inputs (N^2)

### Relationships
ChildOf -> CWE-405
ParentOf -> CWE-1333

### Mapping Guidance
**Usage:** Allowed-with-Review
**Rationale:** This CWE entry is a Class and might have Base-level children that would be more appropriate
**Comments:** Examine children of this entry to see if there is a better fit
**Reasons:**
- Abstraction




### Observed Examples
- **CVE-2021-32617:** C++ library for image metadata has "quadratic complexity" issue with unnecessarily repetitive parsing each time an invalid character is encountered
- **CVE-2020-10735:** Python has "quadratic complexity" issue when converting string to int with many digits in unexpected bases
- **CVE-2020-5243:** server allows ReDOS with crafted User-Agent strings, due to overlapping capture groups that cause excessive backtracking.

