# Vulnerability Information: CVE-2022-1923

## Vulnerability Description
DOS / potential heap overwrite in mkv demuxing using bzip decompression. Integer overflow in matroskademux element in bzip decompression function which causes a segfault, or could cause a heap overwrite, depending on libc and OS. Depending on the libc used, and the underlying OS capabilities, it could be just a segfault or a heap overwrite. If the libc uses mmap for large chunks, and the OS supports mmap, then it is just a segfault (because the realloc before the integer overflow will use mremap to reduce the size of the chunk, and it will start to write to unmapped memory). However, if using a libc implementation that does not use mmap, or if the OS does not support mmap while using libc, then this could result in a heap overwrite.

### Vulnerability Description Key Phrases
- **rootcause:** **integer overflow in matroskademux element in bzip decompression function**
- **impact:** segfault and heap overwrite
- **vector:** mkv demuxing using bzip decompression

### CWE for similar CVE Descriptions
### Primary CWE Match
CWE-190

#### Top CWEs
- CWE-190 (Count: 12)

## CVE Reference Links Content Summary
Based on the provided information, here's an analysis of CVE-2022-1923:

**Root Cause of Vulnerability:**

The vulnerability is caused by an integer overflow in the `gst_matroska_decompress_data` function within the GStreamer matroska demuxer plugin when handling zlib-compressed data. The `zlib` data counters are 64-bit, but 32-bit integers are used to store the size of decompressed data in `gst_matroska_decompress_data`, leading to an overflow when a large decompressed size is encountered.

**Weaknesses/Vulnerabilities Present:**

*   **Integer Overflow:** A 32-bit integer is used to store the size of the decompressed data after the zlib decompression, while the zlib stream keeps track of the data length using 64-bit counters. If the size of the decompressed data exceeds the capacity of the 32-bit integer, it will wrap around.
*   **Heap Overflow (Potential):** If the integer overflow occurs during memory reallocation (using realloc), this may lead to a smaller memory region than required being allocated. Subsequent write operations will lead to a heap overwrite.

**Impact of Exploitation:**

*   **Denial of Service (DoS):** The integer overflow and the memory allocation issues can lead to a segmentation fault, causing the application to crash.
*   **Arbitrary Code Execution (Potential):** Depending on the libc implementation and OS capabilities, the heap overflow could potentially be exploited to overwrite heap metadata or other memory regions leading to arbitrary code execution.

**Attack Vectors:**

*   **Malicious Media File:** A specially crafted Matroska file (.mkv) containing a zlib compressed block with a large decompressed size triggers the vulnerability when processed by a vulnerable version of gstreamer.

**Required Attacker Capabilities/Position:**

*   The attacker needs the ability to create or modify a Matroska file and then supply it to the vulnerable Gstreamer application.

**Additional Information:**

*   The provided example crash involves a file where the decompressed size is `0x100000000`, which when stored into a 32 bit integer, would overflow.
*   The vulnerability was discovered by Adam Doupe.
*   The issue was reported to the gstreamer project on their gitlab instance.
*   The provided proof of concept (.mkv file) causes the application to crash within ~8 seconds on the reporter's system.
*   The Debian Security Advisory (DSA 5204-1) and Debian LTS Advisory (DLA 3069-1) indicate that multiple vulnerabilities were addressed in gst-plugins-good1.0, including CVE-2022-1923.

This information provides more detail than the official CVE description, outlining the specific cause of the integer overflow and potential consequences including the possibility of heap overwrite leading to arbitrary code execution.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage | Combined Score | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|---------------|------------|-------------------|
| 1 | CWE-190 | Integer Overflow or Wraparound | Base | Allowed | 1.1082 | dense, sparse, graph | dense: 0.563, sparse: 1.000, graph: 0.712 |
| 2 | CWE-789 | Memory Allocation with Excessive Size Value | Variant | Allowed | 0.8232 | dense, sparse, graph | dense: 0.499, sparse: 0.639, graph: 0.773 |
| 3 | CWE-191 | Integer Underflow (Wrap or Wraparound) | Base | Allowed | 0.7818 | dense, sparse, graph | dense: 0.494, sparse: 0.566, graph: 0.591 |
| 4 | CWE-1284 | Improper Validation of Specified Quantity in Input | Base | Allowed | 0.7190 | sparse, graph | sparse: 0.632, graph: 1.000 |
| 5 | CWE-681 | Incorrect Conversion between Numeric Types | Base | Allowed | 0.5843 | sparse, graph | sparse: 0.550, graph: 0.754 |
| 6 | CWE-125 | Out-of-bounds Read | Base | Allowed | 0.5801 | dense, sparse | dense: 0.473, sparse: 0.601 |
| 7 | CWE-122 | Heap-based Buffer Overflow | Variant | Allowed | 0.5757 | dense, sparse | dense: 0.547, sparse: 0.611 |
| 8 | CWE-197 | Numeric Truncation Error | Base | Allowed | 0.5658 | dense, sparse | dense: 0.469, sparse: 0.579 |
| 9 | CWE-193 | Off-by-one Error | Base | Allowed | 0.5656 | dense, sparse | dense: 0.467, sparse: 0.580 |
| 10 | CWE-126 | Buffer Over-read | Variant | Allowed | 0.5356 | dense, sparse | dense: 0.530, sparse: 0.550 |

