# Vulnerability Information: CVE-2022-29503

## Vulnerability Description
A **memory corruption** vulnerability exists in the libpthread linuxthreads functionality of uClibC 0.9.33.2 and uClibC-ng 1.0.40. Thread allocation can lead to **memory corruption**. An attacker can create threads to trigger this vulnerability.

### Vulnerability Description Key Phrases
- **rootcause:** **improper memory management**
- **weakness:** **memory corruption**
- **product:** uClibC
- **version:** 0.9.33.2 and 1.0.40
- **component:** libpthread linuxthreads

## CVE Reference Links Content Summary
- **Root cause of vulnerability**: The vulnerability stems from the way `pthread_create` allocates thread stacks using `mmap` with the `MAP_FIXED` flag in uClibC and uClibC-ng's libpthread implementations. Specifically, the thread stack address is calculated by decrementing from a fixed start address, and with each thread creation, the address decreases. Due to the use of `MAP_FIXED`, when a large number of threads are created, these stack allocations eventually overwrite existing memory mappings, including libraries and the application's own code.

- **Weaknesses/vulnerabilities present**:
    - Improper Restriction of Operations within the Bounds of a Memory Buffer (CWE-119)
    - Incorrect use of `mmap` with `MAP_FIXED`.
    - Predictable stack address allocation for threads.
    - Lack of validation for stack address, leading to potential overwriting of existing mappings.

- **Impact of exploitation**:
    - Memory corruption due to overwriting of memory regions.
    - Application crash or unexpected behavior.
    - Potential for arbitrary code execution if the attacker can control the content of the overwritten memory.

- **Attack vectors**:
    - Creation of a large number of threads.
    - This can be triggered remotely if the application exposes an interface that allows for the creation of multiple threads.

- **Required attacker capabilities/position**:
    - Ability to trigger the creation of multiple threads in the affected application.
    - No specific privileges are required, but the application must use the vulnerable version of libpthread

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage | Combined Score | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|---------------|------------|-------------------|
| 1 | CWE-190 | Integer Overflow or Wraparound | Base | Allowed | 0.7175 | dense, sparse, graph | dense: 0.516, sparse: 0.344, graph: 0.734 |
| 2 | CWE-770 | Allocation of Resources Without Limits or Throttling | Base | Allowed | 0.5483 | sparse, graph | sparse: 0.334, graph: 1.000 |
| 3 | CWE-197 | Numeric Truncation Error | Base | Allowed | 0.5313 | sparse, graph | sparse: 0.346, graph: 0.932 |
| 4 | CWE-789 | Memory Allocation with Excessive Size Value | Variant | Allowed | 0.5304 | dense, sparse, graph | dense: 0.489, sparse: 0.171, graph: 0.650 |
| 5 | CWE-787 | Out-of-bounds Write | Base | Allowed | 0.4859 | sparse, graph | sparse: 0.314, graph: 0.857 |
| 6 | CWE-134 | Use of Externally-Controlled Format String | Base | Allowed | 0.4816 | sparse, graph | sparse: 0.306, graph: 0.857 |
| 7 | CWE-366 | Race Condition within a Thread | Base | Allowed | 0.4215 | dense, sparse | dense: 0.507, sparse: 0.293 |
| 8 | CWE-476 | NULL Pointer Dereference | Base | Allowed | 0.4183 | dense, sparse | dense: 0.509, sparse: 0.285 |
| 9 | CWE-415 | Double Free | Variant | Allowed | 0.3899 | dense, sparse | dense: 0.497, sparse: 0.304 |
| 10 | CWE-416 | Use After Free | Variant | Allowed | 0.3838 | dense, sparse | dense: 0.508, sparse: 0.283 |

