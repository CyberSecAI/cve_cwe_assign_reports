# Critic Input for CVE-2021-0268



# Original Analyzer Input
## Vulnerability Description
An Improper Neutralization of CRLF Sequences in HTTP Headers (HTTP Response Splitting) weakness in J-web of Juniper Networks Junos OS leads to buffer overflows, segment faults, or other impacts, which allows an attacker to modify the integrity of the device and exfiltration information from the device without authentication. The weakness can be exploited to facilitate cross-site scripting (XSS), cookie manipulation (modifying session cookies, stealing cookies) and more. This weakness can also be exploited by directing a user to a seemingly legitimate link from the affected site. The attacker requires no special access or permissions to the device to carry out such attacks. This issue affects Juniper Networks Junos OS 18.1 versions prior to 18.1R3-S11 18.2 versions prior to 18.2R3-S5 18.3 versions prior to 18.3R2-S4, 18.3R3-S3 18.4 versions prior to 18.4R2-S5, 18.4R3-S3 19.1 versions prior to 19.1R2-S2, 19.1R3-S2 19.2 versions prior to 19.2R1-S5, 19.2R2 19.3 versions prior to 19.3R3 19.4 versions prior to 19.4R1-S3, 19.4R2, 19.4R3 20.1 versions prior to 20.1R1-S2, 20.1R2. This issue does not affect Juniper Networks Junos OS versions prior to 18.1R1.

### Vulnerability Description Key Phrases
- **rootcause:** **improper neutralization of CRLF sequences in HTTP headers**
- **weakness:** **HTTP response splitting**
- **impact:** ['modify the integrity of the device', 'exfiltration information from the device']
- **product:** Juniper Networks Junos OS
- **version:** 18.1 to 20.1
- **component:** J-web

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage | Combined Score | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|---------------|------------|-------------------|
| 1 | CWE-1285 | Improper Validation of Specified Index, Position, or Offset in Input | Base | Allowed | 1.1013 | dense, sparse, graph | dense: 0.634, sparse: 1.000, graph: 0.593 |
| 2 | CWE-606 | Unchecked Input for Loop Condition | Base | Allowed | 1.0749 | dense, sparse, graph | dense: 0.614, sparse: 1.000, graph: 0.547 |
| 3 | CWE-401 | Missing Release of Memory after Effective Lifetime | Variant | Allowed | 1.0022 | dense, sparse, graph | dense: 0.642, sparse: 1.000, graph: 0.538 |
| 4 | CWE-113 | Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Request/Response Splitting') | Variant | Allowed | 0.8731 | dense, sparse | dense: 0.747, sparse: 1.000 |
| 5 | CWE-364 | Signal Handler Race Condition | Base | Allowed | 0.7871 | sparse, graph | sparse: 1.000, graph: 0.602 |
| 6 | CWE-184 | Incomplete List of Disallowed Inputs | Base | Allowed | 0.7871 | sparse, graph | sparse: 1.000, graph: 0.602 |
| 7 | CWE-250 | Execution with Unnecessary Privileges | Base | Allowed | 0.5720 | sparse | sparse: 1.000 |
| 8 | CWE-1286 | Improper Validation of Syntactic Correctness of Input | Base | Allowed | 0.5720 | sparse | sparse: 1.000 |
| 9 | CWE-410 | Insufficient Resource Pool | Base | Allowed | 0.5720 | sparse | sparse: 1.000 |
| 10 | CWE-497 | Exposure of Sensitive System Information to an Unauthorized Control Sphere | Base | Allowed | 0.5720 | sparse | sparse: 1.000 |



# Analysis to Review
# Summary
| CWE ID | CWE Name | Confidence | CWE Abstraction Level | CWE Vulnerability Mapping Label | CWE-Vulnerability Mapping Notes |
|---|---|---|---|---|---|
| CWE-113 | Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Request/Response Splitting') | 0.9 | Variant | Primary | Allowed |

## Evidence and Confidence

*   **Confidence Score:** 0.9
*   **Evidence Strength:** HIGH

- **Analysis and Justification:**  
  - *Explanation:* The **Vulnerability Description** explicitly states "**Improper Neutralization of CRLF Sequences in HTTP Headers (HTTP Response Splitting)** weakness". This directly aligns with CWE-113, "Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Request/Response Splitting')". The **Vulnerability Description Key Phrases** confirms this with "**rootcause:** **improper neutralization of CRLF sequences in HTTP headers**" and "**weakness:** **HTTP response splitting**". The Retriever Results also list CWE-113 with a high score. CWE-113 is a Variant, which is a preferred level of abstraction for mapping. The MITRE mapping guidance for CWE-113 indicates this is ALLOWED.
  
  - *Relationship Analysis:* No direct relationships found, so there's nothing to influence my decision.

- **Confidence Score:**  
  - Confidence: 0.9 (High evidence from technical description and CVE reference materials)

# CWE Examples from Database


## Known Examples for CWE-113: Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Request/Response Splitting')
### Observed Examples
- **CVE-2020-15811** [https://www.cve.org/CVERecord?id=CVE-2020-15811](https://www.cve.org/CVERecord?id=CVE-2020-15811): Chain: Proxy uses a substring search instead of parsing the Transfer-Encoding header (CWE-697), allowing request splitting (CWE-113) and cache poisoning
- **CVE-2021-41084** [https://www.cve.org/CVERecord?id=CVE-2021-41084](https://www.cve.org/CVERecord?id=CVE-2021-41084): Scala-based HTTP interface allows request splitting and response splitting through header names, header values, status reasons, and URIs
- **CVE-2018-12116** [https://www.cve.org/CVERecord?id=CVE-2018-12116](https://www.cve.org/CVERecord?id=CVE-2018-12116): Javascript-based framework allows request splitting through a path option of an HTTP request
- **CVE-2004-2146** [https://www.cve.org/CVERecord?id=CVE-2004-2146](https://www.cve.org/CVERecord?id=CVE-2004-2146): Application accepts CRLF in an object ID, allowing HTTP response splitting.
- **CVE-2004-1656** [https://www.cve.org/CVERecord?id=CVE-2004-1656](https://www.cve.org/CVERecord?id=CVE-2004-1656): Shopping cart allows HTTP response splitting to perform HTML injection via CRLF in a parameter for a url
- **CVE-2005-2060** [https://www.cve.org/CVERecord?id=CVE-2005-2060](https://www.cve.org/CVERecord?id=CVE-2005-2060): Bulletin board allows response splitting via CRLF in parameter.
- **CVE-2004-2512** [https://www.cve.org/CVERecord?id=CVE-2004-2512](https://www.cve.org/CVERecord?id=CVE-2004-2512): Response splitting via CRLF in PHPSESSID.
- **CVE-2005-1951** [https://www.cve.org/CVERecord?id=CVE-2005-1951](https://www.cve.org/CVERecord?id=CVE-2005-1951): e-commerce app allows HTTP response splitting using CRLF in object id parameters
### Top 25 Examples
- **CVE-2021-0268**: An Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Response Splitting') weakness in J-web of Juniper Networks Junos OS leads to buffer overflows, segment faults, or other impacts, which allows an attacker to modify the integrity of the device and exfiltration information from the device without authentication. The weakness can be exploited to facilitate cross-site scripting (XSS), cookie manipulation (modifying session cookies, stealing cookies) and more. This weakness can also be exploited by directing a user to a seemingly legitimate link from the affected site. The attacker requires no special access or permissions to the device to carry out such attacks. This issue affects: Juniper Networks Junos OS: 18.1 versions prior to 18.1R3-S11; 18.2 versions prior to 18.2R3-S5; 18.3 versions prior to 18.3R2-S4, 18.3R3-S3; 18.4 versions prior to 18.4R2-S5, 18.4R3-S3; 19.1 versions prior to 19.1R2-S2, 19.1R3-S2; 19.2 versions prior to 19.2R1-S5, 19.2R2; 19.3 versions prior to 19.3R3; 19.4 versions prior to 19.4R1-S3, 19.4R2, 19.4R3; 20.1 versions prior to 20.1R1-S2, 20.1R2. This issue does not affect Juniper Networks Junos OS versions prior to 18.1R1.
- **CVE-2021-28979**: SafeNet KeySecure Management Console 8.12.0 is vulnerable to HTTP response splitting attacks. A remote attacker could exploit this vulnerability using specially-crafted URL to cause the server to return a split response, once the URL is clicked.


# Relevant CWE Specifications

## CWE-113: Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Request/Response Splitting')
**Abstraction:** Variant
**Status:** Incomplete

### Description
The product receives data from an HTTP agent/component (e.g., web server, proxy, browser, etc.), but it does not neutralize or incorrectly neutralizes CR and LF characters before the data is included in outgoing HTTP headers.

### Extended Description


 HTTP agents or components may include a web server, load balancer, reverse proxy, web caching proxy, application firewall, web browser, etc. Regardless of the role, they are expected to maintain coherent, consistent HTTP communication state across all components. However, including unexpected data in an HTTP header allows an attacker to specify the entirety of the HTTP message that is rendered by the client HTTP agent (e.g., web browser) or back-end HTTP agent (e.g., web server), whether the message is part of a request or a response. 


When an HTTP request contains unexpected CR and LF characters, the server may respond with an output stream that is interpreted as "splitting" the stream into two different HTTP messages instead of one. CR is carriage return, also given by %0d or \r, and LF is line feed, also given by %0a or \n.


In addition to CR and LF characters, other valid/RFC compliant special characters and unique character encodings can be utilized, such as HT (horizontal tab, also given by %09 or \t) and SP (space, also given as + sign or %20).


These types of unvalidated and unexpected data in HTTP message headers allow an attacker to control the second "split" message to mount attacks such as server-side request forgery, cross-site scripting, and cache poisoning attacks.


HTTP response splitting weaknesses may be present when:


  1. Data enters a web application through an untrusted source, most frequently an HTTP request.

  1. The data is included in an HTTP response header sent to a web user without neutralizing malicious characters that can be interpreted as separator characters for headers.



### Alternative Terms
HTTP Request Splitting
HTTP Response Splitting

### Relationships
ChildOf -> CWE-93
CanPrecede -> CWE-79
ChildOf -> CWE-20
ChildOf -> CWE-436

### Mapping Guidance
**Usage:** Allowed
**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.
**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.
**Reasons:**
- Acceptable-Use


### Potential Mitigations
**Mitigation 1:**
- **Phase:** Implementation
- **Strategy:** Input Validation
- **Description:** Construct HTTP headers very carefully, avoiding the use of non-validated input data.

**Mitigation 2:**
- **Phase:** Implementation
- **Strategy:** Input Validation
- **Description:** 

Assume all input is malicious. Use an "accept known good" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. If an input does not strictly conform to specifications, reject it or transform it into something that conforms.


When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, "boat" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as "red" or "blue."


Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.


**Mitigation 3:**
- **Phase:** Implementation
- **Strategy:** Output Encoding
- **Description:** Use and specify an output encoding that can be handled by the downstream component that is reading the output. Common encodings include ISO-8859-1, UTF-7, and UTF-8. When an encoding is not specified, a downstream component may choose a different encoding, either by assuming a default encoding or automatically inferring which encoding is being used, which can be erroneous. When the encodings are inconsistent, the downstream component might treat some character or byte sequences as special, even if they are not special in the original encoding. Attackers might then be able to exploit this discrepancy and conduct injection attacks; they even might be able to bypass protection mechanisms that assume the original encoding is also being used by the downstream component.




### Observed Examples
- **CVE-2020-15811:** Chain: Proxy uses a substring search instead of parsing the Transfer-Encoding header (CWE-697), allowing request splitting (CWE-113) and cache poisoning
- **CVE-2021-41084:** Scala-based HTTP interface allows request splitting and response splitting through header names, header values, status reasons, and URIs
- **CVE-2018-12116:** Javascript-based framework allows request splitting through a path option of an HTTP request

