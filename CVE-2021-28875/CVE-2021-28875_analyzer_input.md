# Vulnerability Information: CVE-2021-28875

## Vulnerability Description
In the standard library in Rust before 1.50.0, read_to_end() does not validate the return value from Read in an unsafe context. This bug could lead to a buffer overflow.

### Vulnerability Description Key Phrases
- **impact:** buffer overflow
- **product:** Rust standard library
- **version:** before 1.50.0
- **component:** read_to_end()

## CVE Reference Links Content Summary
Based on the provided content, here's a breakdown of the vulnerability:

**Root Cause:**

- The vulnerability lies in the `read_to_end_with_reservation()` function within the Rust standard library's `std::io` module.
- A malicious implementation of the `Read` trait could return a value from its `read` method that is larger than the provided buffer.
- The `read_to_end_with_reservation()` function increments an internal length counter (`g.len`) by the return value of the `read` method, without properly checking if the result remains within the bounds of the buffer.

**Weaknesses/Vulnerabilities:**

- **Heap Buffer Overflow:** When a malicious `Read` implementation returns a length greater than the available buffer space, `g.len` can be increased beyond the capacity of the underlying `Vec<u8>`. This leads to an out-of-bounds write during the next read operation or a double free due to length exceeding capacity.
- **Unsafe Length Manipulation:** The code uses `g.buf.set_len(capacity)` which can set the length to an arbitrary capacity, potentially causing issues if the capacity is smaller than the size of the buffer being written to.
- **Violation of API Contract:** The `Read` trait's contract is violated when the returned `n` value exceeds the provided buffer's length.

**Impact of Exploitation:**

- **Memory Corruption:** Writing past the end of the allocated buffer can corrupt heap metadata or other data structures, leading to crashes.
- **Denial of Service:** The vulnerability can lead to program termination due to a double free, or other memory corruption issues.
- **Potential for Arbitrary Code Execution:** Although not explicitly stated, the potential exists, given memory corruption in the heap. This depends on how the heap is laid out, however.

**Attack Vectors:**

- **Malicious `Read` implementation:** An attacker could provide a custom implementation of the `Read` trait that deliberately returns values larger than the buffer provided to the `read()` call.
- **Indirect Invocation:** The vulnerability can be indirectly reached via functions like `Read::read_to_end()` and `Read::read_to_string()`, which rely on the vulnerable `read_to_end_with_reservation()`.
- **Untrusted Input:** An attacker could control the input source that uses the vulnerable `Read` trait.

**Required Attacker Capabilities/Position:**

- An attacker needs to be able to provide a custom implementation of the `Read` trait that can be used by the vulnerable code. This could be by controlling an input stream/file.
- The attacker may also be able to leverage the vulnerability using existing implementations of the `Read` trait that are not well-behaved.

**Additional Notes:**

- The vulnerability was present for about 2.5 years, since Rust version 1.20.
- The fix involves adding an assertion to ensure that the value `n` returned by `read()` is not greater than the buffer length provided to it. This is achieved by slicing the buffer and taking it's length before using it in the assertion.
- The issue was addressed by the pull request #80895, which was merged into Rust's master branch and backported to the beta branch.
- The documentation for `Read::read` was updated to clarify that the return value should never be larger than the passed buffer, to prevent future misunderstandings of the API.
- The vulnerability has been assigned CVE-2021-28875.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage | Combined Score | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|---------------|------------|-------------------|
| 1 | CWE-190 | Integer Overflow or Wraparound | Base | Allowed | 0.3863 | sparse, graph | sparse: 0.050, graph: 1.000 |
| 2 | CWE-1284 | Improper Validation of Specified Quantity in Input | Base | Allowed | 0.3862 | sparse, graph | sparse: 0.050, graph: 1.000 |
| 3 | CWE-789 | Memory Allocation with Excessive Size Value | Variant | Allowed | 0.3562 | sparse, graph | sparse: 0.050, graph: 1.000 |
| 4 | CWE-252 | Unchecked Return Value | Base | Allowed | 0.3524 | sparse, graph | sparse: 0.065, graph: 0.882 |
| 5 | CWE-770 | Allocation of Resources Without Limits or Throttling | Base | Allowed | 0.2958 | sparse, graph | sparse: 0.046, graph: 0.754 |
| 6 | CWE-787 | Out-of-bounds Write | Base | Allowed | 0.2665 | sparse, graph | sparse: 0.047, graph: 0.670 |
| 7 | CWE-194 | Unexpected Sign Extension | Variant | Allowed | 0.2214 | dense, sparse | dense: 0.427, sparse: 0.046 |
| 8 | CWE-126 | Buffer Over-read | Variant | Allowed | 0.2192 | dense, sparse | dense: 0.419, sparse: 0.048 |
| 9 | CWE-119 | Improper Restriction of Operations within the Bounds of a Memory Buffer | Class | Discouraged | 0.1081 | sparse, graph | sparse: 0.049, graph: 0.598 |
| 10 | CWE-130 | Improper Handling of Length Parameter Inconsistency | Base | Allowed | 0.0283 | sparse | sparse: 0.049 |

