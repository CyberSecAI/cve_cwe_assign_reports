# Vulnerability Information: CVE-2020-25673

## Vulnerability Description
A vulnerability was found in Linux kernel where non-blocking socket in llcp_sock_connect() leads to leak and eventually hanging-up the system.

### Vulnerability Description Key Phrases
- **impact:** leak and hanging-up the system
- **product:** Linux kernel
- **component:** llcp_sock_connect()

## CVE Reference Links Content Summary
```
{
  "CVE-2020-25673": {
    "Root cause": "The `llcp_sock_connect()` function in the Linux kernel's NFC subsystem does not properly handle non-blocking sockets. Specifically, when a non-blocking socket is used, the `sock_wait_state` function returns immediately with `-EINPROGRESS`, and the connection attempt does not complete. This leaves the socket in a state where resources such as `llcp_sock->dev`, `llcp_sock->local`, `llcp_sock->ssap`, and `llcp_sock->service_name` are not freed. Also the socket is linked to `local->connecting_sockets`. Repeated calls to `llcp_sock_connect()` with a non-blocking socket and invalid service name leads to resource leakage.",
    "Weaknesses": [
      "Resource Leak",
       "Improper handling of non-blocking sockets",
       "Double linking of socket to local->connecting_sockets"
    ],
    "Impact": "Repeated calls to `llcp_sock_connect()` with non-blocking sockets causes a resource leak leading to a denial of service. Also, double linking of the socket in `local->connecting_sockets` can lead to an infinite loop, causing a system hang.",
     "Attack vectors": "A local user can create a non-blocking NFC socket and repeatedly attempt to connect using the `llcp_sock_connect()` function with an invalid service name.",
    "Required attacker capabilities/position": "Local user with the ability to create and interact with NFC sockets."
  }
}
```

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage | Combined Score | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|---------------|------------|-------------------|
| 1 | CWE-416 | Use After Free | Variant | Allowed | 0.4948 | dense, sparse, graph | dense: 0.485, sparse: 0.028, graph: 0.775 |
| 2 | CWE-822 | Untrusted Pointer Dereference | Base | Allowed | 0.3151 | sparse, graph | sparse: 0.031, graph: 0.832 |
| 3 | CWE-125 | Out-of-bounds Read | Base | Allowed | 0.2995 | sparse, graph | sparse: 0.030, graph: 0.789 |
| 4 | CWE-911 | Improper Update of Reference Count | Base | Allowed | 0.2964 | sparse, graph | sparse: 0.058, graph: 0.736 |
| 5 | CWE-362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | Allowed-with-Review | 0.2831 | dense, sparse, graph | dense: 0.478, sparse: 0.031, graph: 0.629 |
| 6 | CWE-415 | Double Free | Variant | Allowed | 0.2709 | sparse, graph | sparse: 0.028, graph: 0.776 |
| 7 | CWE-833 | Deadlock | Base | Allowed | 0.2636 | dense, sparse | dense: 0.492, sparse: 0.031 |
| 8 | CWE-401 | Missing Release of Memory after Effective Lifetime | Variant | Allowed | 0.2557 | dense, sparse | dense: 0.517, sparse: 0.032 |
| 9 | CWE-908 | Use of Uninitialized Resource | Base | Allowed | 0.2475 | dense, sparse | dense: 0.461, sparse: 0.029 |
| 10 | CWE-770 | Allocation of Resources Without Limits or Throttling | Base | Allowed | 0.2405 | dense, sparse | dense: 0.447, sparse: 0.029 |

