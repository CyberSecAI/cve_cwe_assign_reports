# Critic Input for CVE-2021-45606



# Original Analyzer Input
## Vulnerability Description
Certain NETGEAR devices are affected by a **stack-based buffer overflow** by an authenticated user. This affects R6400 before 1.0.1.70, R7000 before 1.0.11.126, R7900 before 1.0.4.46, R7900P before 1.4.2.84, R7960P before 1.4.2.84, R8000 before 1.0.4.74, R8000P before 1.4.2.84, RAX200 before 1.0.4.120, RS400 before 1.5.1.80, R6400v2 before 1.0.4.118, R7000P before 1.3.3.140, RAX80 before 1.0.4.120, R6700v3 before 1.0.4.118, R6900P before 1.3.3.140, and RAX75 before 1.0.4.120.

### Vulnerability Description Key Phrases
- **weakness:** **stack-based buffer overflow**
- **attacker:** authenticated user
- **product:** R6400 and R7000 and R7900 and R7900P and R7960P and R8000 and R8000P and RAX200 and RS400 and R6400v2 and R7000P and RAX80 and R6700v3 and R6900P and RAX75
- **version:** before 1.0.1.70 and before 1.0.11.126 and before 1.0.4.46 and before 1.4.2.84 and before 1.4.2.84 and before 1.0.4.74 and before 1.4.2.84 and before 1.0.4.120 and before 1.5.1.80 and before 1.0.4.118 and before 1.3.3.140 and before 1.0.4.120 and before 1.0.4.118 and before 1.3.3.140 and before 1.0.4.120

## CVE Reference Links Content Summary
The provided content is a security advisory from NETGEAR regarding a post-authentication stack overflow vulnerability. Here's a breakdown of the relevant information:

**Root cause of vulnerability:**
*   A stack overflow vulnerability exists in the firmware of several NETGEAR router models.

**Weaknesses/vulnerabilities present:**
*   Stack Overflow: A buffer overflow occurs on the stack, potentially overwriting return addresses or other critical data.

**Impact of exploitation:**
*   Denial of Service (DoS): The vulnerability is rated with a CVSS score of 4.5, with a high impact on availability (A:H). Exploitation could lead to device crashes or instability, resulting in a denial-of-service condition.
*   Potential for Remote Code Execution (not explicitly stated but implied): While the advisory only mentions DoS, stack overflows can potentially be leveraged to execute arbitrary code on the device, depending on the specific implementation and exploit technique.

**Attack vectors:**
*   Network based (AV:A): The vulnerability is exploitable by an attacker on the same network segment as the vulnerable device.
*   Post-authentication (PR:H): The attacker needs valid administrative credentials to access the router’s management interface and trigger the overflow.

**Required attacker capabilities/position:**
*   The attacker must be on the same network as the targeted device.
*   The attacker needs valid administrative access to the router’s web interface.
*   The attacker would need to craft a specific request that triggers the stack overflow.

**Affected Products:**
The advisory lists the affected router models and firmware versions:

*   R6400, firmware versions prior to 1.0.1.70
*   R7000, firmware versions prior to 1.0.11.126
*   R7900, firmware versions prior to 1.0.4.46
*   R7900P, firmware versions prior to 1.4.2.84
*   R7960P, firmware versions prior to 1.4.2.84
*   R8000, firmware versions prior to 1.0.4.74
*   R8000P, firmware versions prior to 1.4.2.84
*   RAX200, firmware versions prior to 1.0.4.120
*  RS400, running firmware versions prior to 1.5.1.80
*   R6400v2, firmware versions prior to 1.0.4.118
*   R7000P, firmware versions prior to 1.3.3.140
*   RAX80, firmware versions prior to 1.0.4.120
*   R6700v3, firmware versions prior to 1.0.4.118
*  R6900P, running firmware versions prior to 1.3.3.140
*   RAX75, firmware versions prior to 1.0.4.120

**Mitigation:**

*   Update to the latest firmware versions. The advisory provides instructions on how to download and update the router's firmware.

**Additional Notes:**
*   The advisory does not mention a CVE ID, but refers to it as "PSV-2020-0499". This implies that it was assigned internally by Netgear.
*   The advisory acknowledges "crixer" for reporting the vulnerability.
*   The advisory includes a CVSS vector string: `CVSS:3.1/AV:A/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:H`
*   The advisory includes best practices for keeping firmware up to date, emphasizing both app-based and manual firmware updates.

This content provides more specific details about the affected products and vulnerable versions than a typical CVE description.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage | Combined Score | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|---------------|------------|-------------------|
| 1 | CWE-121 | Stack-based Buffer Overflow | Variant | Allowed | 0.5625 | dense, sparse | dense: 0.692, sparse: 0.460 |
| 2 | CWE-1284 | Improper Validation of Specified Quantity in Input | Base | Allowed | 0.4398 | dense, sparse | dense: 0.568, sparse: 0.271 |
| 3 | CWE-120 | Buffer Copy without Checking Size of Input ('Classic Buffer Overflow') | Base | Allowed-with-Review | 0.4267 | dense, sparse | dense: 0.578, sparse: 0.276 |
| 4 | CWE-170 | Improper Null Termination | Base | Allowed | 0.4242 | sparse, graph | sparse: 0.248, graph: 0.789 |
| 5 | CWE-77 | Improper Neutralization of Special Elements used in a Command ('Command Injection') | Class | Allowed-with-Review | 0.4193 | dense, sparse | dense: 0.713, sparse: 0.624 |
| 6 | CWE-190 | Integer Overflow or Wraparound | Base | Allowed | 0.4177 | sparse, graph | sparse: 0.270, graph: 0.737 |
| 7 | CWE-122 | Heap-based Buffer Overflow | Variant | Allowed | 0.3981 | dense, sparse | dense: 0.568, sparse: 0.257 |
| 8 | CWE-193 | Off-by-one Error | Base | Allowed | 0.3705 | sparse, graph | sparse: 0.253, graph: 0.631 |
| 9 | CWE-789 | Memory Allocation with Excessive Size Value | Variant | Allowed | 0.3694 | sparse, graph | sparse: 0.244, graph: 0.729 |
| 10 | CWE-119 | Improper Restriction of Operations within the Bounds of a Memory Buffer | Class | Discouraged | 0.1969 | dense, sparse | dense: 0.582, sparse: 0.260 |



# Analysis to Review
# Summary
| CWE ID  | CWE Name  | Confidence | CWE Abstraction Level | CWE Vulnerability Mapping Label | CWE-Vulnerability Mapping Notes |
|---|---|---|---|---|---|
| CWE-121 | Stack-based Buffer Overflow | 0.95 | Variant | Allowed | Primary CWE |
| CWE-120 | Buffer Copy without Checking Size of Input ('Classic Buffer Overflow') | 0.60 | Base | Allowed-with-Review | Secondary Candidate |
| CWE-119 | Improper Restriction of Operations within the Bounds of a Memory Buffer | 0.40 | Class | Discouraged | Secondary Candidate |

## Evidence and Confidence

*   **Confidence Score:** 0.90
*   **Evidence Strength:** HIGH

- **Analysis and Justification:**  
  - *Explanation:* The vulnerability is described as a **stack-based buffer overflow** which directly maps to CWE-121 (Stack-based Buffer Overflow). The **weakness** occurs because an authenticated user can cause a buffer overflow on the stack. The evidence provided from the CVE Reference Links Content Summary indicates that a stack overflow vulnerability exists in the firmware and can potentially overwrite return addresses or other critical data. CWE-121 is a Variant level CWE, making it a more specific and preferred choice compared to its parent CWEs like CWE-119.

  - *Relationship Analysis:* CWE-121 is a variant of CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer). While CWE-119 broadly describes buffer overflows, CWE-121 specifically identifies the location of the buffer on the stack. There are no direct relationships mentioned in the provided information.

- **Confidence Score:**  
  - *Example:* Confidence: 0.95 (High confidence due to explicit mention of stack-based buffer overflow in the vulnerability description and supporting evidence from CVE reference)

---
- **Analysis and Justification:**  
  - *Explanation:* CWE-120 (Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')) is a potential candidate as buffer overflows often involve copying data without proper size validation. However, since the vulnerability is explicitly described as **stack-based**, CWE-121 is a more accurate and specific classification. CWE-120 is a more general case of a buffer overflow and not specific to a stack, which makes CWE-121 a better fit. The MITRE mapping guidance for CWE-120 suggests that it might be misused and is only appropriate for "Buffer Copy" operations where there is no "Checking [the] Size of Input." While this condition might be met, the specific nature of the stack overflow makes CWE-121 the primary choice.

  - *Relationship Analysis:* CWE-120 is a child of CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer). The relationship context supports the idea that CWE-120 can be considered when the details suggest a buffer copy operation without size checking, but it is less specific than CWE-121 for **stack-based buffer overflows.**

- **Confidence Score:**  
  - *Example:* Confidence: 0.60 (Moderate confidence as it relates to the broader concept of buffer overflows, but is not as precise as CWE-121)

---

- **Analysis and Justification:**  
  - *Explanation:* CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer) is a high-level class that encompasses buffer overflows. However, the description specifically states that it is a **stack-based buffer overflow**, making CWE-121 a more precise and preferred mapping. The MITRE mapping guidance for CWE-119 discourages its use in low-information vulnerability reports when lower-level CWEs could be used instead.

  - *Relationship Analysis:* CWE-121 is a variant and child of CWE-119, indicating that it is a more specific type of buffer overflow. Therefore, using CWE-121 is more appropriate given the available details.

- **Confidence Score:**  
  - *Example:* Confidence: 0.40 (Low confidence due to the availability of a more specific CWE (CWE-121) that better represents the vulnerability)

# CWE Examples from Database


## Known Examples for CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')
### Observed Examples
- **CVE-2000-1094** [https://www.cve.org/CVERecord?id=CVE-2000-1094](https://www.cve.org/CVERecord?id=CVE-2000-1094): buffer overflow using command with long argument
- **CVE-1999-0046** [https://www.cve.org/CVERecord?id=CVE-1999-0046](https://www.cve.org/CVERecord?id=CVE-1999-0046): buffer overflow in local program using long environment variable
- **CVE-2002-1337** [https://www.cve.org/CVERecord?id=CVE-2002-1337](https://www.cve.org/CVERecord?id=CVE-2002-1337): buffer overflow in comment characters, when product increments a counter for a ">" but does not decrement for "<"
- **CVE-2003-0595** [https://www.cve.org/CVERecord?id=CVE-2003-0595](https://www.cve.org/CVERecord?id=CVE-2003-0595): By replacing a valid cookie value with an extremely long string of characters, an attacker may overflow the application's buffers.
- **CVE-2001-0191** [https://www.cve.org/CVERecord?id=CVE-2001-0191](https://www.cve.org/CVERecord?id=CVE-2001-0191): By replacing a valid cookie value with an extremely long string of characters, an attacker may overflow the application's buffers.
### Top 25 Examples
- **CVE-2021-1965**: Possible buffer overflow due to lack of parameter length check during MBSSID scan IE parse in Snapdragon Auto, Snapdragon Compute, Snapdragon Connectivity, Snapdragon Mobile, Snapdragon Wired Infrastructure and Networking
- **CVE-2021-20699**: Sharp NEC Displays ((UN462A R1.300 and prior to it, UN462VA R1.300 and prior to it, UN492S R1.300 and prior to it, UN492VS R1.300 and prior to it, UN552A R1.300 and prior to it, UN552S R1.300 and prior to it, UN552VS R1.300 and prior to it, UN552 R1.300 and prior to it, UN552V R1.300 and prior to it, UX552S R1.300 and prior to it, UX552 R1.300 and prior to it, V864Q R2.000 and prior to it, C861Q R2.000 and prior to it, P754Q R2.000 and prior to it, V754Q R2.000 and prior to it, C751Q R2.000 and prior to it, V984Q R2.000 and prior to it, C981Q R2.000 and prior to it, P654Q R2.000 and prior to it, V654Q R2.000 and prior to it, C651Q R2.000 and prior to it, V554Q R2.000 and prior to it, P404 R3.200 and prior to it, P484 R3.200 and prior to it, P554 R3.200 and prior to it, V404 R3.200 and prior to it, V484 R3.200 and prior to it, V554 R3.200 and prior to it, V404-T R3.200 and prior to it, V484-T R3.200 and prior to it, V554-T R3.200 and prior to it, C501 R2.000 and prior to it, C551 R2.000 and prior to it, C431 R2.000 and prior to it) allows an attacker a buffer overflow and to execute remote code by sending long parameters that contains specific characters in http request.
- **CVE-2021-33909**: fs/seq_file.c in the Linux kernel 3.16 through 5.13.x before 5.13.4 does not properly restrict seq buffer allocations, leading to an integer overflow, an Out-of-bounds Write, and escalation to root by an unprivileged user, aka CID-8cae8cd89f05.
- **CVE-2021-3420**: A flaw was found in newlib in versions prior to 4.0.0. Improper overflow validation in the memory allocation functions mEMALIGn, pvALLOc, nano_memalign, nano_valloc, nano_pvalloc could case an integer overflow, leading to an allocation of a small buffer and then to a heap-based buffer overflow.
- **CVE-2021-22659**: Rockwell Automation MicroLogix 1400 Version 21.6 and below may allow a remote unauthenticated attacker to send a specially crafted Modbus packet allowing the attacker to retrieve or modify random values in the register. If successfully exploited, this may lead to a buffer overflow resulting in a denial-of-service condition. The FAULT LED will flash RED and communications may be lost. Recovery from denial-of-service condition requires the fault to be cleared by the user.


# Relevant CWE Specifications

## CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')
**Abstraction:** Base
**Status:** Incomplete

### Description
The product copies an input buffer to an output buffer without verifying that the size of the input buffer is less than the size of the output buffer, leading to a buffer overflow.

### Extended Description
A buffer overflow condition exists when a product attempts to put more data in a buffer than it can hold, or when it attempts to put data in a memory area outside of the boundaries of a buffer. The simplest type of error, and the most common cause of buffer overflows, is the "classic" case in which the product copies the buffer without restricting how much is copied. Other variants exist, but the existence of a classic overflow strongly suggests that the programmer is not considering even the most basic of security protections.

### Alternative Terms
Classic Buffer Overflow: This term was frequently used by vulnerability researchers during approximately 1995 to 2005 to differentiate buffer copies without length checks (which had been known about for decades) from other emerging weaknesses that still involved invalid accesses of buffers, as vulnerability researchers began to develop advanced exploitation techniques.
Unbounded Transfer

### Relationships
ChildOf -> CWE-119
ChildOf -> CWE-119
ChildOf -> CWE-119
ChildOf -> CWE-119
CanPrecede -> CWE-123
ChildOf -> CWE-20
CanFollow -> CWE-170
CanFollow -> CWE-231
CanFollow -> CWE-416
CanFollow -> CWE-456
ParentOf -> CWE-785

### Mapping Guidance
**Usage:** Allowed-with-Review
**Rationale:** There are some indications that this CWE ID might be misused and selected simply because it mentions "buffer overflow" - an increasingly vague term. This CWE entry is only appropriate for "Buffer Copy" operations (not buffer reads), in which where there is no "Checking [the] Size of Input", and (by implication of the copy) writing past the end of the buffer.
**Comments:** If the vulnerability being analyzed involves out-of-bounds reads, then consider CWE-125 or descendants. For root cause analysis: if there is any input validation, consider children of CWE-20 such as CWE-1284. If there is a calculation error for buffer sizes, consider CWE-131 or similar.
**Reasons:**
- Frequent Misuse


### Potential Mitigations
**Mitigation 1:**
- **Phase:** Requirements
- **Strategy:** Language Selection
- **Description:** 

Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.


For example, many languages that perform their own memory management, such as Java and Perl, are not subject to buffer overflows. Other languages, such as Ada and C#, typically provide overflow protection, but the protection can be disabled by the programmer.


Be wary that a language's interface to native code may still be subject to overflows, even if the language itself is theoretically safe.


**Mitigation 2:**
- **Phase:** Architecture and Design
- **Strategy:** Libraries or Frameworks
- **Description:** 

Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.


Examples include the Safe C String Library (SafeStr) by Messier and Viega [REF-57], and the Strsafe.h library from Microsoft [REF-56]. These libraries provide safer versions of overflow-prone string-handling functions.


**Mitigation 3:**
- **Phase:** Operation, Build and Compilation
- **Effectiveness:** Defense in Depth
- **Strategy:** Environment Hardening
- **Description:** 

Use automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking. 


 D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail. 




### Additional Notes
**[Relationship]** At the code level, stack-based and heap-based overflows do not differ significantly, so there usually is not a need to distinguish them. From the attacker perspective, they can be quite different, since different techniques are required to exploit them.

**[Terminology]** Many issues that are now called "buffer overflows" are substantively different than the "classic" overflow, including entirely different bug types that rely on overflow exploit techniques, such as integer signedness errors, integer overflows, and format string bugs. This imprecise terminology can make it difficult to determine which variant is being reported.



### Observed Examples
- **CVE-2000-1094:** buffer overflow using command with long argument
- **CVE-1999-0046:** buffer overflow in local program using long environment variable
- **CVE-2002-1337:** buffer overflow in comment characters, when product increments a counter for a ">" but does not decrement for "<"



## CWE-121: Stack-based Buffer Overflow
**Abstraction:** Variant
**Status:** Draft

### Description
A stack-based buffer overflow condition is a condition where the buffer being overwritten is allocated on the stack (i.e., is a local variable or, rarely, a parameter to a function).

### Extended Description
Not provided

### Alternative Terms
Stack Overflow: "Stack Overflow" is often used to mean the same thing as stack-based buffer overflow, however it is also used on occasion to mean stack exhaustion, usually a result from an excessively recursive function call. Due to the ambiguity of the term, use of stack overflow to describe either circumstance is discouraged.

### Relationships
ChildOf -> CWE-788
ChildOf -> CWE-787

### Mapping Guidance
**Usage:** Allowed
**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.
**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.
**Reasons:**
- Acceptable-Use


### Potential Mitigations
**Mitigation 1:**
- **Phase:** Operation, Build and Compilation
- **Effectiveness:** Defense in Depth
- **Strategy:** Environment Hardening
- **Description:** 

Use automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking. 


 D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail. 


**Mitigation 2:**
- **Phase:** Architecture and Design
- **Description:** Use an abstraction library to abstract away risky APIs. Not a complete solution.

**Mitigation 3:**
- **Phase:** Implementation
- **Description:** Implement and perform bounds checking on input.



### Additional Notes
**[Other]** Stack-based buffer overflows can instantiate in return address overwrites, stack pointer overwrites or frame pointer overwrites. They can also be considered function pointer overwrites, array indexer overwrites or write-what-where condition, etc.



### Observed Examples
- **CVE-2021-35395:** Stack-based buffer overflows in SFK for wifi chipset used for IoT/embedded devices, as exploited in the wild per CISA KEV.



## CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer
**Abstraction:** Class
**Status:** Stable

### Description
The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.

### Extended Description
Not provided

### Alternative Terms
Buffer Overflow: This term has many different meanings to different audiences. From a CWE mapping perspective, this term should be avoided where possible. Some researchers, developers, and tools intend for it to mean "write past the end of a buffer," whereas others use the same term to mean "any read or write outside the boundaries of a buffer, whether before the beginning of the buffer or after the end of the buffer." Others could mean "any action after the end of a buffer, whether it is a read or write." Since the term is commonly used for exploitation and for vulnerabilities, it further confuses things.
buffer overrun: Some prominent vendors and researchers use the term "buffer overrun," but most people use "buffer overflow." See the alternate term for "buffer overflow" for context.
memory safety: Generally used for techniques that avoid weaknesses related to memory access, such as those identified by CWE-119 and its descendants. However, the term is not formal, and there is likely disagreement between practitioners as to which weaknesses are implicitly covered by the "memory safety" term.

### Relationships
ChildOf -> CWE-118
ChildOf -> CWE-20
ParentOf -> CWE-120
ParentOf -> CWE-123
ParentOf -> CWE-125
CanFollow -> CWE-1257
CanFollow -> CWE-1260
CanFollow -> CWE-128
CanFollow -> CWE-129
ParentOf -> CWE-130
CanFollow -> CWE-131
CanFollow -> CWE-1339
CanFollow -> CWE-190
CanFollow -> CWE-193
CanFollow -> CWE-195
CanFollow -> CWE-20
ParentOf -> CWE-466
ParentOf -> CWE-786
ParentOf -> CWE-787
ParentOf -> CWE-788
ParentOf -> CWE-805
ParentOf -> CWE-822
ParentOf -> CWE-823
ParentOf -> CWE-824
ParentOf -> CWE-825
CanFollow -> CWE-839
CanFollow -> CWE-843

### Mapping Guidance
**Usage:** Discouraged
**Rationale:** CWE-119 is commonly misused in low-information vulnerability reports when lower-level CWEs could be used instead, or when more details about the vulnerability are available.
**Comments:** Look at CWE-119's children and consider mapping to CWEs such as CWE-787: Out-of-bounds Write, CWE-125: Out-of-bounds Read, or others.
**Reasons:**
- Frequent Misuse


### Potential Mitigations
**Mitigation 1:**
- **Phase:** Requirements
- **Strategy:** Language Selection
- **Description:** 

Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.


For example, many languages that perform their own memory management, such as Java and Perl, are not subject to buffer overflows. Other languages, such as Ada and C#, typically provide overflow protection, but the protection can be disabled by the programmer.


Be wary that a language's interface to native code may still be subject to overflows, even if the language itself is theoretically safe.


**Mitigation 2:**
- **Phase:** Architecture and Design
- **Strategy:** Libraries or Frameworks
- **Description:** 

Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.


Examples include the Safe C String Library (SafeStr) by Messier and Viega [REF-57], and the Strsafe.h library from Microsoft [REF-56]. These libraries provide safer versions of overflow-prone string-handling functions.


**Mitigation 3:**
- **Phase:** Operation, Build and Compilation
- **Effectiveness:** Defense in Depth
- **Strategy:** Environment Hardening
- **Description:** 

Use automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking. 


 D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail. 




### Additional Notes
**[Applicable Platform]** 

It is possible in any programming languages without memory management support to attempt an operation outside of the bounds of a memory buffer, but the consequences will vary widely depending on the language, platform, and chip architecture.




### Observed Examples
- **CVE-2021-22991:** Incorrect URI normalization in application traffic product leads to buffer overflow, as exploited in the wild per CISA KEV.
- **CVE-2020-29557:** Buffer overflow in Wi-Fi router web interface, as exploited in the wild per CISA KEV.
- **CVE-2009-2550:** Classic stack-based buffer overflow in media player using a long entry in a playlist

