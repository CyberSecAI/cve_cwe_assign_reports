# Vulnerability Information: CVE-2022-0185

## Vulnerability Description
A **heap-based buffer overflow** flaw was found in the way the legacy_parse_param function in the Filesystem Context functionality of the Linux kernel verified the supplied parameters length. An unprivileged (in case of unprivileged user namespaces enabled, otherwise needs namespaced CAP_SYS_ADMIN privilege) local user able to open a filesystem that does not support the Filesystem Context API (and thus fallbacks to legacy handling) could use this flaw to escalate their privileges on the system.

### Vulnerability Description Key Phrases
- **rootcause:** **heap-based buffer overflow**
- **impact:** privilege escalation
- **attacker:** unprivileged local user
- **product:** Linux kernel
- **component:** legacy_parse_param function in Filesystem Context functionality

## CVE Reference Links Content Summary
Based on the provided content, here's an analysis of CVE-2022-0185:

**Root Cause of Vulnerability:**

- An integer underflow in the `legacy_parse_param` function within the Linux kernel's `fs/fs_context.c` file.

**Weaknesses/Vulnerabilities Present:**
- **Heap Buffer Overflow:** The vulnerability allows an attacker to write beyond the allocated buffer on the heap due to an incorrect size calculation.
- **Incorrect Size Check:** The code attempts to prevent the overflow with the check `if (len > PAGE_SIZE - 2 - size)`. However, `size` is an unsigned integer. If `size` is close to `PAGE_SIZE` (4096), the subtraction results in an integer underflow and a large positive value instead of the expected negative value, bypassing the size check.

**Impact of Exploitation:**

- **Arbitrary Code Execution:** The heap overflow can lead to arbitrary code execution in the kernel context.
- **Privilege Escalation:**  By exploiting the overflow, an attacker can gain root privileges.
- **Denial of Service:**  Exploitation may lead to system crashes.
- **Information Disclosure:** Sensitive kernel data can be leaked through out-of-bounds reads.
- **Data Modification:**  Exploitation can allow modification of data.

**Attack Vectors:**

- The `fsconfig` syscall can be abused by specifying a crafted string as a parameter to trigger the overflow.
- FUSE (Filesystem in Userspace) can be used to create a custom filesystem and control the timing of certain operations, which helps with exploiting the race conditions and heap spraying.
- SYSVIPC message queues are leveraged for heap spraying and memory manipulation.
- Modprobe can be abused for privilege escalation after kernel exploitation.
- Unprivileged users can use `unshare(CLONE_NEWNS|CLONE_NEWUSER)` to create a new namespace with `CAP_SYS_ADMIN` capability to exploit the vulnerability.

**Required Attacker Capabilities/Position:**

- **Local Access:** The attacker needs local access to the system.
- **CAP_SYS_ADMIN Capability:** The attacker needs the `CAP_SYS_ADMIN` capability, which can be obtained by creating a new user namespace.
- **Knowledge of Kernel Exploitation:** The attacker requires knowledge of kernel exploitation techniques, including heap overflows, race conditions, and ROP (Return-Oriented Programming).

**Additional Details:**
- The vulnerability exists in Linux kernel versions 5.1 and later, up to (but not including) the fix.
- The vulnerability is triggered through the `fsconfig` syscall, specifically when setting string parameters.
- The provided content includes details on how the overflow is triggered (via a large size variable causing an underflow in the size check) and how it can be used for privilege escalation using FUSE and SYSVIPC.
- Exploits using both FUSE and pipes were developed to achieve local privilege escalation and container escape.
- The vulnerability was found using the Syzkaller fuzzer.
- The vulnerability can be triggered by multiple file systems which utilize the legacy `fs_context`.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage | Combined Score | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|---------------|------------|-------------------|
| 1 | CWE-193 | Off-by-one Error | Base | Allowed | 0.8259 | dense, sparse, graph | dense: 0.587, sparse: 0.352, graph: 0.926 |
| 2 | CWE-191 | Integer Underflow (Wrap or Wraparound) | Base | Allowed | 0.8193 | dense, sparse, graph | dense: 0.581, sparse: 0.545, graph: 0.607 |
| 3 | CWE-190 | Integer Overflow or Wraparound | Base | Allowed | 0.7874 | dense, sparse, graph | dense: 0.601, sparse: 0.380, graph: 0.753 |
| 4 | CWE-126 | Buffer Over-read | Variant | Allowed | 0.6437 | dense, sparse, graph | dense: 0.606, sparse: 0.331, graph: 0.572 |
| 5 | CWE-1284 | Improper Validation of Specified Quantity in Input | Base | Allowed | 0.5111 | sparse, graph | sparse: 0.358, graph: 0.857 |
| 6 | CWE-122 | Heap-based Buffer Overflow | Variant | Allowed | 0.4855 | dense, sparse | dense: 0.628, sparse: 0.370 |
| 7 | CWE-125 | Out-of-bounds Read | Base | Allowed | 0.4760 | dense, sparse | dense: 0.553, sparse: 0.349 |
| 8 | CWE-131 | Incorrect Calculation of Buffer Size | Base | Allowed | 0.4711 | dense, sparse | dense: 0.557, sparse: 0.336 |
| 9 | CWE-121 | Stack-based Buffer Overflow | Variant | Allowed | 0.4411 | dense, sparse | dense: 0.576, sparse: 0.331 |
| 10 | CWE-770 | Allocation of Resources Without Limits or Throttling | Base | Allowed | 0.3994 | sparse, graph | sparse: 0.341, graph: 0.572 |

