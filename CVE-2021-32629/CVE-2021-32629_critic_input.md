# Critic Input for CVE-2021-32629



# Original Analyzer Input
## Vulnerability Description
Cranelift is an open-source code generator maintained by Bytecode Alliance. It translates a target-independent intermediate representation into executable machine code. There is a bug in 0.73 of the Cranelift x64 backend that can create a scenario that could result in a potential sandbox escape in a Wasm program. This bug was introduced in the new backend on 2020-09-08 and first included in a release on 2020-09-30, but the new backend was not the default prior to 0.73. The recently-released version 0.73 with default settings, and prior versions with an explicit build flag to select the new backend, are vulnerable. The bug in question performs a sign-extend instead of a zero-extend on a value loaded from the stack, under a specific set of circumstances. If those circumstances occur, the bug could allow access to memory addresses upto 2GiB before the start of the Wasm program heap. If the heap bound is larger than 2GiB, then it would be possible to read memory from a computable range dependent on the size of the heaps bound. The impact of this bug is highly dependent on heap implementation, specifically * if the heap has bounds checks, and * does not rely exclusively on guard pages, and * the heap bound is 2GiB or smaller * then this bug cannot be used to reach memory from another Wasm program heap. The impact of the vulnerability is mitigated if there is no memory mapped in the range accessible using this bug, for example, if there is a 2 GiB guard region before the Wasm program heap. The bug in question performs a sign-extend instead of a zero-extend on a value loaded from the stack, when the register allocator reloads a spilled integer value narrower than 64 bits. This interacts poorly with another optimization the instruction selector elides a 32-to-64-bit zero-extend operator when we know that an instruction producing a 32-bit value actually zeros the upper 32 bits of its destination register. Hence, we rely on these zeroed bits, but the type of the value is still i32, and the spill/reload reconstitutes those bits as the sign extension of the i32s MSB. The issue would thus occur when * An i32 value in a Wasm program is greater than or equal to 0x8000_0000 * The value is spilled and reloaded by the register allocator due to high register pressure in the program between the values definition and its use * The value is produced by an instruction that we know to be special in that it zeroes the upper 32 bits of its destination add, sub, mul, and, or * The value is then zero-extended to 64 bits in the Wasm program * The resulting 64-bit value is used. Under these circumstances there is a potential sandbox escape when the i32 value is a pointer. The usual code emitted for heap accesses zero-extends the Wasm heap address, adds it to a 64-bit heap base, and accesses the resulting address. If the zero-extend becomes a sign-extend, the program could reach backward and access memory up to 2GiB before the start of its heap. In addition to assessing the nature of the code generation bug in Cranelift, we have also determined that under specific circumstances, both Lucet and Wasmtime using this version of Cranelift may be exploitable. See referenced GitHub Advisory for more details.

### Vulnerability Description Key Phrases
- **rootcause:** **sign-extend instead of zero-extend on a value loaded from the stack**
- **impact:** ['potential sandbox escape', 'read memory from a computable range']
- **product:** Cranelift x64 backend
- **version:** 0.73

## CVE Reference Links Content Summary
Based on the provided information, here's an analysis of CVE-2021-32629:

**Root Cause:**

The vulnerability stems from an incorrect code generation in the Cranelift x64 backend, specifically during the spilling and reloading of integer values from the stack. When a 32-bit integer value is spilled and later reloaded, the code incorrectly performs a sign-extension instead of a zero-extension. This occurs when the register allocator spills the value due to high register pressure, and the value is produced by an instruction that is known to zero the upper 32-bits of the destination register. This is problematic because the compiler relies on the upper 32-bits of an i32 to be zero, and the incorrect sign extension can lead to an out-of-bounds memory access.

**Weaknesses/Vulnerabilities:**

*   **Incorrect Sign Extension:** The core vulnerability is the use of a sign-extension instead of a zero-extension when reloading a spilled 32-bit integer value from the stack.
*   **Optimization Reliance:** The instruction selector's optimization of eliding the 32-to-64-bit zero-extension, relying on the zeroed upper 32 bits from specific instructions, is also a contributing factor.
*   **Type Confusion:**  The type of the value is still i32 but reloaded as sign extended 64bit value.

**Impact of Exploitation:**

*   **Sandbox Escape:** A successful exploit could allow a WebAssembly module to access memory outside of its designated sandbox, potentially accessing up to 2GiB of memory before the start of its allocated heap. This out-of-bounds memory access could lead to arbitrary code execution by reading or writing to different parts of the memory.
*   **Control Flow Subversion:** In the context of a system like Fastly's Compute@Edge, this could be used to potentially subvert control flow in the daemon process.
*   **Memory Corruption/Crashes:**  If the memory accessed outside the sandbox is not valid for reading, the program would likely crash due to an out-of-bounds memory access, or assertion failure.
*   **Information Disclosure:** If attacker is able to craft a WASM module that bypasses the guard pages, they might be able to read memory from other sandboxes

**Attack Vectors:**

*   **Malicious WebAssembly Modules:** The primary attack vector involves crafting a malicious WebAssembly module that triggers the specific conditions required for the vulnerability.
*   **Specific Conditions:** The attack requires:
    *   An i32 value greater than or equal to 0x8000_0000
    *   The value being spilled and reloaded due to register pressure.
    *   The value being produced by instructions that zero the upper 32 bits of the register.
    *   The value being used in a context where it's zero-extended to 64-bits (such as heap access).

**Required Attacker Capabilities/Position:**

*   **Ability to Upload/Execute WebAssembly:**  The attacker needs the capability to upload and execute a specially crafted WebAssembly module, for example in a platform like Fastly's Compute@Edge or a vulnerable Wasmtime environment.
*   **Understanding of Cranelift Backend:**  The attacker needs knowledge of the Cranelift x64 backend, particularly how spilling and reloading works, and also the memory layout and heap structures of the environment the code is running in.

**Additional Notes:**

*   The vulnerability was present in Cranelift versions up to 0.73.0. It was fixed in versions 0.73.1 and 0.74.0.
*   The impact is highly dependent on the environment, particularly how memory is allocated and managed for WebAssembly modules (e.g., the presence of guard pages).
*   Mitigation strategies include using memory allocators that employ Address Space Layout Randomization (ASLR) and/or guard pages.
*   The issue was discovered through monitoring of unusual behaviour by WebAssembly modules.

This is a critical vulnerability that could lead to severe security issues if not addressed properly.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage | Combined Score | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|---------------|------------|-------------------|
| 1 | CWE-190 | Integer Overflow or Wraparound | Base | Allowed | 1.0678 | dense, sparse, graph | dense: 0.574, sparse: 1.000, graph: 0.584 |
| 2 | CWE-194 | Unexpected Sign Extension | Variant | Allowed | 0.9171 | dense, sparse | dense: 0.842, sparse: 1.000 |
| 3 | CWE-197 | Numeric Truncation Error | Base | Allowed | 0.8442 | dense, sparse | dense: 0.544, sparse: 1.000 |
| 4 | CWE-476 | NULL Pointer Dereference | Base | Allowed | 0.8420 | dense, sparse | dense: 0.540, sparse: 1.000 |
| 5 | CWE-681 | Incorrect Conversion between Numeric Types | Base | Allowed | 0.8404 | dense, sparse | dense: 0.536, sparse: 1.000 |
| 6 | CWE-824 | Access of Uninitialized Pointer | Base | Allowed | 0.8397 | dense, sparse | dense: 0.535, sparse: 1.000 |
| 7 | CWE-126 | Buffer Over-read | Variant | Allowed | 0.7847 | dense, sparse | dense: 0.556, sparse: 1.000 |
| 8 | CWE-125 | Out-of-bounds Read | Base | Allowed | 0.7847 | sparse, graph | sparse: 1.000, graph: 0.595 |
| 9 | CWE-1284 | Improper Validation of Specified Quantity in Input | Base | Allowed | 0.7838 | sparse, graph | sparse: 1.000, graph: 0.592 |
| 10 | CWE-122 | Heap-based Buffer Overflow | Variant | Allowed | 0.7826 | dense, sparse | dense: 0.551, sparse: 1.000 |



# Analysis to Review
```markdown
# Summary
| CWE ID  | CWE Name                                     | Confidence | CWE Abstraction Level | CWE Vulnerability Mapping Label | CWE-Vulnerability Mapping Notes |
|---------|----------------------------------------------|------------|-----------------------|---------------------------------|---------------------------------|
| CWE-194 | Unexpected Sign Extension                   | 0.95       | Variant               | Allowed                         | Primary CWE                     |
| CWE-125 | Out-of-bounds Read                           | 0.75       | Base                  | Allowed                         | Secondary Candidate             |
| CWE-787 | Out-of-bounds Write                          | 0.70       | Base                  | Allowed                         | Secondary Candidate             |
| CWE-681 | Incorrect Conversion between Numeric Types | 0.65       | Base                  | Allowed                         | Secondary Candidate             |

## Evidence and Confidence

*   **Confidence Score:** 0.85
*   **Evidence Strength:** HIGH

- **Analysis and Justification:**
  - *Explanation:* The core of this vulnerability lies in the **sign-extend instead of zero-extend on a value loaded from the stack**. The vulnerability description explicitly states, "The bug in question performs a sign-extend instead of a zero-extend on a value loaded from the stack." This aligns perfectly with CWE-194 (Unexpected Sign Extension), which is defined as "The product performs an operation on a number that causes it to be sign extended when it is transformed into a larger data type." The impact of this incorrect sign extension allows access to memory addresses before the start of the Wasm program heap, leading to a potential sandbox escape. The Retriever Results also indicate CWE-194 as a high-scoring candidate. Since the description is very specific about a sign extension being the root cause, CWE-194 is an appropriate and specific mapping. MITRE mapping guidance for CWE-194 indicates this is ALLOWED.

  - *Relationship Analysis:* CWE-194 is a variant of CWE-681 (Incorrect Conversion between Numeric Types). The incorrect sign extension leads to potential out-of-bounds memory access, making CWE-125 (Out-of-bounds Read) and CWE-787 (Out-of-bounds Write) possible consequences.

- **Confidence Score:**
  - Confidence: 0.95 (Strong evidence directly supports the mapping to CWE-194).

- **Analysis and Justification for Secondary CWEs:**
  - *CWE-125 (Out-of-bounds Read):* The vulnerability can lead to reading memory outside the intended buffer, as the incorrect sign extension allows accessing memory addresses before the start of the Wasm program heap. While CWE-194 is the root cause, the direct consequence is an out-of-bounds read. The description mentions, "If the heap bound is larger than 2GiB, then it would be possible to read memory from a computable range dependent on the size of the heaps bound." This supports the inclusion of CWE-125.
    - Confidence: 0.75
  - *CWE-787 (Out-of-bounds Write):* Although the primary description emphasizes reading out-of-bounds, the potential for a sandbox escape implies that writing out-of-bounds is also possible, leading to memory corruption. Therefore, CWE-787 is considered as a possible consequence.
    - Confidence: 0.70
  - *CWE-681 (Incorrect Conversion between Numeric Types):* The issue stems from an implicit type conversion that goes wrong, thus converting a signed integer into a larger data type.
    - Confidence: 0.65
```

# CWE Examples from Database


## Known Examples for CWE-681: Incorrect Conversion between Numeric Types
### Observed Examples
- **CVE-2022-2639** [https://www.cve.org/CVERecord?id=CVE-2022-2639](https://www.cve.org/CVERecord?id=CVE-2022-2639): Chain: integer coercion error (CWE-192) prevents a return value from indicating an error, leading to out-of-bounds write (CWE-787)
- **CVE-2021-43537** [https://www.cve.org/CVERecord?id=CVE-2021-43537](https://www.cve.org/CVERecord?id=CVE-2021-43537): Chain: in a web browser, an unsigned 64-bit integer is forcibly cast to a 32-bit integer (CWE-681) and potentially leading to an integer overflow (CWE-190). If an integer overflow occurs, this can cause heap memory corruption (CWE-122)
- **CVE-2007-4268** [https://www.cve.org/CVERecord?id=CVE-2007-4268](https://www.cve.org/CVERecord?id=CVE-2007-4268): Chain: integer signedness error (CWE-195) passes signed comparison, leading to heap overflow (CWE-122)
- **CVE-2007-4988** [https://www.cve.org/CVERecord?id=CVE-2007-4988](https://www.cve.org/CVERecord?id=CVE-2007-4988): Chain: signed short width value in image processor is sign extended during conversion to unsigned int, which leads to integer overflow and heap-based buffer overflow.
- **CVE-2009-0231** [https://www.cve.org/CVERecord?id=CVE-2009-0231](https://www.cve.org/CVERecord?id=CVE-2009-0231): Integer truncation of length value leads to heap-based buffer overflow.
- **CVE-2008-3282** [https://www.cve.org/CVERecord?id=CVE-2008-3282](https://www.cve.org/CVERecord?id=CVE-2008-3282): Size of a particular type changes for 64-bit platforms, leading to an integer truncation in document processor causes incorrect index to be generated.
### Top 25 Examples
- **CVE-2021-23997**: Due to unexpected data type conversions, a use-after-free could have occurred when interacting with the font cache. We presume that with enough effort this could have been exploited to run arbitrary code. This vulnerability affects Firefox < 88.
- **CVE-2021-37645**: TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation of `tf.raw_ops.QuantizeAndDequantizeV4Grad` is vulnerable to an integer overflow issue caused by converting a signed integer value to an unsigned one and then allocating memory based on this value. The [implementation](https://github.com/tensorflow/tensorflow/blob/8d72537c6abf5a44103b57b9c2e22c14f5f49698/tensorflow/core/kernels/quantize_and_dequantize_op.cc#L126) uses the `axis` value as the size argument to `absl::InlinedVector` constructor. But, the constructor uses an unsigned type for the argument, so the implicit conversion transforms the negative value to a large integer. We have patched the issue in GitHub commit 96f364a1ca3009f98980021c4b32be5fdcca33a1. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, and TensorFlow 2.4.3, as these are also affected and still in supported range.
- **CVE-2021-37646**: TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation of `tf.raw_ops.StringNGrams` is vulnerable to an integer overflow issue caused by converting a signed integer value to an unsigned one and then allocating memory based on this value. The [implementation](https://github.com/tensorflow/tensorflow/blob/8d72537c6abf5a44103b57b9c2e22c14f5f49698/tensorflow/core/kernels/string_ngrams_op.cc#L184) calls `reserve` on a `tstring` with a value that sometimes can be negative if user supplies negative `ngram_widths`. The `reserve` method calls `TF_TString_Reserve` which has an `unsigned long` argument for the size of the buffer. Hence, the implicit conversion transforms the negative value to a large integer. We have patched the issue in GitHub commit c283e542a3f422420cfdb332414543b62fc4e4a5. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.
- **CVE-2021-44499**: An issue was discovered in FIS GT.M through V7.0-000 (related to the YottaDB code base). Using crafted input, an attacker can cause a call to $Extract to force an signed integer holding the size of a buffer to take on a large negative number, which is then used as the length of a memcpy call that occurs on the stack, causing a buffer overflow.


# Relevant CWE Specifications

## CWE-681: Incorrect Conversion between Numeric Types
**Abstraction:** Base
**Status:** Draft

### Description
When converting from one data type to another, such as long to integer, data can be omitted or translated in a way that produces unexpected values. If the resulting values are used in a sensitive context, then dangerous behaviors may occur.

### Extended Description
Not provided

### Alternative Terms
None

### Relationships
ChildOf -> CWE-704
ChildOf -> CWE-704
CanPrecede -> CWE-682
ParentOf -> CWE-192
ParentOf -> CWE-194
ParentOf -> CWE-195
ParentOf -> CWE-196
ParentOf -> CWE-197

### Mapping Guidance
**Usage:** Allowed
**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.
**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.
**Reasons:**
- Acceptable-Use


### Potential Mitigations
**Mitigation 1:**
- **Phase:** Implementation
- **Description:** Avoid making conversion between numeric types. Always check for the allowed ranges.




### Observed Examples
- **CVE-2022-2639:** Chain: integer coercion error (CWE-192) prevents a return value from indicating an error, leading to out-of-bounds write (CWE-787)
- **CVE-2021-43537:** Chain: in a web browser, an unsigned 64-bit integer is forcibly cast to a 32-bit integer (CWE-681) and potentially leading to an integer overflow (CWE-190). If an integer overflow occurs, this can cause heap memory corruption (CWE-122)
- **CVE-2007-4268:** Chain: integer signedness error (CWE-195) passes signed comparison, leading to heap overflow (CWE-122)



## CWE-194: Unexpected Sign Extension
**Abstraction:** Variant
**Status:** Incomplete

### Description
The product performs an operation on a number that causes it to be sign extended when it is transformed into a larger data type. When the original number is negative, this can produce unexpected values that lead to resultant weaknesses.

### Extended Description
Not provided

### Alternative Terms
None

### Relationships
ChildOf -> CWE-681
ChildOf -> CWE-681
ChildOf -> CWE-681

### Mapping Guidance
**Usage:** Allowed
**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.
**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.
**Reasons:**
- Acceptable-Use


### Potential Mitigations
**Mitigation 1:**
- **Phase:** Implementation
- **Description:** Avoid using signed variables if you don't need to represent negative values. When negative values are needed, perform validation after you save those values to larger data types, or before passing them to functions that are expecting unsigned values.



### Additional Notes
**[Relationship]** Sign extension errors can lead to buffer overflows and other memory-based problems. They are also likely to be factors in other weaknesses that are not based on memory operations, but rely on numeric calculation.

**[Maintenance]** This entry is closely associated with signed-to-unsigned conversion errors (CWE-195) and other numeric errors. These relationships need to be more closely examined within CWE.



### Observed Examples
- **CVE-2018-10887:** Chain: unexpected sign extension (CWE-194) leads to integer overflow (CWE-190), causing an out-of-bounds read (CWE-125)
- **CVE-1999-0234:** Sign extension error produces -1 value that is treated as a command separator, enabling OS command injection.
- **CVE-2003-0161:** Product uses "char" type for input character. When char is implemented as a signed type, ASCII value 0xFF (255), a sign extension produces a -1 value that is treated as a program-specific separator value, effectively disabling a length check and leading to a buffer overflow. This is also a multiple interpretation error.



## CWE-787: Out-of-bounds Write
**Abstraction:** Base
**Status:** Draft

### Description
The product writes data past the end, or before the beginning, of the intended buffer.

### Extended Description
Not provided

### Alternative Terms
Memory Corruption: Often used to describe the consequences of writing to memory outside the bounds of a buffer, or to memory that is otherwise invalid.

### Relationships
ChildOf -> CWE-119
ChildOf -> CWE-119
ChildOf -> CWE-119
ChildOf -> CWE-119
ParentOf -> CWE-121
ParentOf -> CWE-122
ParentOf -> CWE-123
ParentOf -> CWE-124
CanFollow -> CWE-822
CanFollow -> CWE-823
CanFollow -> CWE-824
CanFollow -> CWE-825

### Mapping Guidance
**Usage:** Allowed
**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.
**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.
**Reasons:**
- Acceptable-Use


### Potential Mitigations
**Mitigation 1:**
- **Phase:** Requirements
- **Strategy:** Language Selection
- **Description:** 

Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.


For example, many languages that perform their own memory management, such as Java and Perl, are not subject to buffer overflows. Other languages, such as Ada and C#, typically provide overflow protection, but the protection can be disabled by the programmer.


Be wary that a language's interface to native code may still be subject to overflows, even if the language itself is theoretically safe.


**Mitigation 2:**
- **Phase:** Architecture and Design
- **Strategy:** Libraries or Frameworks
- **Description:** 

Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.


Examples include the Safe C String Library (SafeStr) by Messier and Viega [REF-57], and the Strsafe.h library from Microsoft [REF-56]. These libraries provide safer versions of overflow-prone string-handling functions.


**Mitigation 3:**
- **Phase:** Operation, Build and Compilation
- **Effectiveness:** Defense in Depth
- **Strategy:** Environment Hardening
- **Description:** 

Use automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking. 


 D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail. 





### Observed Examples
- **CVE-2023-1017:** The reference implementation code for a Trusted Platform Module does not implement length checks on data, allowing for an attacker to write 2 bytes past the end of a buffer.
- **CVE-2021-21220:** Chain: insufficient input validation (CWE-20) in browser allows heap corruption (CWE-787), as exploited in the wild per CISA KEV.
- **CVE-2021-28664:** GPU kernel driver allows memory corruption because a user can obtain read/write access to read-only pages, as exploited in the wild per CISA KEV.



## CWE-125: Out-of-bounds Read
**Abstraction:** Base
**Status:** Draft

### Description
The product reads data past the end, or before the beginning, of the intended buffer.

### Extended Description
Not provided

### Alternative Terms
OOB read: Shorthand for "Out of bounds" read

### Relationships
ChildOf -> CWE-119
ChildOf -> CWE-119
ChildOf -> CWE-119
ChildOf -> CWE-119
ParentOf -> CWE-126
ParentOf -> CWE-127
CanFollow -> CWE-822
CanFollow -> CWE-823
CanFollow -> CWE-824
CanFollow -> CWE-825

### Mapping Guidance
**Usage:** Allowed
**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.
**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.
**Reasons:**
- Acceptable-Use


### Potential Mitigations
**Mitigation 1:**
- **Phase:** Implementation
- **Strategy:** Input Validation
- **Description:** 

Assume all input is malicious. Use an "accept known good" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.


When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, "boat" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as "red" or "blue."


Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.


To reduce the likelihood of introducing an out-of-bounds read, ensure that you validate and ensure correct calculations for any length argument, buffer size calculation, or offset. Be especially careful of relying on a sentinel (i.e. special character such as NUL) in untrusted inputs.


**Mitigation 2:**
- **Phase:** Architecture and Design
- **Strategy:** Language Selection
- **Description:** Use a language that provides appropriate memory abstractions.




### Observed Examples
- **CVE-2023-1018:** The reference implementation code for a Trusted Platform Module does not implement length checks on data, allowing for an attacker to read 2 bytes past the end of a buffer.
- **CVE-2020-11899:** Out-of-bounds read in IP stack used in embedded systems, as exploited in the wild per CISA KEV.
- **CVE-2014-0160:** Chain: "Heartbleed" bug receives an inconsistent length parameter (CWE-130) enabling an out-of-bounds read (CWE-126), returning memory that could include private cryptographic keys and other sensitive data.

