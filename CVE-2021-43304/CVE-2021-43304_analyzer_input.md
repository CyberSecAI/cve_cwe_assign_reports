# Vulnerability Information: CVE-2021-43304

## Vulnerability Description
Heap buffer overflow in Clickhouses LZ4 compression codec when parsing a malicious query. There is no verification that the copy operations in the LZ4decompressImpl loop and especially the arbitrary copy operation wildCopy(op, ip, copy_end), dont exceed the destination buffers limits.

### Vulnerability Description Key Phrases
- **rootcause:** **arbitrary copy operation without bounds check**
- **weakness:** **heap buffer overflow**
- **vector:** malicious query
- **product:** Clickhouse
- **component:** LZ4 compression codec

## CVE Reference Links Content Summary
Based on the provided information, here's a breakdown of the vulnerability:

**CVE-2021-43304**

*   **Root Cause:** Heap buffer overflow in the LZ4 decompression routine. The vulnerability lies in the `wildCopy` function within the `LZ4::decompressImpl` loop, where a user-controlled length is used to copy data into a destination buffer, without proper bounds checking, allowing an attacker to write beyond the allocated buffer. The `wildCopy` function is called with a `copy_end` value which is calculated based on a user-provided length, but the actual copy operation is performed in chunks of `copy_amount` bytes, which can result in writing up to `copy_amount - 1` bytes beyond the intended `copy_end`.
*   **Weaknesses/Vulnerabilities:**
    *   **Heap buffer overflow:**  The code doesn't properly check if the copy operation in `wildCopy` exceeds the destination buffer's bounds.
    *   **User-controlled length:** The length of data copied using `wildCopy` is derived from the compressed data which is under user control.
*   **Impact of Exploitation:**
    *   **Remote Code Execution (RCE):** By overflowing the buffer, an attacker can overwrite adjacent memory regions, potentially including critical data or function pointers, and gain control of program execution.
    *   **Denial of Service (DoS):**  A crash can be triggered if the overflow overwrites critical data, causing the service to stop responding.
*   **Attack Vectors:**
    *   The attack vector is through a crafted compressed query sent to the ClickHouse server using the `decompress=1` parameter in the URL.
    *   The compressed data contains a header with the expected decompressed size, and a compressed payload. An attacker manipulates the header and compressed data to cause the overflow during decompression.
*  **Required Attacker Capabilities/Position:**
    *  Attacker requires access to the ClickHouse server and valid credentials (any set of credentials).
    *  Attacker needs to be able to send HTTP requests to the ClickHouse server, including the `decompress=1` query parameter.
    *  Attacker needs to have some understanding of the format of compressed queries in ClickHouse.

**Additional Notes:**
* The vulnerability is located in `LZ4_decompress_faster.cpp` in the ClickHouse codebase.
* The `wildCopy` function's implementation is optimized using a loop and memory copy operations of size `copy_amount`, which is a template parameter of the decompression function and can be 8, 16, or 32 bytes.
* The `wildCopy` function may write up to `copy_amount - 1` bytes past the intended end of a copy, which makes the issue harder to detect.
* The provided jfrog.com content gives a comprehensive explanation of this and other vulnerabilities discovered in ClickHouse including a crafted exploit example and a proof of concept crash using a crafted compressed file.

The provided content from `github.com` includes the vulnerable source code. The content from `lists.debian.org` confirms that this CVE was addressed in a Debian LTS security update.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage | Combined Score | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|---------------|------------|-------------------|
| 1 | CWE-190 | Integer Overflow or Wraparound | Base | Allowed | 0.6929 | dense, sparse, graph | dense: 0.501, sparse: 0.322, graph: 0.722 |
| 2 | CWE-120 | Buffer Copy without Checking Size of Input ('Classic Buffer Overflow') | Base | Allowed-with-Review | 0.6702 | dense, sparse, graph | dense: 0.466, sparse: 0.340, graph: 0.768 |
| 3 | CWE-125 | Out-of-bounds Read | Base | Allowed | 0.4760 | sparse, graph | sparse: 0.317, graph: 0.823 |
| 4 | CWE-1284 | Improper Validation of Specified Quantity in Input | Base | Allowed | 0.4500 | sparse, graph | sparse: 0.293, graph: 0.789 |
| 5 | CWE-787 | Out-of-bounds Write | Base | Allowed | 0.4474 | sparse, graph | sparse: 0.274, graph: 0.813 |
| 6 | CWE-122 | Heap-based Buffer Overflow | Variant | Allowed | 0.4393 | dense, sparse | dense: 0.502, sparse: 0.392 |
| 7 | CWE-124 | Buffer Underwrite ('Buffer Underflow') | Base | Allowed | 0.4088 | dense, sparse | dense: 0.476, sparse: 0.298 |
| 8 | CWE-131 | Incorrect Calculation of Buffer Size | Base | Allowed | 0.4016 | dense, sparse | dense: 0.463, sparse: 0.297 |
| 9 | CWE-197 | Numeric Truncation Error | Base | Allowed | 0.3961 | dense, sparse | dense: 0.461, sparse: 0.289 |
| 10 | CWE-835 | Loop with Unreachable Exit Condition ('Infinite Loop') | Base | Allowed | 0.3951 | dense, sparse | dense: 0.461, sparse: 0.288 |

