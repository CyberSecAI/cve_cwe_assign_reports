# Critic Input for CVE-2021-21474



# Original Analyzer Input
## Vulnerability Description
SAP HANA Database, versions - 1.0, 2.0, accepts SAML tokens with MD5 digest, an attacker who manages to obtain an MD5-digest signed SAML Assertion issued for an SAP HANA instance might be able to tamper with it and alter it in a way that the digest continues to be the same and without invalidating the digital signature, this allows them to impersonate as user in HANA database and be able to read the contents in the database.

### Vulnerability Description Key Phrases
- **rootcause:** **use of MD5 digest**
- **weakness:** **signature spoofing**
- **impact:** impersonate user, read database contents
- **attacker:** attacker
- **product:** SAP HANA Database
- **version:** 1.0, 2.0
- **component:** SAML token authentication

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage | Combined Score | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|---------------|------------|-------------------|
| 1 | CWE-328 | Use of Weak Hash | Base | Allowed | 1.0047 | dense, sparse, graph | dense: 0.438, sparse: 1.000, graph: 0.598 |
| 2 | CWE-347 | Improper Verification of Cryptographic Signature | Base | Allowed | 0.7756 | dense, sparse, graph | dense: 0.411, sparse: 0.643, graph: 0.565 |
| 3 | CWE-916 | Use of Password Hash With Insufficient Computational Effort | Base | Allowed | 0.7668 | dense, sparse, graph | dense: 0.443, sparse: 0.579, graph: 0.599 |
| 4 | CWE-319 | Cleartext Transmission of Sensitive Information | Base | Allowed | 0.6454 | sparse, graph | sparse: 0.593, graph: 0.857 |
| 5 | CWE-760 | Use of a One-Way Hash with a Predictable Salt | Variant | Allowed | 0.3865 | dense, sparse | dense: 0.433, sparse: 0.353 |
| 6 | CWE-306 | Missing Authentication for Critical Function | Base | Allowed | 0.3185 | sparse | sparse: 0.557 |
| 7 | CWE-611 | Improper Restriction of XML External Entity Reference | Base | Allowed | 0.3172 | sparse | sparse: 0.555 |
| 8 | CWE-256 | Plaintext Storage of a Password | Base | Allowed | 0.3124 | sparse | sparse: 0.546 |
| 9 | CWE-325 | Missing Cryptographic Step | Base | Allowed | 0.3120 | sparse | sparse: 0.545 |
| 10 | CWE-327 | Use of a Broken or Risky Cryptographic Algorithm | Class | Allowed-with-Review | 0.3043 | sparse, graph | sparse: 0.591, graph: 0.503 |



# Analysis to Review
# Summary
| CWE ID | CWE Name | Confidence | CWE Abstraction Level | CWE Vulnerability Mapping Label | CWE-Vulnerability Mapping Notes |
|---|---|---|---|---|---|
| CWE-328 | Use of Weak Hash | 0.9 | Base | Allowed | Primary CWE |
| CWE-347 | Improper Verification of Cryptographic Signature | 0.6 | Base | Allowed | Secondary Candidate |

## Evidence and Confidence

*   **Confidence Score:** 0.75
*   **Evidence Strength:** MEDIUM

- **Analysis and Justification:**  
  - *Explanation:* The vulnerability description clearly states that the SAP HANA Database accepts SAML tokens with MD5 digest. This indicates a **use of a weak hash**, specifically MD5, which is vulnerable to collision attacks. An attacker can manipulate the SAML assertion without invalidating the digital signature due to the weakness of MD5. This directly aligns with CWE-328, "Use of Weak Hash," because MD5 does not meet security expectations for a hash function, as attackers can find collisions. CWE-328 is a Base level CWE, which is preferred. While other CWEs such as CWE-916 (Use of Password Hash With Insufficient Computational Effort) are also relevant, CWE-328 is more appropriate as it focuses on the general weakness of the hash algorithm used in the signature, rather than specifically focusing on password hashing. The MITRE mapping guidance for CWE-328 specifies that its usage is ALLOWED.
  
  - *Relationship Analysis:* CWE-328 is a Base level CWE. CWE-328 is a parent of CWE-916 (Use of Password Hash With Insufficient Computational Effort). Given the vulnerability focuses on the general use of a weak hash (MD5) for signatures, CWE-328 is more fitting.

- **Confidence Score:**  
  - *Example:* Confidence: 0.9 (High confidence due to explicit mention of MD5 usage and the ability to tamper with signatures)

---

- **Analysis and Justification:**  
  - *Explanation:* The vulnerability also involves the ability to alter a signed SAML assertion in a way that the digest remains the same, effectively spoofing the signature. This points towards CWE-347, "Improper Verification of Cryptographic Signature". While the **root cause** is the **use of a weak hash**, the direct consequence is the **failure to properly verify the digital signature**, enabling impersonation. However, the primary issue stems from using MD5 and not necessarily from the verification process itself. So, this is added as a secondary candidate. The MITRE mapping guidance for CWE-347 specifies that its usage is ALLOWED.
  
  - *Relationship Analysis:* There is no direct relationship between CWE-328 and CWE-347. CWE-347 highlights a failure in verifying the signature, which is a consequence of the weak hash algorithm used.

- **Confidence Score:**  
  - *Example:* Confidence: 0.6 (Medium confidence as this is a consequence of the weak hash rather than a direct implementation flaw in the signature verification logic)

# CWE Examples from Database


## Known Examples for CWE-347: Improper Verification of Cryptographic Signature
### Observed Examples
- **CVE-2002-1796** [https://www.cve.org/CVERecord?id=CVE-2002-1796](https://www.cve.org/CVERecord?id=CVE-2002-1796): Does not properly verify signatures for "trusted" entities.
- **CVE-2005-2181** [https://www.cve.org/CVERecord?id=CVE-2005-2181](https://www.cve.org/CVERecord?id=CVE-2005-2181): Insufficient verification allows spoofing.
- **CVE-2005-2182** [https://www.cve.org/CVERecord?id=CVE-2005-2182](https://www.cve.org/CVERecord?id=CVE-2005-2182): Insufficient verification allows spoofing.
- **CVE-2002-1706** [https://www.cve.org/CVERecord?id=CVE-2002-1706](https://www.cve.org/CVERecord?id=CVE-2002-1706): Accepts a configuration file without a Message Integrity Check (MIC) signature.
### Top 25 Examples
- **CVE-2021-21405**: Lotus is an Implementation of the Filecoin protocol written in Go. BLS signature validation in lotus uses blst library method VerifyCompressed. This method accepts signatures in 2 forms: "serialized", and "compressed", meaning that BLS signatures can be provided as either of 2 unique byte arrays. Lotus block validation functions perform a uniqueness check on provided blocks. Two blocks are considered distinct if the CIDs of their blockheader do not match. The CID method for blockheader includes the BlockSig of the block. The result of these issues is that it would be possible to punish miners for valid blocks, as there are two different valid block CIDs available for each block, even though this must be unique. By switching from the go based `blst` bindings over to the bindings in `filecoin-ffi`, the code paths now ensure that all signatures are compressed by size and the way they are deserialized. This happened in https://github.com/filecoin-project/lotus/pull/5393.
- **CVE-2020-23533**: Union Pay up to 1.2.0, for web based versions contains a CWE-347: Improper Verification of Cryptographic Signature vulnerability, allows attackers to shop for free in merchants' websites and mobile apps, via a crafted authentication code (MAC) which is generated based on a secret key which is NULL.
- **CVE-2021-0152**: Improper verification of cryptographic signature in the installer for some Intel(R) Wireless Bluetooth(R) and Killer(TM) Bluetooth(R) products in Windows 10 may allow an authenticated user to potentially enable denial of service via local access.
- **CVE-2021-21238**: PySAML2 is a pure python implementation of SAML Version 2 Standard. PySAML2 before 6.5.0 has an improper verification of cryptographic signature vulnerability. All users of pysaml2 that need to validate signed SAML documents are impacted. The vulnerability is a variant of XML Signature wrapping because it did not validate the SAML document against an XML schema. This allowed invalid XML documents to be processed and such a document can trick pysaml2 with a wrapped signature. This is fixed in PySAML2 6.5.0.
- **CVE-2021-21239**: PySAML2 is a pure python implementation of SAML Version 2 Standard. PySAML2 before 6.5.0 has an improper verification of cryptographic signature vulnerability. Users of pysaml2 that use the default CryptoBackendXmlSec1 backend and need to verify signed SAML documents are impacted. PySAML2 does not ensure that a signed SAML document is correctly signed. The default CryptoBackendXmlSec1 backend is using the xmlsec1 binary to verify the signature of signed SAML documents, but by default xmlsec1 accepts any type of key found within the given document. xmlsec1 needs to be configured explicitly to only use only _x509 certificates_ for the verification process of the SAML document signature. This is fixed in PySAML2 6.5.0.
- **CVE-2021-22708**: A CWE-347: Improper Verification of Cryptographic Signature vulnerability exists in EVlink City (EVC1S22P4 / EVC1S7P4 all versions prior to R8 V3.4.0.1), EVlink Parking (EVW2 / EVF2 / EV.2 all versions prior to R8 V3.4.0.1), and EVlink Smart Wallbox (EVB1A all versions prior to R8 V3.4.0.1 ) that could allow an attacker to craft a malicious firmware package and bypass the signature verification mechanism.


# Relevant CWE Specifications

## CWE-347: Improper Verification of Cryptographic Signature
**Abstraction:** Base
**Status:** Draft

### Description
The product does not verify, or incorrectly verifies, the cryptographic signature for data.

### Extended Description
Not provided

### Alternative Terms
None

### Relationships
ChildOf -> CWE-345
ChildOf -> CWE-345

### Mapping Guidance
**Usage:** Allowed
**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.
**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.
**Reasons:**
- Acceptable-Use




### Observed Examples
- **CVE-2002-1796:** Does not properly verify signatures for "trusted" entities.
- **CVE-2005-2181:** Insufficient verification allows spoofing.
- **CVE-2005-2182:** Insufficient verification allows spoofing.



## CWE-328: Use of Weak Hash
**Abstraction:** Base
**Status:** Draft

### Description
The product uses an algorithm that produces a digest (output value) that does not meet security expectations for a hash function that allows an adversary to reasonably determine the original input (preimage attack), find another input that can produce the same hash (2nd preimage attack), or find multiple inputs that evaluate to the same hash (birthday attack).

### Extended Description


A hash function is defined as an algorithm that maps arbitrarily sized data into a fixed-sized digest (output) such that the following properties hold:


  1. The algorithm is not invertible (also called "one-way" or "not reversible")

  1. The algorithm is deterministic; the same input produces the same digest every time

 Building on this definition, a cryptographic hash function must also ensure that a malicious actor cannot leverage the hash function to have a reasonable chance of success at determining any of the following:

  1. the original input (preimage attack), given only the digest

  1. another input that can produce the same digest (2nd preimage attack), given the original input

  1. a set of two or more inputs that evaluate to the same digest (birthday attack), given the actor can arbitrarily choose the inputs to be hashed and can do so a reasonable amount of times

What is regarded as "reasonable" varies by context and threat model, but in general, "reasonable" could cover any attack that is more efficient than brute force (i.e., on average, attempting half of all possible combinations). Note that some attacks might be more efficient than brute force but are still not regarded as achievable in the real world.

Any algorithm that does not meet the above conditions will generally be considered weak for general use in hashing.


In addition to algorithmic weaknesses, a hash function can be made weak by using the hash in a security context that breaks its security guarantees. For example, using a hash function without a salt for storing passwords (that are sufficiently short) could enable an adversary to create a "rainbow table" [REF-637] to recover the password under certain conditions; this attack works against such hash functions as MD5, SHA-1, and SHA-2.


### Alternative Terms
None

### Relationships
ChildOf -> CWE-326
ChildOf -> CWE-327
ParentOf -> CWE-916

### Mapping Guidance
**Usage:** Allowed
**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.
**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.
**Reasons:**
- Acceptable-Use


### Potential Mitigations
**Mitigation 1:**
- **Phase:** Architecture and Design
- **Effectiveness:** High
- **Description:** 

Use an adaptive hash function that can be configured to change the amount of computational effort needed to compute the hash, such as the number of iterations ("stretching") or the amount of memory required. Some hash functions perform salting automatically. These functions can significantly increase the overhead for a brute force attack compared to intentionally-fast functions such as MD5. For example, rainbow table attacks can become infeasible due to the high computing overhead. Finally, since computing power gets faster and cheaper over time, the technique can be reconfigured to increase the workload without forcing an entire replacement of the algorithm in use.


Some hash functions that have one or more of these desired properties include bcrypt [REF-291], scrypt [REF-292], and PBKDF2 [REF-293]. While there is active debate about which of these is the most effective, they are all stronger than using salts with hash functions with very little computing overhead.


Note that using these functions can have an impact on performance, so they require special consideration to avoid denial-of-service attacks. However, their configurability provides finer control over how much CPU and memory is used, so it could be adjusted to suit the environment's needs.




### Additional Notes
**[Maintenance]** Since CWE 4.4, various cryptography-related entries including CWE-328 have been slated for extensive research, analysis, and community consultation to define consistent terminology, improve relationships, and reduce overlap or duplication. As of CWE 4.6, this work is still ongoing.



### Observed Examples
- **CVE-2022-30320:** Programmable Logic Controller (PLC) uses a protocol with a cryptographically insecure hashing algorithm for passwords.
- **CVE-2005-4900:** SHA-1 algorithm is not collision-resistant.
- **CVE-2020-25685:** DNS product uses a weak hash (CRC32 or SHA-1) of the query name, allowing attacker to forge responses by computing domain names with the same hash.



## CWE-916: Use of Password Hash With Insufficient Computational Effort
**Abstraction:** Base
**Status:** Incomplete

### Description
The product generates a hash for a password, but it uses a scheme that does not provide a sufficient level of computational effort that would make password cracking attacks infeasible or expensive.

### Extended Description


Many password storage mechanisms compute a hash and store the hash, instead of storing the original password in plaintext. In this design, authentication involves accepting an incoming password, computing its hash, and comparing it to the stored hash.


Many hash algorithms are designed to execute quickly with minimal overhead, even cryptographic hashes. However, this efficiency is a problem for password storage, because it can reduce an attacker's workload for brute-force password cracking. If an attacker can obtain the hashes through some other method (such as SQL injection on a database that stores hashes), then the attacker can store the hashes offline and use various techniques to crack the passwords by computing hashes efficiently. Without a built-in workload, modern attacks can compute large numbers of hashes, or even exhaust the entire space of all possible passwords, within a very short amount of time, using massively-parallel computing (such as cloud computing) and GPU, ASIC, or FPGA hardware. In such a scenario, an efficient hash algorithm helps the attacker.


There are several properties of a hash scheme that are relevant to its strength against an offline, massively-parallel attack:


  - The amount of CPU time required to compute the hash ("stretching")

  - The amount of memory required to compute the hash ("memory-hard" operations)

  - Including a random value, along with the password, as input to the hash computation ("salting")

  - Given a hash, there is no known way of determining an input (e.g., a password) that produces this hash value, other than by guessing possible inputs ("one-way" hashing)

  - Relative to the number of all possible hashes that can be generated by the scheme, there is a low likelihood of producing the same hash for multiple different inputs ("collision resistance")

Note that the security requirements for the product may vary depending on the environment and the value of the passwords. Different schemes might not provide all of these properties, yet may still provide sufficient security for the environment. Conversely, a solution might be very strong in preserving one property, which still being very weak for an attack against another property, or it might not be able to significantly reduce the efficiency of a massively-parallel attack.

### Alternative Terms
None

### Relationships
ChildOf -> CWE-328
ChildOf -> CWE-327
ParentOf -> CWE-759
ParentOf -> CWE-760

### Mapping Guidance
**Usage:** Allowed
**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.
**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.
**Reasons:**
- Acceptable-Use


### Potential Mitigations
**Mitigation 1:**
- **Phase:** Architecture and Design
- **Effectiveness:** High
- **Description:** 

Use an adaptive hash function that can be configured to change the amount of computational effort needed to compute the hash, such as the number of iterations ("stretching") or the amount of memory required. Some hash functions perform salting automatically. These functions can significantly increase the overhead for a brute force attack compared to intentionally-fast functions such as MD5. For example, rainbow table attacks can become infeasible due to the high computing overhead. Finally, since computing power gets faster and cheaper over time, the technique can be reconfigured to increase the workload without forcing an entire replacement of the algorithm in use.


Some hash functions that have one or more of these desired properties include bcrypt [REF-291], scrypt [REF-292], and PBKDF2 [REF-293]. While there is active debate about which of these is the most effective, they are all stronger than using salts with hash functions with very little computing overhead.


Note that using these functions can have an impact on performance, so they require special consideration to avoid denial-of-service attacks. However, their configurability provides finer control over how much CPU and memory is used, so it could be adjusted to suit the environment's needs.


**Mitigation 2:**
- **Phase:** Implementation, Architecture and Design
- **Description:** When using industry-approved techniques, use them correctly. Don't cut corners by skipping resource-intensive steps (CWE-325). These steps are often essential for preventing common attacks.




### Observed Examples
- **CVE-2008-1526:** Router does not use a salt with a hash, making it easier to crack passwords.
- **CVE-2006-1058:** Router does not use a salt with a hash, making it easier to crack passwords.
- **CVE-2008-4905:** Blogging software uses a hard-coded salt when calculating a password hash.

