# Vulnerability Information: CVE-2022-25258

## Vulnerability Description
An issue was discovered in drivers/usb/gadget/composite.c in the Linux kernel before 5.16.10. The USB Gadget subsystem **lacks certain validation of interface OS descriptor requests** (ones with a large array index and ones associated with NULL function pointer retrieval). Memory corruption might occur.

### Vulnerability Description Key Phrases
- **rootcause:** **lacks certain validation of interface OS descriptor requests**
- **impact:** Memory corruption
- **vector:** requests with a large array index and ones associated with NULL function pointer retrieval
- **product:** Linux kernel
- **version:** before 5.16.10
- **component:** drivers/usb/gadget/composite.c

## CVE Reference Links Content Summary
Based on the provided content, here's an analysis of CVE-2022-25258:

**1.  Verification of CVE Relevance**

*   The content from Debian Security Advisories (DSA-5092-1, DLA 2941-1, DSA-5096-1) and the NetApp Security Advisory (NTAP-20221028-0007), as well as the commit log from the Linux kernel source code,  explicitly mentions CVE-2022-25258, confirming its relevance.
* The github repository [szymonh/d-os-descriptor](https://github.com/szymonh/d-os-descriptor) provides a demo exploit for CVE-2022-25258

**2. Root Cause of the Vulnerability**

*   The vulnerability lies in the USB Gadget subsystem within the Linux kernel, specifically in how it handles interface OS descriptor requests.
*   The `composite_setup()` function lacks proper validation of the `interface` variable, which is derived from the `w_value` field of a USB control transfer request. This variable is used as an index into the `usb_configuration->interface` array.
*   The functions `count_ext_prop`, `len_ext_prop` and `fill_ext_prop` which are called by `composite_setup()` also lack validation of `usb_function` pointer which is retrieved by using the interface variable as an index.

**3. Weaknesses/Vulnerabilities Present**

*   **Missing Bounds Check:** The `interface` variable is not checked against the valid range of indices for the `c->interface` array, which has a size of `MAX_CONFIG_INTERFACES (16)`. This can lead to out-of-bounds access.
*   **Null Pointer Dereference:** The functions `count_ext_prop`, `len_ext_prop`, and `fill_ext_prop` do not check if the retrieved `usb_function` pointer from `c->interface` array is valid before dereferencing, which leads to a null pointer dereference if the pointer is NULL.
*   **Potential Memory Corruption:** While less likely, the lack of length validation combined with a specific memory layout could lead to a buffer overflow via `fill_ext_prop` and `usb_ext_prop_put_binary` if a crafted request with `wLength` greater than 0x0A is sent

**4. Impact of Exploitation**

*   **Denial of Service (DoS):** By sending a crafted USB control transfer request, an attacker can cause the target device to crash. The vulnerability may also cause a denial of service due to memory corruption.
*   **Memory Corruption:** The missing bounds check and NULL pointer dereference can lead to arbitrary memory corruption, allowing an attacker to potentially alter kernel data and control execution flow.
*   **Information Leak:** By reading out-of-bounds memory, an attacker could potentially leak sensitive kernel information, although this scenario seems to be less probable due to the specific conditions required to trigger it.

**5. Attack Vectors**

*   **Local Attack (Physical Access):** An attacker with physical access to the target device can exploit this vulnerability by connecting a malicious USB device.
*   **Malicious USB Device:** A crafted USB device could send malicious USB control transfer requests to trigger the vulnerability.

**6. Required Attacker Capabilities/Position**

*   **Physical Access:** The attacker must have the ability to physically connect a USB device to the target system.
*   **USB Device Knowledge:**  The attacker must be capable of crafting USB control transfer requests that target the OS descriptor handling section within the USB gadget subsystem.

**7. Additional Details:**
*   The provided github repo [szymonh/d-os-descriptor](https://github.com/szymonh/d-os-descriptor) contains a python script that demonstrates how to trigger the vulnerability. The vulnerability can be triggered in a single control transfer message.
*   The fix for this vulnerability, which involves validating the interface index and retrieved function pointer, is available in [this commit](https://github.com/torvalds/linux/commit/75e5b4849b81e19e9efe1654b30d7f3151c33c2c).

In summary, CVE-2022-25258 is a medium-severity vulnerability in the Linux kernel's USB Gadget subsystem that could be exploited by a physically present attacker with a malicious USB device to cause a denial-of-service via memory corruption or a null pointer dereference, potentially leading to privilege escalation.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage | Combined Score | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|---------------|------------|-------------------|
| 1 | CWE-1284 | Improper Validation of Specified Quantity in Input | Base | Allowed | 0.7317 | dense, sparse, graph | dense: 0.540, sparse: 0.234, graph: 0.916 |
| 2 | CWE-476 | NULL Pointer Dereference | Base | Allowed | 0.5484 | sparse, graph | sparse: 0.334, graph: 1.000 |
| 3 | CWE-1285 | Improper Validation of Specified Index, Position, or Offset in Input | Base | Allowed | 0.4198 | dense, sparse | dense: 0.589, sparse: 0.218 |
| 4 | CWE-908 | Use of Uninitialized Resource | Base | Allowed | 0.3918 | dense, sparse | dense: 0.541, sparse: 0.212 |
| 5 | CWE-822 | Untrusted Pointer Dereference | Base | Allowed | 0.3906 | dense, sparse | dense: 0.539, sparse: 0.211 |
| 6 | CWE-787 | Out-of-bounds Write | Base | Allowed | 0.3854 | dense, sparse | dense: 0.543, sparse: 0.199 |
| 7 | CWE-126 | Buffer Over-read | Variant | Allowed | 0.3580 | dense, sparse | dense: 0.536, sparse: 0.209 |
| 8 | CWE-122 | Heap-based Buffer Overflow | Variant | Allowed | 0.3556 | dense, sparse | dense: 0.541, sparse: 0.200 |
| 9 | CWE-401 | Missing Release of Memory after Effective Lifetime | Variant | Allowed | 0.3541 | dense, sparse | dense: 0.533, sparse: 0.205 |
| 10 | CWE-362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | Allowed-with-Review | 0.2366 | dense, sparse | dense: 0.559, sparse: 0.215 |

