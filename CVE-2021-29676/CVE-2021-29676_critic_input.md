# Critic Input for CVE-2021-29676



# Original Analyzer Input
## Vulnerability Description
IBM Security Verify (IBM Security Verify Privilege Vault 10.9.66) is vulnerable to **link injection**. By persuading a victim to click on a specially-crafted URL link, a remote attacker could exploit this vulnerability to conduct various attacks against the vulnerable system, including cross-site scripting, cache poisoning or session hijacking

### Vulnerability Description Key Phrases
- **weakness:** **link injection**
- **impact:** ['cross-site scripting', 'cache poisoning', 'session hijacking']
- **vector:** specially-crafted URL link
- **attacker:** remote attacker
- **product:** IBM Security Verify Privilege Vault
- **version:** 10.9.66

## CVE Reference Links Content Summary
Based on the provided document, here's an analysis of CVE-2021-29676:

**Summary:**

Multiple vulnerabilities were identified in IBM Security Verify Privilege Vault (formerly IBM Security Secret Server) prior to version 10.9.66.

**Root Cause of Vulnerability:**

The document does not specify the exact root cause of the vulnerability, only that multiple vulnerabilities exist. It indicates that these vulnerabilities were addressed in version 10.9.66.

**Weaknesses/Vulnerabilities Present:**

Multiple unspecified vulnerabilities.

**Impact of Exploitation:**

The document doesn't detail the specific impact of these vulnerabilities but states they are security-related and require a patch. The impact would likely vary depending on the specific vulnerability exploited.  It is mentioned that the CVSS environment score is customer environment specific, meaning the impact could vary based on the user's specific setup.

**Attack Vectors:**

The document does not explicitly describe attack vectors.

**Required Attacker Capabilities/Position:**

The document doesn't detail the attacker's required capabilities or position, but one can infer the following:
*   The vulnerabilities are likely exploitable by an external or internal actor with access to the vulnerable service or product.
*   Specific capabilities would vary based on the specific vulnerability being exploited.

**Additional Notes:**

*   The provided information is a security bulletin and does not include detailed technical information on the vulnerabilities.
*   The document suggests upgrading to version 10.9.66 as the remediation.
*   The IBM X-Force Ethical Hacking Team is acknowledged for their contribution to discovering the vulnerabilities.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage | Combined Score | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|---------------|------------|-------------------|
| 1 | CWE-80 | Improper Neutralization of Script-Related HTML Tags in a Web Page (Basic XSS) | Variant | Allowed | 0.5620 | dense, sparse, graph | dense: 0.537, sparse: 0.251, graph: 0.550 |
| 2 | CWE-79 | Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting') | Base | Allowed | 0.5014 | sparse, graph | sparse: 0.252, graph: 1.000 |
| 3 | CWE-113 | Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Request/Response Splitting') | Variant | Allowed | 0.4522 | sparse, graph | sparse: 0.231, graph: 1.000 |
| 4 | CWE-78 | Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection') | Base | Allowed | 0.4228 | sparse, graph | sparse: 0.198, graph: 0.865 |
| 5 | CWE-89 | Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection') | Base | Allowed | 0.3932 | dense, sparse | dense: 0.552, sparse: 0.204 |
| 6 | CWE-352 | Cross-Site Request Forgery (CSRF) | Compound | Allowed | 0.3147 | sparse, graph | sparse: 0.231, graph: 0.775 |
| 7 | CWE-327 | Use of a Broken or Risky Cryptographic Algorithm | Class | Allowed-with-Review | 0.2270 | dense, sparse | dense: 0.553, sparse: 0.192 |
| 8 | CWE-74 | Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection') | Class | Discouraged | 0.1963 | dense, sparse | dense: 0.535, sparse: 0.298 |
| 9 | CWE-20 | Improper Input Validation | Class | Discouraged | 0.1756 | dense, sparse | dense: 0.534, sparse: 0.218 |
| 10 | CWE-287 | Improper Authentication | Class | Discouraged | 0.1705 | dense, sparse | dense: 0.538, sparse: 0.195 |



# Analysis to Review
# Summary
| CWE ID | CWE Name | Confidence | CWE Abstraction Level | CWE Vulnerability Mapping Label | CWE-Vulnerability Mapping Notes |
|---|---|---|---|---|---|
| CWE-79 | Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting') | 0.85 | Base | Allowed | Primary CWE |
| CWE-352 | Cross-Site Request Forgery (CSRF) | 0.65 | Compound | Allowed | Secondary Candidate |
| CWE-113 | Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Request/Response Splitting') | 0.55 | Variant | Allowed | Secondary Candidate |

## Evidence and Confidence

*   **Confidence Score:** 0.80
*   **Evidence Strength:** MEDIUM

- **Analysis and Justification:**  
  - *Explanation:* The vulnerability description highlights a **link injection** vulnerability in IBM Security Verify. An attacker can craft a malicious URL, and if a victim clicks on it, it could lead to **cross-site scripting**. This aligns with CWE-79 (Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')), where user-controllable input isn't properly neutralized before being used in a web page. The description also mentions potential impacts like cache poisoning and session hijacking. The 'Retriever Results' also lists CWE-79 as a potential match, and MITRE mapping guidance considers it ALLOWED.

  - *Relationship Analysis:* CWE-79 is a Base level CWE and has relationships with CWE-352 (Cross-Site Request Forgery), CWE-113 (Improper Neutralization of CRLF Sequences in HTTP Headers) and CWE-184 (Incomplete List of Disallowed Inputs). Given the stated impacts of cross-site scripting and session hijacking in the vulnerability description, these are potential secondary CWEs to consider, though the current evidence is not strong enough to confirm.

- **Confidence Score:**  
  - *Example:* Confidence: 0.85 (Evidence from vulnerability description and retriever results suggest CWE-79)

---

# CWE Examples from Database


## Known Examples for CWE-352: Cross-Site Request Forgery (CSRF)
### Observed Examples
- **CVE-2004-1703** [https://www.cve.org/CVERecord?id=CVE-2004-1703](https://www.cve.org/CVERecord?id=CVE-2004-1703): Add user accounts via a URL in an img tag
- **CVE-2004-1995** [https://www.cve.org/CVERecord?id=CVE-2004-1995](https://www.cve.org/CVERecord?id=CVE-2004-1995): Add user accounts via a URL in an img tag
- **CVE-2004-1967** [https://www.cve.org/CVERecord?id=CVE-2004-1967](https://www.cve.org/CVERecord?id=CVE-2004-1967): Arbitrary code execution by specifying the code in a crafted img tag or URL
- **CVE-2004-1842** [https://www.cve.org/CVERecord?id=CVE-2004-1842](https://www.cve.org/CVERecord?id=CVE-2004-1842): Gain administrative privileges via a URL in an img tag
- **CVE-2005-1947** [https://www.cve.org/CVERecord?id=CVE-2005-1947](https://www.cve.org/CVERecord?id=CVE-2005-1947): Delete a victim's information via a URL or an img tag
- **CVE-2005-2059** [https://www.cve.org/CVERecord?id=CVE-2005-2059](https://www.cve.org/CVERecord?id=CVE-2005-2059): Change another user's settings via a URL or an img tag
- **CVE-2005-1674** [https://www.cve.org/CVERecord?id=CVE-2005-1674](https://www.cve.org/CVERecord?id=CVE-2005-1674): Perform actions as administrator via a URL or an img tag
- **CVE-2009-3520** [https://www.cve.org/CVERecord?id=CVE-2009-3520](https://www.cve.org/CVERecord?id=CVE-2009-3520): modify password for the administrator
- **CVE-2009-3022** [https://www.cve.org/CVERecord?id=CVE-2009-3022](https://www.cve.org/CVERecord?id=CVE-2009-3022): CMS allows modification of configuration via CSRF attack against the administrator
- **CVE-2009-3759** [https://www.cve.org/CVERecord?id=CVE-2009-3759](https://www.cve.org/CVERecord?id=CVE-2009-3759): web interface allows password changes or stopping a virtual machine via CSRF


# Relevant CWE Specifications

## CWE-352: Cross-Site Request Forgery (CSRF)
**Abstraction:** Compound
**Status:** Stable

### Description
The web application does not, or can not, sufficiently verify whether a well-formed, valid, consistent request was intentionally provided by the user who submitted the request.

### Extended Description
When a web server is designed to receive a request from a client without any mechanism for verifying that it was intentionally sent, then it might be possible for an attacker to trick a client into making an unintentional request to the web server which will be treated as an authentic request. This can be done via a URL, image load, XMLHttpRequest, etc. and can result in exposure of data or unintended code execution.

### Alternative Terms
Session Riding
Cross Site Reference Forgery
XSRF

### Relationships
ChildOf -> CWE-345
ChildOf -> CWE-345
Requires -> CWE-346
Requires -> CWE-441
Requires -> CWE-642
Requires -> CWE-613
CanFollow -> CWE-1275

### Mapping Guidance
**Usage:** Allowed
**Rationale:** This is a well-known Composite of multiple weaknesses that must all occur simultaneously, although it is attack-oriented in nature.
**Comments:** While attack-oriented composites are supported in CWE, they have not been a focus of research. There is a chance that future research or CWE scope clarifications will change or deprecate them. Perform root-cause analysis to determine if other weaknesses allow CSRF attacks to occur, and map to those weaknesses. For example, predictable CSRF tokens might allow bypass of CSRF protection mechanisms; if this occurs, they might be better characterized as randomness/predictability weaknesses.
**Reasons:**
- Other


### Potential Mitigations
**Mitigation 1:**
- **Phase:** Architecture and Design
- **Strategy:** Libraries or Frameworks
- **Description:** 

Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.


For example, use anti-CSRF packages such as the OWASP CSRFGuard. [REF-330]


Another example is the ESAPI Session Management control, which includes a component for CSRF. [REF-45]


**Mitigation 2:**
- **Phase:** Implementation
- **Description:** Ensure that the application is free of cross-site scripting issues (CWE-79), because most CSRF defenses can be bypassed using attacker-controlled script.

**Mitigation 3:**
- **Phase:** Architecture and Design
- **Description:** Generate a unique nonce for each form, place the nonce into the form, and verify the nonce upon receipt of the form. Be sure that the nonce is not predictable (CWE-330). [REF-332]



### Additional Notes
**[Relationship]** 

There can be a close relationship between XSS and CSRF (CWE-352). An attacker might use CSRF in order to trick the victim into submitting requests to the server in which the requests contain an XSS payload. A well-known example of this was the Samy worm on MySpace [REF-956]. The worm used XSS to insert malicious HTML sequences into a user's profile and add the attacker as a MySpace friend. MySpace friends of that victim would then execute the payload to modify their own profiles, causing the worm to propagate exponentially. Since the victims did not intentionally insert the malicious script themselves, CSRF was a root cause.


**[Theoretical]** 

The CSRF topology is multi-channel:


  - Attacker (as outsider) to intermediary (as user). The interaction point is either an external or internal channel.

  - Intermediary (as user) to server (as victim). The activation point is an internal channel.





### Observed Examples
- **CVE-2004-1703:** Add user accounts via a URL in an img tag
- **CVE-2004-1995:** Add user accounts via a URL in an img tag
- **CVE-2004-1967:** Arbitrary code execution by specifying the code in a crafted img tag or URL



## CWE-184: Incomplete List of Disallowed Inputs
**Abstraction:** Base
**Status:** Draft

### Description
The product implements a protection mechanism that relies on a list of inputs (or properties of inputs) that are not allowed by policy or otherwise require other action to neutralize before additional processing takes place, but the list is incomplete.

### Extended Description
Not provided

### Alternative Terms
Denylist / Deny List: This is used by CWE and CAPEC instead of other commonly-used terms. Its counterpart is allowlist.
Blocklist / Block List: This is often used by security tools such as firewalls, email or web gateways, proxies, etc.
Blacklist / Black List: This term is frequently used, but usage has been declining as organizations have started to adopt other terms.

### Relationships
ChildOf -> CWE-693
ChildOf -> CWE-1023
CanPrecede -> CWE-79
CanPrecede -> CWE-78
CanPrecede -> CWE-434
CanPrecede -> CWE-98
ParentOf -> CWE-692

### Mapping Guidance
**Usage:** Allowed
**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.
**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.
**Reasons:**
- Acceptable-Use


### Potential Mitigations
**Mitigation 1:**
- **Phase:** Implementation
- **Strategy:** Input Validation
- **Description:** Do not rely exclusively on detecting disallowed inputs. There are too many variants to encode a character, especially when different environments are used, so there is a high likelihood of missing some variants. Only use detection of disallowed inputs as a mechanism for detecting suspicious activity. Ensure that you are using other protection mechanisms that only identify "good" input - such as lists of allowed inputs - and ensure that you are properly encoding your outputs.



### Additional Notes
**[Relationship]** 

Multiple interpretation errors can indirectly introduce inputs that should be disallowed. For example, a list of dangerous shell metacharacters might not include a metacharacter that only has meaning in one particular shell, not all of them; or a check for XSS manipulations might ignore an unusual construct that is supported by one web browser, but not others.




### Observed Examples
- **CVE-2024-4315:** Chain: API for text generation using Large Language Models (LLMs) does not include the "\" Windows folder separator in its denylist (CWE-184) when attempting to prevent Local File Inclusion via path traversal (CWE-22), allowing deletion of arbitrary files on Windows systems.
- **CVE-2008-2309:** product uses a denylist to identify potentially dangerous content, allowing attacker to bypass a warning
- **CVE-2005-2782:** PHP remote file inclusion in web application that filters "http" and "https" URLs, but not "ftp".



## CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')
**Abstraction:** Base
**Status:** Stable

### Description
The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.

### Extended Description


Cross-site scripting (XSS) vulnerabilities occur when:


  1. Untrusted data enters a web application, typically from a web request.

  1. The web application dynamically generates a web page that contains this untrusted data.

  1. During page generation, the application does not prevent the data from containing content that is executable by a web browser, such as JavaScript, HTML tags, HTML attributes, mouse events, Flash, ActiveX, etc.

  1. A victim visits the generated web page through a web browser, which contains malicious script that was injected using the untrusted data.

  1. Since the script comes from a web page that was sent by the web server, the victim's web browser executes the malicious script in the context of the web server's domain.

  1. This effectively violates the intention of the web browser's same-origin policy, which states that scripts in one domain should not be able to access resources or run code in a different domain.

There are three main kinds of XSS:

  -  **Type 1: Reflected XSS (or Non-Persistent)**  - The server reads data directly from the HTTP request and reflects it back in the HTTP response. Reflected XSS exploits occur when an attacker causes a victim to supply dangerous content to a vulnerable web application, which is then reflected back to the victim and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or e-mailed directly to the victim. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces a victim to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the victim, the content is executed by the victim's browser.

  -  **Type 2: Stored XSS (or Persistent)**  - The application stores dangerous data in a database, message forum, visitor log, or other trusted data store. At a later time, the dangerous data is subsequently read back into the application and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user. For example, the attacker might inject XSS into a log message, which might not be handled properly when an administrator views the logs. 

  -  **Type 0: DOM-Based XSS**  - In DOM-based XSS, the client performs the injection of XSS into the page; in the other types, the server performs the injection. DOM-based XSS generally involves server-controlled, trusted script that is sent to the client, such as Javascript that performs sanity checks on a form before the user submits it. If the server-supplied script processes user-supplied data and then injects it back into the web page (such as with dynamic HTML), then DOM-based XSS is possible. 

Once the malicious script is injected, the attacker can perform a variety of malicious activities. The attacker could transfer private information, such as cookies that may include session information, from the victim's machine to the attacker. The attacker could send malicious requests to a web site on behalf of the victim, which could be especially dangerous to the site if the victim has administrator privileges to manage that site. Phishing attacks could be used to emulate trusted web sites and trick the victim into entering a password, allowing the attacker to compromise the victim's account on that web site. Finally, the script could exploit a vulnerability in the web browser itself possibly taking over the victim's machine, sometimes referred to as "drive-by hacking."

In many cases, the attack can be launched without the victim even being aware of it. Even with careful users, attackers frequently use a variety of methods to encode the malicious portion of the attack, such as URL encoding or Unicode, so the request looks less suspicious.


### Alternative Terms
XSS: A common abbreviation for Cross-Site Scripting.
HTML Injection: Used as a synonym of stored (Type 2) XSS.
CSS: In the early years after initial discovery of XSS, "CSS" was a commonly-used acronym. However, this would cause confusion with "Cascading Style Sheets," so usage of this acronym has declined significantly.

### Relationships
ChildOf -> CWE-74
ChildOf -> CWE-74
CanPrecede -> CWE-494
PeerOf -> CWE-352
CanFollow -> CWE-113
CanFollow -> CWE-184
ParentOf -> CWE-80
ParentOf -> CWE-81
ParentOf -> CWE-83
ParentOf -> CWE-84
ParentOf -> CWE-85
ParentOf -> CWE-86
ParentOf -> CWE-87

### Mapping Guidance
**Usage:** Allowed
**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.
**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.
**Reasons:**
- Acceptable-Use


### Potential Mitigations
**Mitigation 1:**
- **Phase:** Architecture and Design
- **Strategy:** Libraries or Frameworks
- **Description:** 

Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.


Examples of libraries and frameworks that make it easier to generate properly encoded output include Microsoft's Anti-XSS library, the OWASP ESAPI Encoding module, and Apache Wicket.


**Mitigation 2:**
- **Phase:** Implementation, Architecture and Design
- **Description:** 

Understand the context in which your data will be used and the encoding that will be expected. This is especially important when transmitting data between different components, or when generating outputs that can contain multiple encodings at the same time, such as web pages or multi-part mail messages. Study all expected communication protocols and data representations to determine the required encoding strategies.


For any data that will be output to another web page, especially any data that was received from external inputs, use the appropriate encoding on all non-alphanumeric characters.


Parts of the same output document may require different encodings, which will vary depending on whether the output is in the:


  - HTML body

  - Element attributes (such as src="XYZ")

  - URIs

  - JavaScript sections

  - Cascading Style Sheets and style property

etc. Note that HTML Entity Encoding is only appropriate for the HTML body.

Consult the XSS Prevention Cheat Sheet [REF-724] for more details on the types of encoding and escaping that are needed.


**Mitigation 3:**
- **Phase:** Architecture and Design, Implementation
- **Effectiveness:** Limited
- **Strategy:** Attack Surface Reduction
- **Description:** Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, filenames, databases, and any external systems that provide data to the application. Remember that such inputs may be obtained indirectly through API calls.



### Additional Notes
**[Relationship]** 

There can be a close relationship between XSS and CSRF (CWE-352). An attacker might use CSRF in order to trick the victim into submitting requests to the server in which the requests contain an XSS payload. A well-known example of this was the Samy worm on MySpace [REF-956]. The worm used XSS to insert malicious HTML sequences into a user's profile and add the attacker as a MySpace friend. MySpace friends of that victim would then execute the payload to modify their own profiles, causing the worm to propagate exponentially. Since the victims did not intentionally insert the malicious script themselves, CSRF was a root cause.


**[Applicable Platform]** 

XSS flaws are very common in web applications, since they require a great deal of developer discipline to avoid them.




### Observed Examples
- **CVE-2021-25926:** Python Library Manager did not sufficiently neutralize a user-supplied search term, allowing reflected XSS.
- **CVE-2021-25963:** Python-based e-commerce platform did not escape returned content on error pages, allowing for reflected Cross-Site Scripting attacks.
- **CVE-2021-1879:** Universal XSS in mobile operating system, as exploited in the wild per CISA KEV.



## CWE-113: Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Request/Response Splitting')
**Abstraction:** Variant
**Status:** Incomplete

### Description
The product receives data from an HTTP agent/component (e.g., web server, proxy, browser, etc.), but it does not neutralize or incorrectly neutralizes CR and LF characters before the data is included in outgoing HTTP headers.

### Extended Description


 HTTP agents or components may include a web server, load balancer, reverse proxy, web caching proxy, application firewall, web browser, etc. Regardless of the role, they are expected to maintain coherent, consistent HTTP communication state across all components. However, including unexpected data in an HTTP header allows an attacker to specify the entirety of the HTTP message that is rendered by the client HTTP agent (e.g., web browser) or back-end HTTP agent (e.g., web server), whether the message is part of a request or a response. 


When an HTTP request contains unexpected CR and LF characters, the server may respond with an output stream that is interpreted as "splitting" the stream into two different HTTP messages instead of one. CR is carriage return, also given by %0d or \r, and LF is line feed, also given by %0a or \n.


In addition to CR and LF characters, other valid/RFC compliant special characters and unique character encodings can be utilized, such as HT (horizontal tab, also given by %09 or \t) and SP (space, also given as + sign or %20).


These types of unvalidated and unexpected data in HTTP message headers allow an attacker to control the second "split" message to mount attacks such as server-side request forgery, cross-site scripting, and cache poisoning attacks.


HTTP response splitting weaknesses may be present when:


  1. Data enters a web application through an untrusted source, most frequently an HTTP request.

  1. The data is included in an HTTP response header sent to a web user without neutralizing malicious characters that can be interpreted as separator characters for headers.



### Alternative Terms
HTTP Request Splitting
HTTP Response Splitting

### Relationships
ChildOf -> CWE-93
CanPrecede -> CWE-79
ChildOf -> CWE-20
ChildOf -> CWE-436

### Mapping Guidance
**Usage:** Allowed
**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.
**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.
**Reasons:**
- Acceptable-Use


### Potential Mitigations
**Mitigation 1:**
- **Phase:** Implementation
- **Strategy:** Input Validation
- **Description:** Construct HTTP headers very carefully, avoiding the use of non-validated input data.

**Mitigation 2:**
- **Phase:** Implementation
- **Strategy:** Input Validation
- **Description:** 

Assume all input is malicious. Use an "accept known good" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. If an input does not strictly conform to specifications, reject it or transform it into something that conforms.


When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, "boat" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as "red" or "blue."


Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.


**Mitigation 3:**
- **Phase:** Implementation
- **Strategy:** Output Encoding
- **Description:** Use and specify an output encoding that can be handled by the downstream component that is reading the output. Common encodings include ISO-8859-1, UTF-7, and UTF-8. When an encoding is not specified, a downstream component may choose a different encoding, either by assuming a default encoding or automatically inferring which encoding is being used, which can be erroneous. When the encodings are inconsistent, the downstream component might treat some character or byte sequences as special, even if they are not special in the original encoding. Attackers might then be able to exploit this discrepancy and conduct injection attacks; they even might be able to bypass protection mechanisms that assume the original encoding is also being used by the downstream component.




### Observed Examples
- **CVE-2020-15811:** Chain: Proxy uses a substring search instead of parsing the Transfer-Encoding header (CWE-697), allowing request splitting (CWE-113) and cache poisoning
- **CVE-2021-41084:** Scala-based HTTP interface allows request splitting and response splitting through header names, header values, status reasons, and URIs
- **CVE-2018-12116:** Javascript-based framework allows request splitting through a path option of an HTTP request

