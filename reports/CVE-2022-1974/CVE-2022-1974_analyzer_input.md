# Vulnerability Information: CVE-2022-1974

## Vulnerability Description
A **use-after-free** flaw was found in the Linux kernels NFC core functionality due to a **race condition** between kobject creation and delete. This vulnerability allows a local attacker with CAP_NET_ADMIN privilege to leak kernel information.

### Vulnerability Description Key Phrases
- **rootcause:** **race condition**
- **weakness:** **use-after-free**
- **impact:** information leak
- **attacker:** local attacker with CAP_NET_ADMIN privilege
- **product:** Linux kernels
- **component:** NFC core functionality

## CVE Reference Links Content Summary
Based on the provided content, here's an analysis regarding CVE-2022-1974:

**1. Verification of CVE Relevance:**

The content describes a race condition vulnerability in the Linux kernel's NFC (Near Field Communication) subsystem. Although no CVE number is specified in the commit message, the description does detail a race condition vulnerability related to the `device_is_registered()` function and the `kobject_del()` function.
The commit message states:
"The device_is_registered() in nfc core is used to check whether nfc device is registered in netlink related functions such as nfc_fw_download(), nfc_dev_up() and so on. Although device_is_registered() is protected by device_lock, there is still a race condition between device_del() and device_is_registered(). The root cause is that kobject_del() in device_del() is not protected by device_lock."

Given the context of the commit, it's related to the fix for the race condition described by CVE-2022-1974.

**2. Vulnerability Details:**

*   **Root Cause:** The race condition exists because the `device_is_registered()` function, used to check if an NFC device is registered, is not properly synchronized with the `kobject_del()` function called during device unregistration (`device_del()`). While a lock (`device_lock`) protects the access to `device_is_registered()`, `kobject_del()` is not protected by this lock.
*   **Weakness/Vulnerability:** The core issue is a time-of-check to time-of-use (TOCTOU) race condition. The `device_is_registered()` function checks a state variable (`state_in_sysfs`), but this variable can change asynchronously by `kobject_del()` before the check result is used by the calling function.
*   **Impact of Exploitation:** The vulnerability could lead to use-after-free or double-free scenarios, potentially causing a kernel crash or other unpredictable behavior. This could lead to a denial-of-service (DoS) on the affected system.  Although, not explicitly mentioned in the provided content, use-after-free scenarios can be leveraged for arbitrary code execution.
*   **Attack Vectors:** The race condition is triggered by a concurrent unregistration of the NFC device (via `device_del()`) while another thread is attempting to use the device via netlink related operations.
*   **Required Attacker Capabilities/Position:**
    *   The attacker must be able to trigger the device unregistration and a device access operation concurrently. This would require local access and the ability to interact with the NFC subsystem.

**3. Technical Details:**

*   The commit message explains the race condition clearly with a timeline:
    ```
    (cleanup task)         |     (netlink task)
                           |
    nfc_unregister_device     | nfc_fw_download
     device_del               |  device_lock
      ...                     |   if (!device_is_registered)//(1)
      kobject_del//(2)        |   ...
     ...                      |  device_unlock
    ```
    -   The `device_del` is called to remove the device, which eventually calls `kobject_del`.
    -   A separate netlink task might be calling a function that first acquires `device_lock` and then checks `device_is_registered`.
    -   The race condition occurs if (1) occurs before (2).  In this case, the check passes, but the device is then deleted, and any further access to the device will be invalid.

*   The fix replaces the usage of `device_is_registered()` with a boolean variable, which is correctly synchronized.
*   The relevant code changes are shown in the diff for `net/nfc/core.c`, replacing the call to `device_is_registered(&dev->dev)` with a check on `dev->shutting_down`.

**4. Additional Notes:**

*   The commit message also mentions the fix for an earlier commit `3e256b8` which added the NFC subsystem core.
*   The provided content gives sufficient technical detail to understand the vulnerability, and it appears to be more detailed than the CVE description that is listed as "PLACEHOLDER".

**Summary:**

The provided content describes a race condition vulnerability in the Linux kernel's NFC subsystem. The vulnerability stems from unsynchronized access to the device state during device removal, which can lead to use-after-free issues. The fix replaces the vulnerable `device_is_registered()` check with a synchronized boolean flag to prevent the race.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage | Combined Score | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|---------------|------------|-------------------|
| 1 | CWE-416 | Use After Free | Variant | Allowed | 0.7496 | dense, sparse, graph | dense: 0.616, sparse: 0.300, graph: 0.928 |
| 2 | CWE-367 | Time-of-check Time-of-use (TOCTOU) Race Condition | Base | Allowed | 0.7391 | dense, sparse, graph | dense: 0.587, sparse: 0.391, graph: 0.620 |
| 3 | CWE-415 | Double Free | Variant | Allowed | 0.7101 | dense, sparse, graph | dense: 0.580, sparse: 0.328, graph: 0.815 |
| 4 | CWE-366 | Race Condition within a Thread | Base | Allowed | 0.6905 | dense, sparse, graph | dense: 0.607, sparse: 0.287, graph: 0.622 |
| 5 | CWE-908 | Use of Uninitialized Resource | Base | Allowed | 0.6748 | dense, sparse, graph | dense: 0.604, sparse: 0.296, graph: 0.569 |
| 6 | CWE-364 | Signal Handler Race Condition | Base | Allowed | 0.5193 | sparse, graph | sparse: 0.283, graph: 1.000 |
| 7 | CWE-362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | Allowed-with-Review | 0.4522 | dense, sparse, graph | dense: 0.650, sparse: 0.373, graph: 0.646 |
| 8 | CWE-476 | NULL Pointer Dereference | Base | Allowed | 0.4456 | dense, sparse | dense: 0.580, sparse: 0.272 |
| 9 | CWE-401 | Missing Release of Memory after Effective Lifetime | Variant | Allowed | 0.4403 | dense, sparse | dense: 0.620, sparse: 0.292 |
| 10 | CWE-193 | Off-by-one Error | Base | Allowed | 0.3772 | dense, sparse | dense: 0.572, sparse: 0.159 |

