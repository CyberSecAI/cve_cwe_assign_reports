# Critic Input for CVE-2022-1237



# Original Analyzer Input
## Vulnerability Description
**Improper Validation of Array Index** in GitHub repository radareorg/radare2 prior to 5.6.8. This vulnerability is **heap overflow** and may be exploitable. For more general description of heap buffer overflow, see [CWE](https//cwe.mitre.org/data/definitions/122.html).

### Vulnerability Description Key Phrases
- **rootcause:** **Improper Validation of Array Index**
- **weakness:** **heap overflow**
- **product:** radareorg/radare2
- **version:** prior to 5.6.8

## CVE Reference Links Content Summary
Based on the provided content, here's an analysis of the vulnerability addressed by the commit, which seems to be related to CVE-2022-1237.

**Root cause of vulnerability:**
The vulnerability is an out-of-bounds read in the NE (New Executable) binary parser of radare2. Specifically, the issue occurs when parsing relocation information within NE files. The code attempts to read data based on offsets and sizes specified in the NE header. However, these offsets and sizes can be manipulated, leading to reads beyond the allocated buffer.

**Weaknesses/vulnerabilities present:**

*   **Out-of-bounds read:** The core issue is that the code reads data from a buffer using offsets and sizes derived from the NE header without proper validation.
    *   Specifically, a loop condition `while (off < start + length * sizeof (NE_image_reloc_item) && off < buf_size)` attempts to prevent out of bounds reads but is not sufficient to prevent all instances, as seen by the patch.
*   **Incorrect Size Calculation:** The code calculates the size of the segment entries based on `bin->ne_header->SegCount * sizeof (NE_image_segment_entry)` which can overflow on large crafted inputs. Later it is corrected by checking against `r_buf_size(bin->buf)`.

**Impact of exploitation:**

*   **Segmentation fault (segfault):** The out-of-bounds read leads to the program attempting to access memory it's not allowed to, resulting in a crash (segfault). This is mentioned in the commit message "Fix oobread segfaults in the NE bin parser". This can lead to denial of service (DoS) and possibly further exploitation (if it can lead to other issues).

**Attack vectors:**

*   **Crafted NE files:** An attacker can craft a malicious NE file with manipulated header values (specifically `SegCount`, `ModRefs`, offsets and sizes for relocation) that trigger the out-of-bounds read.
*   **File Analysis with radare2:** The attacker needs to entice the user to load the malicious NE file with radare2 for analysis.

**Required attacker capabilities/position:**

*   The attacker needs to be able to create a crafted NE file.
*   The attacker needs to be able to get the victim to open the crafted file using the vulnerable version of radare2.

**Additional Notes**
*   The commit message mentions that the issue was reported by `@Han0nly` via huntr.dev, and the bounty ID `ad3c9c4c-76e7-40c8-bd4a-c095acd8bb40`. This confirms that it is a vulnerability.
*   The patch fixes the issue by adding bounds checks to ensure that reads do not go beyond the allocated buffer (as shown by the change in the code). There are other changes such as a change from `malloc` to `calloc` when allocating `modref` and adding size validation for `segment_entries` and `ModRefs` based on available buffer size.
*   The vulnerability is present in `libr/bin/format/ne/ne.c`
*   The fix is in the same file.

The provided information gives more specific details on the vulnerability than a typical CVE description.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage | Combined Score | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|---------------|------------|-------------------|
| 1 | CWE-190 | Integer Overflow or Wraparound | Base | Allowed | 0.8155 | dense, sparse, graph | dense: 0.559, sparse: 0.374, graph: 0.900 |
| 2 | CWE-476 | NULL Pointer Dereference | Base | Allowed | 0.7504 | dense, sparse, graph | dense: 0.526, sparse: 0.407, graph: 0.712 |
| 3 | CWE-129 | Improper Validation of Array Index | Variant | Allowed | 0.7281 | dense, sparse, graph | dense: 0.601, sparse: 0.417, graph: 0.697 |
| 4 | CWE-126 | Buffer Over-read | Variant | Allowed | 0.6725 | dense, sparse, graph | dense: 0.571, sparse: 0.348, graph: 0.681 |
| 5 | CWE-130 | Improper Handling of Length Parameter Inconsistency | Base | Allowed | 0.6637 | dense, sparse, graph | dense: 0.535, sparse: 0.345, graph: 0.555 |
| 6 | CWE-124 | Buffer Underwrite ('Buffer Underflow') | Base | Allowed | 0.6543 | dense, sparse, graph | dense: 0.535, sparse: 0.329, graph: 0.556 |
| 7 | CWE-839 | Numeric Range Comparison Without Minimum Check | Base | Allowed | 0.5683 | sparse, graph | sparse: 0.369, graph: 1.000 |
| 8 | CWE-122 | Heap-based Buffer Overflow | Variant | Allowed | 0.4971 | dense, sparse | dense: 0.574, sparse: 0.439 |
| 9 | CWE-193 | Off-by-one Error | Base | Allowed | 0.4777 | dense, sparse | dense: 0.550, sparse: 0.354 |
| 10 | CWE-191 | Integer Underflow (Wrap or Wraparound) | Base | Allowed | 0.4682 | dense, sparse | dense: 0.528, sparse: 0.357 |



# Analysis to Review
# Summary
| CWE ID    | CWE Name                               | Confidence | CWE Abstraction Level | CWE Vulnerability Mapping Label | CWE-Vulnerability Mapping Notes |
| :--------- | :------------------------------------- | :--------- | :-------------------- | :------------------------------ | :------------------------------ |
| CWE-129     | Improper Validation of Array Index     | 0.90       | Variant               | Allowed                         | Primary CWE                     |
| CWE-125    | Out-of-bounds Read                     | 0.75       | Base                  | Allowed                         | Secondary Candidate             |
| CWE-122     | Heap-based Buffer Overflow             | 0.70       | Variant               | Allowed                         | Secondary Candidate             |
| CWE-1284     | Improper Validation of Quantity      | 0.60       | Base                  | Allowed                         | Secondary Candidate             |

## Evidence and Confidence

*   **Confidence Score:** 0.80
*   **Evidence Strength:** HIGH

- **Analysis and Justification:**  
  - *Explanation:* The vulnerability description highlights an "**Improper Validation of Array Index**" leading to a "**heap overflow**" in radare2. The CVE reference links content summary confirms that the root cause is an out-of-bounds read due to manipulated offsets and sizes in the NE header, without proper validation, which allows reads beyond the allocated buffer. CWE-129 (Improper Validation of Array Index) is a Variant level CWE and accurately captures the root cause. The retriever results list CWE-129 with a high score (0.7281) and it has an Allowed usage.
  
  - *Relationship Analysis:* CWE-129 has no direct relationships in the provided data. The description and evidence point towards the lack of validation as the primary issue, making CWE-129 the most fitting choice.

- **Confidence Score:**  
  - Confidence: 0.90 (High confidence due to explicit mention of "Improper Validation of Array Index" and confirmation from CVE reference details).

---
- **Analysis and Justification:**  
  - *Explanation:* The CVE reference content summary details an "out-of-bounds read" in the NE binary parser. This occurs because offsets and sizes from the NE header are used to read data, and these values aren't properly validated. This aligns with CWE-125 (Out-of-bounds Read), which describes reading data past the end or before the beginning of the intended buffer. While CWE-129 captures the root cause, CWE-125 describes the direct consequence of the vulnerability. The retriever results indicate CWE-125 as a relevant candidate.
  
  - *Relationship Analysis:* CWE-125 is a child of CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer). This relationship is consistent with the nature of the vulnerability, where the read operation goes beyond the intended buffer boundaries due to a lack of validation.

- **Confidence Score:**  
  - Confidence: 0.75 (Good confidence, as out-of-bounds read is a direct consequence of the vulnerability.)

---
- **Analysis and Justification:**  
  - *Explanation:* The vulnerability description mentions "**heap overflow**" which is confirmed with the CVE reference links. This occurs in the heap portion of memory. The vulnerability is a buffer overflow due to improper validation. This maps well to CWE-122 (Heap-based Buffer Overflow).
  
  - *Relationship Analysis:* CWE-122 is a variant of CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer).

- **Confidence Score:**  
  - Confidence: 0.70 (Good confidence because the vulnerability leads to heap buffer overflow.)

---
- **Analysis and Justification:**  
  - *Explanation:* The vulnerability arises from manipulated header values, specifically offsets and sizes for relocation, indicating a potential issue with how the quantity (size) is validated. CWE-1284 (Improper Validation of Quantity) describes a situation where the product receives input that is expected to specify a quantity, but it does not validate or incorrectly validates that the quantity has the required properties.

  - *Relationship Analysis:* CWE-1284 is a child of CWE-20 (Improper Input Validation).

- **Confidence Score:**
  - Confidence: 0.60 (Fair confidence because quantity is not validated, which leads to an overflow.)

# CWE Examples from Database


## Known Examples for CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer
### Observed Examples
- **CVE-2021-22991** [https://www.cve.org/CVERecord?id=CVE-2021-22991](https://www.cve.org/CVERecord?id=CVE-2021-22991): Incorrect URI normalization in application traffic product leads to buffer overflow, as exploited in the wild per CISA KEV.
- **CVE-2020-29557** [https://www.cve.org/CVERecord?id=CVE-2020-29557](https://www.cve.org/CVERecord?id=CVE-2020-29557): Buffer overflow in Wi-Fi router web interface, as exploited in the wild per CISA KEV.
- **CVE-2009-2550** [https://www.cve.org/CVERecord?id=CVE-2009-2550](https://www.cve.org/CVERecord?id=CVE-2009-2550): Classic stack-based buffer overflow in media player using a long entry in a playlist
- **CVE-2009-2403** [https://www.cve.org/CVERecord?id=CVE-2009-2403](https://www.cve.org/CVERecord?id=CVE-2009-2403): Heap-based buffer overflow in media player using a long entry in a playlist
- **CVE-2009-0689** [https://www.cve.org/CVERecord?id=CVE-2009-0689](https://www.cve.org/CVERecord?id=CVE-2009-0689): large precision value in a format string triggers overflow
- **CVE-2009-0690** [https://www.cve.org/CVERecord?id=CVE-2009-0690](https://www.cve.org/CVERecord?id=CVE-2009-0690): negative offset value leads to out-of-bounds read
- **CVE-2009-1532** [https://www.cve.org/CVERecord?id=CVE-2009-1532](https://www.cve.org/CVERecord?id=CVE-2009-1532): malformed inputs cause accesses of uninitialized or previously-deleted objects, leading to memory corruption
- **CVE-2009-1528** [https://www.cve.org/CVERecord?id=CVE-2009-1528](https://www.cve.org/CVERecord?id=CVE-2009-1528): chain: lack of synchronization leads to memory corruption
- **CVE-2021-29529** [https://www.cve.org/CVERecord?id=CVE-2021-29529](https://www.cve.org/CVERecord?id=CVE-2021-29529): Chain: machine-learning product can have a heap-based buffer overflow (CWE-122) when some integer-oriented bounds are calculated by using ceiling() and floor() on floating point values (CWE-1339)
- **CVE-2009-0558** [https://www.cve.org/CVERecord?id=CVE-2009-0558](https://www.cve.org/CVERecord?id=CVE-2009-0558): attacker-controlled array index leads to code execution


# Relevant CWE Specifications

## CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer
**Abstraction:** Class
**Status:** Stable

### Description
The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.

### Extended Description
Not provided

### Alternative Terms
Buffer Overflow: This term has many different meanings to different audiences. From a CWE mapping perspective, this term should be avoided where possible. Some researchers, developers, and tools intend for it to mean "write past the end of a buffer," whereas others use the same term to mean "any read or write outside the boundaries of a buffer, whether before the beginning of the buffer or after the end of the buffer." Others could mean "any action after the end of a buffer, whether it is a read or write." Since the term is commonly used for exploitation and for vulnerabilities, it further confuses things.
buffer overrun: Some prominent vendors and researchers use the term "buffer overrun," but most people use "buffer overflow." See the alternate term for "buffer overflow" for context.
memory safety: Generally used for techniques that avoid weaknesses related to memory access, such as those identified by CWE-119 and its descendants. However, the term is not formal, and there is likely disagreement between practitioners as to which weaknesses are implicitly covered by the "memory safety" term.

### Relationships
ChildOf -> CWE-118
ChildOf -> CWE-20
ParentOf -> CWE-120
ParentOf -> CWE-123
ParentOf -> CWE-125
CanFollow -> CWE-1257
CanFollow -> CWE-1260
CanFollow -> CWE-128
CanFollow -> CWE-129
ParentOf -> CWE-130
CanFollow -> CWE-131
CanFollow -> CWE-1339
CanFollow -> CWE-190
CanFollow -> CWE-193
CanFollow -> CWE-195
CanFollow -> CWE-20
ParentOf -> CWE-466
ParentOf -> CWE-786
ParentOf -> CWE-787
ParentOf -> CWE-788
ParentOf -> CWE-805
ParentOf -> CWE-822
ParentOf -> CWE-823
ParentOf -> CWE-824
ParentOf -> CWE-825
CanFollow -> CWE-839
CanFollow -> CWE-843

### Mapping Guidance
**Usage:** Discouraged
**Rationale:** CWE-119 is commonly misused in low-information vulnerability reports when lower-level CWEs could be used instead, or when more details about the vulnerability are available.
**Comments:** Look at CWE-119's children and consider mapping to CWEs such as CWE-787: Out-of-bounds Write, CWE-125: Out-of-bounds Read, or others.
**Reasons:**
- Frequent Misuse


### Potential Mitigations
**Mitigation 1:**
- **Phase:** Requirements
- **Strategy:** Language Selection
- **Description:** 

Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.


For example, many languages that perform their own memory management, such as Java and Perl, are not subject to buffer overflows. Other languages, such as Ada and C#, typically provide overflow protection, but the protection can be disabled by the programmer.


Be wary that a language's interface to native code may still be subject to overflows, even if the language itself is theoretically safe.


**Mitigation 2:**
- **Phase:** Architecture and Design
- **Strategy:** Libraries or Frameworks
- **Description:** 

Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.


Examples include the Safe C String Library (SafeStr) by Messier and Viega [REF-57], and the Strsafe.h library from Microsoft [REF-56]. These libraries provide safer versions of overflow-prone string-handling functions.


**Mitigation 3:**
- **Phase:** Operation, Build and Compilation
- **Effectiveness:** Defense in Depth
- **Strategy:** Environment Hardening
- **Description:** 

Use automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking. 


 D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail. 




### Additional Notes
**[Applicable Platform]** 

It is possible in any programming languages without memory management support to attempt an operation outside of the bounds of a memory buffer, but the consequences will vary widely depending on the language, platform, and chip architecture.




### Observed Examples
- **CVE-2021-22991:** Incorrect URI normalization in application traffic product leads to buffer overflow, as exploited in the wild per CISA KEV.
- **CVE-2020-29557:** Buffer overflow in Wi-Fi router web interface, as exploited in the wild per CISA KEV.
- **CVE-2009-2550:** Classic stack-based buffer overflow in media player using a long entry in a playlist



## CWE-1284: Improper Validation of Specified Quantity in Input
**Abstraction:** Base
**Status:** Incomplete

### Description
The product receives input that is expected to specify a quantity (such as size or length), but it does not validate or incorrectly validates that the quantity has the required properties.

### Extended Description


Specified quantities include size, length, frequency, price, rate, number of operations, time, and others. Code may rely on specified quantities to allocate resources, perform calculations, control iteration, etc. When the quantity is not properly validated, then attackers can specify malicious quantities to cause excessive resource allocation, trigger unexpected failures, enable buffer overflows, etc.


### Alternative Terms
None

### Relationships
ChildOf -> CWE-20
ChildOf -> CWE-20
CanPrecede -> CWE-789
ParentOf -> CWE-606

### Mapping Guidance
**Usage:** Allowed
**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.
**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.
**Reasons:**
- Acceptable-Use


### Potential Mitigations
**Mitigation 1:**
- **Phase:** Implementation
- **Effectiveness:** High
- **Strategy:** Input Validation
- **Description:** 

Assume all input is malicious. Use an "accept known good" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.


When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, "boat" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as "red" or "blue."


Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.




### Additional Notes
**[Maintenance]** This entry is still under development and will continue to see updates and content improvements.



### Observed Examples
- **CVE-2022-21668:** Chain: Python library does not limit the resources used to process images that specify a very large number of bands (CWE-1284), leading to excessive memory consumption (CWE-789) or an integer overflow (CWE-190).
- **CVE-2008-1440:** lack of validation of length field leads to infinite loop
- **CVE-2008-2374:** lack of validation of string length fields allows memory consumption or buffer over-read



## CWE-122: Heap-based Buffer Overflow
**Abstraction:** Variant
**Status:** Draft

### Description
A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().

### Extended Description
Not provided

### Alternative Terms
None

### Relationships
ChildOf -> CWE-788
ChildOf -> CWE-787

### Mapping Guidance
**Usage:** Allowed
**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.
**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.
**Reasons:**
- Acceptable-Use


### Potential Mitigations
**Mitigation 1:**
- **Description:** Pre-design: Use a language or compiler that performs automatic bounds checking.

**Mitigation 2:**
- **Phase:** Architecture and Design
- **Description:** Use an abstraction library to abstract away risky APIs. Not a complete solution.

**Mitigation 3:**
- **Phase:** Operation, Build and Compilation
- **Effectiveness:** Defense in Depth
- **Strategy:** Environment Hardening
- **Description:** 

Use automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking. 


 D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail. 




### Additional Notes
**[Relationship]** Heap-based buffer overflows are usually just as dangerous as stack-based buffer overflows.



### Observed Examples
- **CVE-2021-43537:** Chain: in a web browser, an unsigned 64-bit integer is forcibly cast to a 32-bit integer (CWE-681) and potentially leading to an integer overflow (CWE-190). If an integer overflow occurs, this can cause heap memory corruption (CWE-122)
- **CVE-2007-4268:** Chain: integer signedness error (CWE-195) passes signed comparison, leading to heap overflow (CWE-122)
- **CVE-2009-2523:** Chain: product does not handle when an input string is not NULL terminated (CWE-170), leading to buffer over-read (CWE-125) or heap-based buffer overflow (CWE-122).



## CWE-20: Improper Input Validation
**Abstraction:** Class
**Status:** Stable

### Description
The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.

### Extended Description


Input validation is a frequently-used technique for checking potentially dangerous inputs in order to ensure that the inputs are safe for processing within the code, or when communicating with other components. When software does not validate input properly, an attacker is able to craft the input in a form that is not expected by the rest of the application. This will lead to parts of the system receiving unintended input, which may result in altered control flow, arbitrary control of a resource, or arbitrary code execution.


Input validation is not the only technique for processing input, however. Other techniques attempt to transform potentially-dangerous input into something safe, such as filtering (CWE-790) - which attempts to remove dangerous inputs - or encoding/escaping (CWE-116), which attempts to ensure that the input is not misinterpreted when it is included in output to another component. Other techniques exist as well (see CWE-138 for more examples.)


Input validation can be applied to:


  - raw data - strings, numbers, parameters, file contents, etc.

  - metadata - information about the raw data, such as headers or size

Data can be simple or structured. Structured data can be composed of many nested layers, composed of combinations of metadata and raw data, with other simple or structured data.

Many properties of raw data or metadata may need to be validated upon entry into the code, such as:


  - specified quantities such as size, length, frequency, price, rate, number of operations, time, etc.

  - implied or derived quantities, such as the actual size of a file instead of a specified size

  - indexes, offsets, or positions into more complex data structures

  - symbolic keys or other elements into hash tables, associative arrays, etc.

  - well-formedness, i.e. syntactic correctness - compliance with expected syntax 

  - lexical token correctness - compliance with rules for what is treated as a token

  - specified or derived type - the actual type of the input (or what the input appears to be)

  - consistency - between individual data elements, between raw data and metadata, between references, etc.

  - conformance to domain-specific rules, e.g. business logic 

  - equivalence - ensuring that equivalent inputs are treated the same

  - authenticity, ownership, or other attestations about the input, e.g. a cryptographic signature to prove the source of the data

Implied or derived properties of data must often be calculated or inferred by the code itself. Errors in deriving properties may be considered a contributing factor to improper input validation. 

Note that "input validation" has very different meanings to different people, or within different classification schemes. Caution must be used when referencing this CWE entry or mapping to it. For example, some weaknesses might involve inadvertently giving control to an attacker over an input when they should not be able to provide an input at all, but sometimes this is referred to as input validation.


Finally, it is important to emphasize that the distinctions between input validation and output escaping are often blurred, and developers must be careful to understand the difference, including how input validation is not always sufficient to prevent vulnerabilities, especially when less stringent data types must be supported, such as free-form text. Consider a SQL injection scenario in which a person's last name is inserted into a query. The name "O'Reilly" would likely pass the validation step since it is a common last name in the English language. However, this valid name cannot be directly inserted into the database because it contains the "'" apostrophe character, which would need to be escaped or otherwise transformed. In this case, removing the apostrophe might reduce the risk of SQL injection, but it would produce incorrect behavior because the wrong name would be recorded.


### Alternative Terms
None

### Relationships
ChildOf -> CWE-707
PeerOf -> CWE-345
CanPrecede -> CWE-22
CanPrecede -> CWE-41
CanPrecede -> CWE-74
CanPrecede -> CWE-119
CanPrecede -> CWE-770
ParentOf -> CWE-102
ParentOf -> CWE-103
ParentOf -> CWE-104
ParentOf -> CWE-105
ParentOf -> CWE-106
ParentOf -> CWE-107
ParentOf -> CWE-108
ParentOf -> CWE-109
ParentOf -> CWE-110
ParentOf -> CWE-111
ParentOf -> CWE-112
ParentOf -> CWE-113
ParentOf -> CWE-114
ParentOf -> CWE-117
ParentOf -> CWE-1173
ParentOf -> CWE-119
ParentOf -> CWE-120
ParentOf -> CWE-1284
ParentOf -> CWE-1285
ParentOf -> CWE-1286
ParentOf -> CWE-1287
ParentOf -> CWE-1288
ParentOf -> CWE-1289
ParentOf -> CWE-129
ParentOf -> CWE-134
ParentOf -> CWE-15
ParentOf -> CWE-170
ParentOf -> CWE-179
ParentOf -> CWE-190
ParentOf -> CWE-466
ParentOf -> CWE-470
ParentOf -> CWE-622
ParentOf -> CWE-73
ParentOf -> CWE-785

### Mapping Guidance
**Usage:** Discouraged
**Rationale:** CWE-20 is commonly misused in low-information vulnerability reports when lower-level CWEs could be used instead, or when more details about the vulnerability are available [REF-1287]. It is not useful for trend analysis. It is also a level-1 Class (i.e., a child of a Pillar).
**Comments:** Consider lower-level children such as Improper Use of Validation Framework (CWE-1173) or improper validation involving specific types or properties of input such as Specified Quantity (CWE-1284); Specified Index, Position, or Offset (CWE-1285); Syntactic Correctness (CWE-1286); Specified Type (CWE-1287); Consistency within Input (CWE-1288); or Unsafe Equivalence (CWE-1289).
**Reasons:**
- Frequent Misuse
**Suggested Alternatives:**
- CWE-1284: Specified Quantity
- CWE-1285: Specified Index, Position, or Offset
- CWE-1286: Syntactic Correctness
- CWE-1287: Specified Type
- CWE-1288: Consistency within Input
- CWE-1289: Unsafe Equivalence
- CWE-116: Improper Encoding or Escaping of Output


### Potential Mitigations
**Mitigation 1:**
- **Phase:** Architecture and Design
- **Strategy:** Attack Surface Reduction
- **Description:** Consider using language-theoretic security (LangSec) techniques that characterize inputs using a formal language and build "recognizers" for that language. This effectively requires parsing to be a distinct layer that effectively enforces a boundary between raw input and internal data representations, instead of allowing parser code to be scattered throughout the program, where it could be subject to errors or inconsistencies that create weaknesses. [REF-1109] [REF-1110] [REF-1111]

**Mitigation 2:**
- **Phase:** Architecture and Design
- **Strategy:** Libraries or Frameworks
- **Description:** Use an input validation framework such as Struts or the OWASP ESAPI Validation API. Note that using a framework does not automatically address all input validation problems; be mindful of weaknesses that could arise from misusing the framework itself (CWE-1173).

**Mitigation 3:**
- **Phase:** Architecture and Design, Implementation
- **Strategy:** Attack Surface Reduction
- **Description:** Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, filenames, databases, and any external systems that provide data to the application. Remember that such inputs may be obtained indirectly through API calls.



### Additional Notes
**[Relationship]** 

CWE-116 and CWE-20 have a close association because, depending on the nature of the structured message, proper input validation can indirectly prevent special characters from changing the meaning of a structured message. For example, by validating that a numeric ID field should only contain the 0-9 characters, the programmer effectively prevents injection attacks.


**[Maintenance]** As of 2020, this entry is used more often than preferred, and it is a source of frequent confusion. It is being actively modified for CWE 4.1 and subsequent versions.

**[Maintenance]** Concepts such as validation, data transformation, and neutralization are being refined, so relationships between CWE-20 and other entries such as CWE-707 may change in future versions, along with an update to the Vulnerability Theory document.

**[Maintenance]** Input validation - whether missing or incorrect - is such an essential and widespread part of secure development that it is implicit in many different weaknesses. Traditionally, problems such as buffer overflows and XSS have been classified as input validation problems by many security professionals. However, input validation is not necessarily the only protection mechanism available for avoiding such problems, and in some cases it is not even sufficient. The CWE team has begun capturing these subtleties in chains within the Research Concepts view (CWE-1000), but more work is needed.

**[Terminology]** 

The "input validation" term is extremely common, but it is used in many different ways. In some cases its usage can obscure the real underlying weakness or otherwise hide chaining and composite relationships.


Some people use "input validation" as a general term that covers many different neutralization techniques for ensuring that input is appropriate, such as filtering, canonicalization, and escaping. Others use the term in a more narrow context to simply mean "checking if an input conforms to expectations without changing it." CWE uses this more narrow interpretation.




### Observed Examples
- **CVE-2024-37032:** Large language model (LLM) management tool does not validate the format of a digest value (CWE-1287) from a private, untrusted model registry, enabling relative path traversal (CWE-23), a.k.a. Probllama
- **CVE-2022-45918:** Chain: a learning management tool debugger uses external input to locate previous session logs (CWE-73) and does not properly validate the given path (CWE-20), allowing for filesystem path traversal using "../" sequences (CWE-24)
- **CVE-2021-30860:** Chain: improper input validation (CWE-20) leads to integer overflow (CWE-190) in mobile OS, as exploited in the wild per CISA KEV.



## CWE-129: Improper Validation of Array Index
**Abstraction:** Variant
**Status:** Draft

### Description
The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.

### Extended Description
Not provided

### Alternative Terms
out-of-bounds array index
index-out-of-range
array index underflow

### Relationships
ChildOf -> CWE-1285
ChildOf -> CWE-20
CanPrecede -> CWE-119
CanPrecede -> CWE-823
CanPrecede -> CWE-789

### Mapping Guidance
**Usage:** Allowed
**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.
**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.
**Reasons:**
- Acceptable-Use


### Potential Mitigations
**Mitigation 1:**
- **Phase:** Architecture and Design
- **Strategy:** Input Validation
- **Description:** Use an input validation framework such as Struts or the OWASP ESAPI Validation API. Note that using a framework does not automatically address all input validation problems; be mindful of weaknesses that could arise from misusing the framework itself (CWE-1173).

**Mitigation 2:**
- **Phase:** Architecture and Design
- **Description:** 

For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.


Even though client-side checks provide minimal benefits with respect to server-side security, they are still useful. First, they can support intrusion detection. If the server receives input that should have been rejected by the client, then it may be an indication of an attack. Second, client-side error-checking can provide helpful feedback to the user about the expectations for valid input. Third, there may be a reduction in server-side processing time for accidental input errors, although this is typically a small savings.


**Mitigation 3:**
- **Phase:** Requirements
- **Strategy:** Language Selection
- **Description:** 

Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.


For example, Ada allows the programmer to constrain the values of a variable and languages such as Java and Ruby will allow the programmer to handle exceptions when an out-of-bounds index is accessed.




### Additional Notes
**[Relationship]** This weakness can precede uncontrolled memory allocation (CWE-789) in languages that automatically expand an array when an index is used that is larger than the size of the array, such as JavaScript.

**[Theoretical]** An improperly validated array index might lead directly to the always-incorrect behavior of "access of array using out-of-bounds index."



### Observed Examples
- **CVE-2005-0369:** large ID in packet used as array index
- **CVE-2001-1009:** negative array index as argument to POP LIST command
- **CVE-2003-0721:** Integer signedness error leads to negative array index



## CWE-125: Out-of-bounds Read
**Abstraction:** Base
**Status:** Draft

### Description
The product reads data past the end, or before the beginning, of the intended buffer.

### Extended Description
Not provided

### Alternative Terms
OOB read: Shorthand for "Out of bounds" read

### Relationships
ChildOf -> CWE-119
ChildOf -> CWE-119
ChildOf -> CWE-119
ChildOf -> CWE-119
ParentOf -> CWE-126
ParentOf -> CWE-127
CanFollow -> CWE-822
CanFollow -> CWE-823
CanFollow -> CWE-824
CanFollow -> CWE-825

### Mapping Guidance
**Usage:** Allowed
**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.
**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.
**Reasons:**
- Acceptable-Use


### Potential Mitigations
**Mitigation 1:**
- **Phase:** Implementation
- **Strategy:** Input Validation
- **Description:** 

Assume all input is malicious. Use an "accept known good" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.


When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, "boat" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as "red" or "blue."


Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.


To reduce the likelihood of introducing an out-of-bounds read, ensure that you validate and ensure correct calculations for any length argument, buffer size calculation, or offset. Be especially careful of relying on a sentinel (i.e. special character such as NUL) in untrusted inputs.


**Mitigation 2:**
- **Phase:** Architecture and Design
- **Strategy:** Language Selection
- **Description:** Use a language that provides appropriate memory abstractions.




### Observed Examples
- **CVE-2023-1018:** The reference implementation code for a Trusted Platform Module does not implement length checks on data, allowing for an attacker to read 2 bytes past the end of a buffer.
- **CVE-2020-11899:** Out-of-bounds read in IP stack used in embedded systems, as exploited in the wild per CISA KEV.
- **CVE-2014-0160:** Chain: "Heartbleed" bug receives an inconsistent length parameter (CWE-130) enabling an out-of-bounds read (CWE-126), returning memory that could include private cryptographic keys and other sensitive data.

