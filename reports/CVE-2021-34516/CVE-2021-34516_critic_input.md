# Critic Input for CVE-2021-34516



# Original Analyzer Input
## Vulnerability Description
Win32k Elevation of Privilege Vulnerability

### Vulnerability Description Key Phrases
- **product:** Windows
- **component:** Win32k

### CWE for similar CVE Descriptions
### Primary CWE Match
CWE-NVD-noinfo

#### Top CWEs
- CWE-NVD-noinfo (Count: 532)
- CWE-269 (Count: 103)
- CWE-362 (Count: 67)

## CVE Reference Links Content Summary
The provided content describes multiple vulnerabilities, all identified as CVE-2021-34516, affecting the Microsoft Windows Canonical Display Driver (cdd.dll).  The root cause of these vulnerabilities is either an untrusted pointer dereference due to a lack of proper validation of user-supplied values or a null pointer dereference.

**Vulnerabilities and Root Causes:**

The following functions within cdd.dll are affected by untrusted pointer dereference vulnerabilities due to a lack of proper input validation:
*   **DrvStrokeAndFillPath**
*   **DrvStretchBltInternal**
*   **DrvLineTo**
*   **DrvStrokePath**
*   **DrvPlgBltInternal**
*  **DrvBitBltInternal**
* **DrvGradientFill**
* **DrvTransparentBltInternal**
* **DrvFillPath**
*   **DrvStretchBltROPInternal**
*   **DrvAlphaBlendInternal**
* **DrvTextOut**
    
The following functions within cdd.dll are affected by null pointer dereference vulnerabilities:
*   **DrvFillPath**
*  **DrvLineTo**
*   **DrvStrokeAndFillPath**
*   **DrvGradientFill**
*   **DrvTextOut**
*  **DrvStrokePath**
*  **ColorFillBitmap**
    

**Impact of Exploitation:**

*   Successful exploitation of these vulnerabilities allows a local attacker to escalate privileges to SYSTEM, enabling the attacker to execute arbitrary code with the highest privileges.

**Attack Vectors:**

*   Local access is required to exploit these vulnerabilities.
*   The attacker must be able to execute low-privileged code on the target system.

**Required Attacker Capabilities:**

*   Ability to execute low-privileged code on a vulnerable Windows system.
*   No user interaction is required (UI:N).
*  The attacker needs to supply a malicious user-supplied value or trigger the condition that leads to null pointer dereference.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage | Combined Score | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|---------------|------------|-------------------|
| 1 | CWE-1386 | Insecure Operation on Windows Junction / Mount Point | Base | Allowed | 0.5293 | dense, sparse, graph | dense: 0.600, sparse: 0.009, graph: 0.626 |
| 2 | CWE-59 | Improper Link Resolution Before File Access ('Link Following') | Base | Allowed | 0.4981 | dense, sparse, graph | dense: 0.541, sparse: 0.011, graph: 0.619 |
| 3 | CWE-266 | Incorrect Privilege Assignment | Base | Allowed | 0.4978 | dense, sparse, graph | dense: 0.551, sparse: 0.009, graph: 0.606 |
| 4 | CWE-787 | Out-of-bounds Write | Base | Allowed | 0.3608 | sparse, graph | sparse: 0.009, graph: 0.995 |
| 5 | CWE-1285 | Improper Validation of Specified Index, Position, or Offset in Input | Base | Allowed | 0.3120 | sparse, graph | sparse: 0.010, graph: 0.857 |
| 6 | CWE-825 | Expired Pointer Dereference | Base | Allowed | 0.2870 | sparse, graph | sparse: 0.008, graph: 0.789 |
| 7 | CWE-123 | Write-what-where Condition | Base | Allowed | 0.0052 | sparse | sparse: 0.009 |
| 8 | CWE-454 | External Initialization of Trusted Variables or Data Stores | Base | Allowed | 0.0050 | sparse | sparse: 0.009 |
| 9 | CWE-378 | Creation of Temporary File With Insecure Permissions | Base | Allowed | 0.0047 | sparse | sparse: 0.008 |
| 10 | CWE-191 | Integer Underflow (Wrap or Wraparound) | Base | Allowed | 0.0047 | sparse | sparse: 0.008 |



# Analysis to Review
# Summary
| CWE ID  | CWE Name    | Confidence | CWE Abstraction Level | CWE Vulnerability Mapping Label | CWE-Vulnerability Mapping Notes |
|--------------|--------------------------------------------------------------------------------------------|------------|-----------------------|------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| CWE-476 | NULL Pointer Dereference | 0.9 | Base | Allowed | The product dereferences a pointer that it expects to be valid but is NULL. |
| CWE-822 | Untrusted Pointer Dereference | 0.9 | Base | Allowed | The product obtains a value from an untrusted source, converts this value to a pointer, and dereferences the resulting pointer. |

## Evidence and Confidence

*   **Confidence Score:** 0.9
*   **Evidence Strength:** HIGH

- **Analysis and Justification:**  
  - *Explanation:* The vulnerability description explicitly mentions **null pointer dereference vulnerabilities** and **untrusted pointer dereference** in multiple functions within cdd.dll. Specifically, the functions **DrvFillPath**, **DrvLineTo**, **DrvStrokeAndFillPath**, **DrvGradientFill**, **DrvTextOut**, **DrvStrokePath**, and **ColorFillBitmap** are affected by **null pointer dereference vulnerabilities**. Additionally, the functions **DrvStrokeAndFillPath**, **DrvStretchBltInternal**, **DrvLineTo**, **DrvStrokePath**, **DrvPlgBltInternal**, **DrvBitBltInternal**, **DrvGradientFill**, **DrvTransparentBltInternal**, **DrvFillPath**, **DrvStretchBltROPInternal**, **DrvAlphaBlendInternal**, and **DrvTextOut** are affected by **untrusted pointer dereference vulnerabilities** due to a lack of proper input validation. This direct evidence strongly supports mapping to CWE-476 (NULL Pointer Dereference) and CWE-822 (Untrusted Pointer Dereference). Both CWEs are at the Base level of abstraction, which is preferred, and the MITRE mapping guidance indicates that they are ALLOWED.

  - *Relationship Analysis:* CWE-476 (NULL Pointer Dereference) has a parent relationship to CWE-754 (Improper Check for Unusual or Exceptional Conditions) and CWE-710 (Fault Masking Errors). It can also precede CWE-789 (Uncontrolled Memory Allocation) or CWE-362 (Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')). CWE-822 (Untrusted Pointer Dereference) shares similarities with CWE-416 (Use After Free) and CWE-415 (Double Free) but is more specific to the case where the pointer value is derived from an untrusted source.

- **Confidence Score:**  
  - Confidence: 0.9 (High confidence due to the explicit mention of the weaknesses in the vulnerability description and CVE reference materials)

---

# CWE Examples from Database


## Known Examples for CWE-822: Untrusted Pointer Dereference
### Observed Examples
- **CVE-2007-5655** [https://www.cve.org/CVERecord?id=CVE-2007-5655](https://www.cve.org/CVERecord?id=CVE-2007-5655): message-passing framework interprets values in packets as pointers, causing a crash.
- **CVE-2010-2299** [https://www.cve.org/CVERecord?id=CVE-2010-2299](https://www.cve.org/CVERecord?id=CVE-2010-2299): labeled as a "type confusion" issue, also referred to as a "stale pointer." However, the bug ID says "contents are simply interpreted as a pointer... renderer ordinarily doesn't supply this pointer directly". The "handle" in the untrusted area is replaced in one function, but not another - thus also, effectively, exposure to wrong sphere (CWE-668).
- **CVE-2009-1719** [https://www.cve.org/CVERecord?id=CVE-2009-1719](https://www.cve.org/CVERecord?id=CVE-2009-1719): Untrusted dereference using undocumented constructor.
- **CVE-2009-1250** [https://www.cve.org/CVERecord?id=CVE-2009-1250](https://www.cve.org/CVERecord?id=CVE-2009-1250): An error code is incorrectly checked and interpreted as a pointer, leading to a crash.
- **CVE-2009-0311** [https://www.cve.org/CVERecord?id=CVE-2009-0311](https://www.cve.org/CVERecord?id=CVE-2009-0311): An untrusted value is obtained from a packet and directly called as a function pointer, leading to code execution.
- **CVE-2010-1818** [https://www.cve.org/CVERecord?id=CVE-2010-1818](https://www.cve.org/CVERecord?id=CVE-2010-1818): Undocumented attribute in multimedia software allows "unmarshaling" of an untrusted pointer.
- **CVE-2010-3189** [https://www.cve.org/CVERecord?id=CVE-2010-3189](https://www.cve.org/CVERecord?id=CVE-2010-3189): ActiveX control for security software accepts a parameter that is assumed to be an initialized pointer.
- **CVE-2010-1253** [https://www.cve.org/CVERecord?id=CVE-2010-1253](https://www.cve.org/CVERecord?id=CVE-2010-1253): Spreadsheet software treats certain record values that lead to "user-controlled pointer" (might be untrusted offset, not untrusted pointer).
### Top 25 Examples
- **CVE-2021-22649**: Luxion KeyShot versions prior to 10.1, Luxion KeyShot Viewer versions prior to 10.1, Luxion KeyShot Network Rendering versions prior to 10.1, and Luxion KeyVR versions prior to 10.1 have multiple NULL pointer dereference issues while processing project files, which may allow an attacker to execute arbitrary code.
- **CVE-2021-40157**: A user may be tricked into opening a malicious FBX file which may exploit an Untrusted Pointer Dereference vulnerability in FBXâ€™s Review version 1.5.0 and prior causing it to run arbitrary code on the system.


# Relevant CWE Specifications

## CWE-822: Untrusted Pointer Dereference
**Abstraction:** Base
**Status:** Incomplete

### Description
The product obtains a value from an untrusted source, converts this value to a pointer, and dereferences the resulting pointer.

### Extended Description


An attacker can supply a pointer for memory locations that the product is not expecting. If the pointer is dereferenced for a write operation, the attack might allow modification of critical state variables, cause a crash, or execute code. If the dereferencing operation is for a read, then the attack might allow reading of sensitive data, cause a crash, or set a variable to an unexpected value (since the value will be read from an unexpected memory location).


There are several variants of this weakness, including but not necessarily limited to:


  - The untrusted value is directly invoked as a function call.

  - In OS kernels or drivers where there is a boundary between "userland" and privileged memory spaces, an untrusted pointer might enter through an API or system call (see CWE-781 for one such example).

  - Inadvertently accepting the value from an untrusted control sphere when it did not have to be accepted as input at all. This might occur when the code was originally developed to be run by a single user in a non-networked environment, and the code is then ported to or otherwise exposed to a networked environment.



### Alternative Terms
None

### Relationships
ChildOf -> CWE-119
ChildOf -> CWE-119
ChildOf -> CWE-119
CanPrecede -> CWE-125
CanPrecede -> CWE-787
CanFollow -> CWE-781

### Mapping Guidance
**Usage:** Allowed
**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.
**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.
**Reasons:**
- Acceptable-Use



### Additional Notes
**[Maintenance]** There are close relationships between incorrect pointer dereferences and other weaknesses related to buffer operations. There may not be sufficient community agreement regarding these relationships. Further study is needed to determine when these relationships are chains, composites, perspective/layering, or other types of relationships. As of September 2010, most of the relationships are being captured as chains.

**[Terminology]** Many weaknesses related to pointer dereferences fall under the general term of "memory corruption" or "memory safety." As of September 2010, there is no commonly-used terminology that covers the lower-level variants.



### Observed Examples
- **CVE-2007-5655:** message-passing framework interprets values in packets as pointers, causing a crash.
- **CVE-2010-2299:** labeled as a "type confusion" issue, also referred to as a "stale pointer." However, the bug ID says "contents are simply interpreted as a pointer... renderer ordinarily doesn't supply this pointer directly". The "handle" in the untrusted area is replaced in one function, but not another - thus also, effectively, exposure to wrong sphere (CWE-668).
- **CVE-2009-1719:** Untrusted dereference using undocumented constructor.



## CWE-789: Memory Allocation with Excessive Size Value
**Abstraction:** Variant
**Status:** Draft

### Description
The product allocates memory based on an untrusted, large size value, but it does not ensure that the size is within expected limits, allowing arbitrary amounts of memory to be allocated.

### Extended Description
Not provided

### Alternative Terms
Stack Exhaustion: When a weakness allocates excessive memory on the stack, it is often described as "stack exhaustion," which is a technical impact of the weakness. This technical impact is often encountered as a consequence of CWE-789 and/or CWE-1325.

### Relationships
ChildOf -> CWE-770
CanPrecede -> CWE-476
CanFollow -> CWE-1284
CanFollow -> CWE-129

### Mapping Guidance
**Usage:** Allowed
**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.
**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.
**Reasons:**
- Acceptable-Use


### Potential Mitigations
**Mitigation 1:**
- **Phase:** Implementation, Architecture and Design
- **Description:** Perform adequate input validation against any value that influences the amount of memory that is allocated. Define an appropriate strategy for handling requests that exceed the limit, and consider supporting a configuration option so that the administrator can extend the amount of memory to be used if necessary.

**Mitigation 2:**
- **Phase:** Operation
- **Description:** Run your program using system-provided resource limits for memory. This might still cause the program to crash or exit, but the impact to the rest of the system will be minimized.



### Additional Notes
**[Relationship]** This weakness can be closely associated with integer overflows (CWE-190). Integer overflow attacks would concentrate on providing an extremely large number that triggers an overflow that causes less memory to be allocated than expected. By providing a large value that does not trigger an integer overflow, the attacker could still cause excessive amounts of memory to be allocated.

**[Applicable Platform]** 

Uncontrolled memory allocation is possible in many languages, such as dynamic array allocation in perl or initial size parameters in Collections in Java. However, languages like C and C++ where programmers have the power to more directly control memory management will be more susceptible.




### Observed Examples
- **CVE-2022-21668:** Chain: Python library does not limit the resources used to process images that specify a very large number of bands (CWE-1284), leading to excessive memory consumption (CWE-789) or an integer overflow (CWE-190).
- **CVE-2010-3701:** program uses ::alloca() for encoding messages, but large messages trigger segfault
- **CVE-2008-1708:** memory consumption and daemon exit by specifying a large value in a length field



## CWE-416: Use After Free
**Abstraction:** Variant
**Status:** Stable

### Description
The product reuses or references memory after it has been freed. At some point afterward, the memory may be allocated again and saved in another pointer, while the original pointer references a location somewhere within the new allocation. Any operations using the original pointer are no longer valid because the memory "belongs" to the code that operates on the new pointer.

### Extended Description
Not provided

### Alternative Terms
Dangling pointer: a pointer that no longer points to valid memory, often after it has been freed
UAF: commonly used acronym for Use After Free
Use-After-Free

### Relationships
ChildOf -> CWE-825
ChildOf -> CWE-672
ChildOf -> CWE-672
ChildOf -> CWE-672
CanPrecede -> CWE-120
CanPrecede -> CWE-123
CanFollow -> CWE-1265
CanFollow -> CWE-362
CanFollow -> CWE-364
CanFollow -> CWE-754

### Mapping Guidance
**Usage:** Allowed
**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.
**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.
**Reasons:**
- Acceptable-Use


### Potential Mitigations
**Mitigation 1:**
- **Phase:** Architecture and Design
- **Strategy:** Language Selection
- **Description:** Choose a language that provides automatic memory management.

**Mitigation 2:**
- **Phase:** Implementation
- **Effectiveness:** Defense in Depth
- **Strategy:** Attack Surface Reduction
- **Description:** When freeing pointers, be sure to set them to NULL once they are freed. However, the utilization of multiple or complex data structures may lower the usefulness of this strategy.




### Observed Examples
- **CVE-2022-20141:** Chain: an operating system kernel has insufficent resource locking (CWE-413) leading to a use after free (CWE-416).
- **CVE-2022-2621:** Chain: two threads in a web browser use the same resource (CWE-366), but one of those threads can destroy the resource before the other has completed (CWE-416).
- **CVE-2021-0920:** Chain: mobile platform race condition (CWE-362) leading to use-after-free (CWE-416), as exploited in the wild per CISA KEV.



## CWE-710: Improper Adherence to Coding Standards
**Abstraction:** Pillar
**Status:** Incomplete

### Description
The product does not follow certain coding rules for development, which can lead to resultant weaknesses or increase the severity of the associated vulnerabilities.

### Extended Description
Not provided

### Alternative Terms
None

### Relationships
ParentOf -> CWE-1061
ParentOf -> CWE-1093
ParentOf -> CWE-1120
ParentOf -> CWE-1126
ParentOf -> CWE-1127
ParentOf -> CWE-1164
ParentOf -> CWE-1177
ParentOf -> CWE-1209
ParentOf -> CWE-1357
ParentOf -> CWE-476
ParentOf -> CWE-477
ParentOf -> CWE-484
ParentOf -> CWE-489
ParentOf -> CWE-570
ParentOf -> CWE-571
ParentOf -> CWE-573
ParentOf -> CWE-657
ParentOf -> CWE-684
ParentOf -> CWE-758

### Mapping Guidance
**Usage:** Discouraged
**Rationale:** This CWE entry is extremely high-level, a Pillar.
**Comments:** Consider children or descendants of this entry instead.
**Reasons:**
- Abstraction


### Potential Mitigations
**Mitigation 1:**
- **Phase:** Implementation
- **Description:** Document and closely follow coding standards.

**Mitigation 2:**
- **Phase:** Testing, Implementation
- **Description:** Where possible, use automated tools to enforce the standards.






## CWE-754: Improper Check for Unusual or Exceptional Conditions
**Abstraction:** Class
**Status:** Incomplete

### Description
The product does not check or incorrectly checks for unusual or exceptional conditions that are not expected to occur frequently during day to day operation of the product.

### Extended Description


The programmer may assume that certain events or conditions will never occur or do not need to be worried about, such as low memory conditions, lack of access to resources due to restrictive permissions, or misbehaving clients or components. However, attackers may intentionally trigger these unusual conditions, thus violating the programmer's assumptions, possibly introducing instability, incorrect behavior, or a vulnerability.


Note that this entry is not exclusively about the use of exceptions and exception handling, which are mechanisms for both checking and handling unusual or unexpected conditions.


### Alternative Terms
None

### Relationships
ChildOf -> CWE-703
CanPrecede -> CWE-416
ParentOf -> CWE-252
ParentOf -> CWE-253
ParentOf -> CWE-273
ParentOf -> CWE-354
ParentOf -> CWE-394
ParentOf -> CWE-476

### Mapping Guidance
**Usage:** Allowed-with-Review
**Rationale:** This CWE entry is a Class and might have Base-level children that would be more appropriate
**Comments:** Examine children of this entry to see if there is a better fit
**Reasons:**
- Abstraction


### Potential Mitigations
**Mitigation 1:**
- **Phase:** Requirements
- **Strategy:** Language Selection
- **Description:** 

Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.


Choose languages with features such as exception handling that force the programmer to anticipate unusual conditions that may generate exceptions. Custom exceptions may need to be developed to handle unusual business-logic conditions. Be careful not to pass sensitive exceptions back to the user (CWE-209, CWE-248).


**Mitigation 2:**
- **Phase:** Implementation
- **Effectiveness:** High
- **Description:** Check the results of all functions that return a value and verify that the value is expected.

**Mitigation 3:**
- **Phase:** Implementation
- **Effectiveness:** High
- **Description:** If using exception handling, catch and throw specific exceptions instead of overly-general exceptions (CWE-396, CWE-397). Catch and handle exceptions as locally as possible so that exceptions do not propagate too far up the call stack (CWE-705). Avoid unchecked or uncaught exceptions where feasible (CWE-248).



### Additional Notes
**[Relationship]** Sometimes, when a return value can be used to indicate an error, an unchecked return value is a code-layer instance of a missing application-layer check for exceptional conditions. However, return values are not always needed to communicate exceptional conditions. For example, expiration of resources, values passed by reference, asynchronously modified data, sockets, etc. may indicate exceptional conditions without the use of a return value.



### Observed Examples
- **CVE-2023-49286:** Chain: function in web caching proxy does not correctly check a return value (CWE-253) leading to a reachable assertion (CWE-617)
- **CVE-2007-3798:** Unchecked return value leads to resultant integer overflow and code execution.
- **CVE-2006-4447:** Program does not check return value when invoking functions to drop privileges, which could leave users with higher privileges than expected by forcing those functions to fail.



## CWE-415: Double Free
**Abstraction:** Variant
**Status:** Draft

### Description
The product calls free() twice on the same memory address, potentially leading to modification of unexpected memory locations.

### Extended Description
When a program calls free() twice with the same argument, the program's memory management data structures become corrupted. This corruption can cause the program to crash or, in some circumstances, cause two later calls to malloc() to return the same pointer. If malloc() returns the same value twice and the program later gives the attacker control over the data that is written into this doubly-allocated memory, the program becomes vulnerable to a buffer overflow attack.

### Alternative Terms
Double-free

### Relationships
ChildOf -> CWE-825
ChildOf -> CWE-1341
ChildOf -> CWE-672
ChildOf -> CWE-672
ChildOf -> CWE-672
ChildOf -> CWE-666
PeerOf -> CWE-416
PeerOf -> CWE-123
CanFollow -> CWE-364

### Mapping Guidance
**Usage:** Allowed
**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.
**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.
**Reasons:**
- Acceptable-Use


### Potential Mitigations
**Mitigation 1:**
- **Phase:** Architecture and Design
- **Description:** Choose a language that provides automatic memory management.

**Mitigation 2:**
- **Phase:** Implementation
- **Description:** Ensure that each allocation is freed only once. After freeing a chunk, set the pointer to NULL to ensure the pointer cannot be freed again. In complicated error conditions, be sure that clean-up routines respect the state of allocation properly. If the language is object oriented, ensure that object destructors delete each chunk of memory only once.

**Mitigation 3:**
- **Phase:** Implementation
- **Description:** Use a static analysis tool to find double free instances.



### Additional Notes
**[Relationship]** This is usually resultant from another weakness, such as an unhandled error or race condition between threads. It could also be primary to weaknesses such as buffer overflows.

**[Theoretical]** It could be argued that Double Free would be most appropriately located as a child of "Use after Free", but "Use" and "Release" are considered to be distinct operations within vulnerability theory, therefore this is more accurately "Release of a Resource after Expiration or Release", which doesn't exist yet.



### Observed Examples
- **CVE-2006-5051:** Chain: Signal handler contains too much functionality (CWE-828), introducing a race condition (CWE-362) that leads to a double free (CWE-415).
- **CVE-2004-0642:** Double free resultant from certain error conditions.
- **CVE-2004-0772:** Double free resultant from certain error conditions.



## CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')
**Abstraction:** Class
**Status:** Draft

### Description
The product contains a concurrent code sequence that requires temporary, exclusive access to a shared resource, but a timing window exists in which the shared resource can be modified by another code sequence operating concurrently.

### Extended Description


A race condition occurs within concurrent environments, and it is effectively a property of a code sequence. Depending on the context, a code sequence may be in the form of a function call, a small number of instructions, a series of program invocations, etc.


A race condition violates these properties, which are closely related:


  - Exclusivity - the code sequence is given exclusive access to the shared resource, i.e., no other code sequence can modify properties of the shared resource before the original sequence has completed execution.

  - Atomicity - the code sequence is behaviorally atomic, i.e., no other thread or process can concurrently execute the same sequence of instructions (or a subset) against the same resource.

A race condition exists when an "interfering code sequence" can still access the shared resource, violating exclusivity.

The interfering code sequence could be "trusted" or "untrusted." A trusted interfering code sequence occurs within the product; it cannot be modified by the attacker, and it can only be invoked indirectly. An untrusted interfering code sequence can be authored directly by the attacker, and typically it is external to the vulnerable product.


### Alternative Terms
Race Condition

### Relationships
ChildOf -> CWE-691
CanPrecede -> CWE-416
CanPrecede -> CWE-476
ParentOf -> CWE-1223
ParentOf -> CWE-1298
ParentOf -> CWE-364
ParentOf -> CWE-366
ParentOf -> CWE-367
ParentOf -> CWE-368
ParentOf -> CWE-421
RequiredBy -> CWE-61
CanFollow -> CWE-662
ParentOf -> CWE-689
RequiredBy -> CWE-689

### Mapping Guidance
**Usage:** Allowed-with-Review
**Rationale:** This CWE entry is a Class and might have Base-level children that would be more appropriate
**Comments:** Examine children of this entry to see if there is a better fit
**Reasons:**
- Abstraction


### Potential Mitigations
**Mitigation 1:**
- **Phase:** Architecture and Design
- **Description:** In languages that support it, use synchronization primitives. Only wrap these around critical code to minimize the impact on performance.

**Mitigation 2:**
- **Phase:** Architecture and Design
- **Description:** Use thread-safe capabilities such as the data access abstraction in Spring.

**Mitigation 3:**
- **Phase:** Architecture and Design
- **Description:** 

Minimize the usage of shared resources in order to remove as much complexity as possible from the control flow and to reduce the likelihood of unexpected conditions occurring.


Additionally, this will minimize the amount of synchronization necessary and may even help to reduce the likelihood of a denial of service where an attacker may be able to repeatedly trigger a critical section (CWE-400).




### Additional Notes
**[Maintenance]** The relationship between race conditions and synchronization problems (CWE-662) needs to be further developed. They are not necessarily two perspectives of the same core concept, since synchronization is only one technique for avoiding race conditions, and synchronization can be used for other purposes besides race condition prevention.

**[Research Gap]** Race conditions in web applications are under-studied and probably under-reported. However, in 2008 there has been growing interest in this area.

**[Research Gap]** Much of the focus of race condition research has been in Time-of-check Time-of-use (TOCTOU) variants (CWE-367), but many race conditions are related to synchronization problems that do not necessarily require a time-of-check.

**[Research Gap]** From a classification/taxonomy perspective, the relationships between concurrency and program state need closer investigation and may be useful in organizing related issues.



### Observed Examples
- **CVE-2022-29527:** Go application for cloud management creates a world-writable sudoers file that allows local attackers to inject sudo rules and escalate privileges to root by winning a race condition.
- **CVE-2021-1782:** Chain: improper locking (CWE-667) leads to race condition (CWE-362), as exploited in the wild per CISA KEV.
- **CVE-2021-0920:** Chain: mobile platform race condition (CWE-362) leading to use-after-free (CWE-416), as exploited in the wild per CISA KEV.



## CWE-476: NULL Pointer Dereference
**Abstraction:** Base
**Status:** Stable

### Description
The product dereferences a pointer that it expects to be valid but is NULL.

### Extended Description
Not provided

### Alternative Terms
NPD: Common abbreviation for Null Pointer Dereference
null deref: Common abbreviation for Null Pointer Dereference
NPE: Common abbreviation for Null Pointer Exception
nil pointer dereference: used for access of nil in Go programs

### Relationships
ChildOf -> CWE-710
ChildOf -> CWE-754
ChildOf -> CWE-754
CanFollow -> CWE-1325
CanFollow -> CWE-252
CanFollow -> CWE-362
CanFollow -> CWE-789

### Mapping Guidance
**Usage:** Allowed
**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.
**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.
**Reasons:**
- Acceptable-Use


### Potential Mitigations
**Mitigation 1:**
- **Phase:** Implementation
- **Description:** If all pointers that could have been modified are checked for NULL before use, nearly all NULL pointer dereferences can be prevented.

**Mitigation 2:**
- **Phase:** Requirements
- **Description:** Select a programming language that is not susceptible to these issues.

**Mitigation 3:**
- **Phase:** Implementation
- **Effectiveness:** Moderate
- **Description:** Check the results of all functions that return a value and verify that the value is non-null before acting upon it.




### Observed Examples
- **CVE-2005-3274:** race condition causes a table to be corrupted if a timer activates while it is being modified, leading to resultant NULL dereference; also involves locking.
- **CVE-2002-1912:** large number of packets leads to NULL dereference
- **CVE-2005-0772:** packet with invalid error status value triggers NULL dereference

