# Critic Input for CVE-2021-20195



# Original Analyzer Input
## Vulnerability Description
A flaw was found in keycloak in versions before 13.0.0. A Self Stored XSS attack vector escalating to a complete account takeover is possible due to **user-supplied data fields not being properly encoded** and Javascript code being used to process the data. The highest threat from this vulnerability is to data confidentiality and integrity as well as system availability.

### Vulnerability Description Key Phrases
- **rootcause:** **user-supplied data fields not being properly encoded**
- **weakness:** **cross-site scripting**
- **impact:** account takeover
- **product:** keycloak
- **version:** before 13.0.0

## CVE Reference Links Content Summary
Based on the provided content, here's the breakdown of the vulnerability:

**Root Cause:**

*   The Keycloak Account console does not properly HTML-encode user-supplied data, specifically the first and last name fields. This allows an attacker to inject malicious HTML and JavaScript code into these fields.

**Weaknesses/Vulnerabilities:**

*   **Stored Self-XSS (Cross-Site Scripting):** Malicious JavaScript code is stored within the user's profile data.
*   **Lack of Input Sanitization/Encoding:** The application fails to sanitize or encode user-supplied input before displaying it, which is a fundamental flaw in web application security.

**Impact of Exploitation:**

*   **Account Takeover:** Although the XSS is initially "self-XSS" (affecting the user who injects the code), it can be escalated to a complete account takeover. This is achieved by exploiting the impersonation functionality. When an administrator impersonates the attacker’s account, the malicious JavaScript will be executed within the administrator's browser session, allowing the attacker to compromise the administrator's access.
*   **Data Confidentiality and Integrity:** The attacker could potentially steal sensitive data or modify data within the application if admin access is gained.
*  **System Availability:** By compromising administrative access, an attacker may be able to disrupt normal system operation.

**Attack Vectors:**

*   **User Input Fields:** The attacker injects the malicious code into the first and last name fields of their user profile through the Keycloak Account console.
*   **Impersonation Feature:** An administrator impersonates the malicious user through the Keycloak admin interface. This action triggers the malicious code within the admin's session due to the stored XSS.

**Required Attacker Capabilities/Position:**

*   **Valid User Account:** The attacker needs a valid user account on the Keycloak instance to modify their profile.
*   **Knowledge of Impersonation Feature:** The attacker needs to be aware of the Keycloak admin’s ability to impersonate users.
*   **Social Engineering (Optional):** Although not strictly required, an attacker might try to entice an administrator to impersonate their account through social engineering tactics.

**Additional Details:**

*   The vulnerability was fixed in Keycloak version 13.0.0
*   Recommendations include:
    *   HTML encoding user-supplied data to prevent script execution.
    *   Implementing Content Security Policy (CSP) as a browser protection mechanism.
    *   Using subdomain separation for realms to enhance Same Origin Policy (SOP) protections.
*   The bug report was closed on 2021-02-16

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage | Combined Score | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|---------------|------------|-------------------|
| 1 | CWE-79 | Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting') | Base | Allowed | 0.8823 | dense, sparse, graph | dense: 0.585, sparse: 0.489, graph: 0.866 |
| 2 | CWE-352 | Cross-Site Request Forgery (CSRF) | Compound | Allowed | 0.6834 | dense, sparse, graph | dense: 0.565, sparse: 0.472, graph: 0.940 |
| 3 | CWE-444 | Inconsistent Interpretation of HTTP Requests ('HTTP Request/Response Smuggling') | Base | Allowed | 0.5251 | sparse, graph | sparse: 0.445, graph: 0.757 |
| 4 | CWE-1336 | Improper Neutralization of Special Elements Used in a Template Engine | Base | Allowed | 0.4273 | dense, sparse | dense: 0.559, sparse: 0.258 |
| 5 | CWE-116 | Improper Encoding or Escaping of Output | Class | Allowed-with-Review | 0.3637 | dense, sparse | dense: 0.570, sparse: 0.583 |
| 6 | CWE-863 | Incorrect Authorization | Class | Allowed-with-Review | 0.2558 | sparse, graph | sparse: 0.447, graph: 0.503 |
| 7 | CWE-787 | Out-of-bounds Write | Base | Allowed | 0.2485 | sparse | sparse: 0.434 |
| 8 | CWE-201 | Insertion of Sensitive Information Into Sent Data | Base | Allowed | 0.2411 | sparse | sparse: 0.422 |
| 9 | CWE-125 | Out-of-bounds Read | Base | Allowed | 0.2383 | sparse | sparse: 0.417 |
| 10 | CWE-94 | Improper Control of Generation of Code ('Code Injection') | Base | Allowed-with-Review | 0.2281 | sparse | sparse: 0.418 |



# Analysis to Review
# Summary
| CWE ID | CWE Name | Confidence | CWE Abstraction Level | CWE Vulnerability Mapping Label | CWE-Vulnerability Mapping Notes |
|---|---|---|---|---|---|
| CWE-79 | Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting') | 1.0 | Base | Allowed | Primary CWE |
| CWE-116 | Improper Encoding or Escaping of Output | 0.7 | Class | Allowed-with-Review | Secondary Candidate |

## Evidence and Confidence

*   **Confidence Score:** 0.85
*   **Evidence Strength:** HIGH

- **Analysis and Justification:**  
  - *Explanation:* "The vulnerability description clearly states that the root cause is **user-supplied data fields not being properly encoded**, leading to a Self Stored XSS attack. The CVE Reference Links Content Summary further confirms that the Keycloak Account console does not properly HTML-encode user-supplied data (first and last name fields), allowing injection of malicious HTML and JavaScript code. This aligns directly with CWE-79 [Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')], which describes the product failing to neutralize user-controllable input before it is placed in output used as a web page. The impact is account takeover, which is a common consequence of XSS. The MITRE mapping guidance for CWE-79 indicates this is ALLOWED, making it an appropriate mapping."
  
  - *Relationship Analysis:* "CWE-79 is a Base level CWE and a child of CWE-74 [Improper Neutralization of Special Elements]. The description emphasizes the improper encoding of user-supplied data, linking it to CWE-116 [Improper Encoding or Escaping of Output] as a contributing factor. While CWE-74 is a parent, CWE-79 is more specific because it directly relates to XSS. The retriever results also indicate that CWE-79 is the best match. There is a PEEROF relationship between CWE-79 and CWE-352 [Cross-Site Request Forgery (CSRF)], however, CSRF is not explicitly mentioned in the vulnerability description."

- **Confidence Score:** 
  - Confidence: 1.0 (High evidence from technical description, CVE reference materials, and retriever results)

---
- **Analysis and Justification:**  
  - *Explanation:* "The root cause of the vulnerability is the improper encoding of **user-supplied data fields**. The `Vulnerability Description Key Phrases` highlights this point. The injected JavaScript is then executed when the administrator impersonates the user, leading to account takeover. This indicates a failure to properly encode or escape output, which aligns with CWE-116 [Improper Encoding or Escaping of Output]. However, since the primary issue results in XSS, CWE-79 is the primary weakness, and CWE-116 is a contributing factor."

  - *Relationship Analysis:* "CWE-116 is a Class-level CWE, and its mapping guidance suggests reviewing for more specific Base-level children. It is related to CWE-79 because the lack of proper encoding directly leads to the XSS vulnerability. Considering the information available, mapping both CWE-79 and CWE-116 provides a more complete view of the weakness."

- **Confidence Score:**  
  - *Example:* Confidence: 0.7 (Supporting evidence from the root cause analysis, but the primary focus is on XSS)

# CWE Examples from Database


## Known Examples for CWE-352: Cross-Site Request Forgery (CSRF)
### Observed Examples
- **CVE-2004-1703** [https://www.cve.org/CVERecord?id=CVE-2004-1703](https://www.cve.org/CVERecord?id=CVE-2004-1703): Add user accounts via a URL in an img tag
- **CVE-2004-1995** [https://www.cve.org/CVERecord?id=CVE-2004-1995](https://www.cve.org/CVERecord?id=CVE-2004-1995): Add user accounts via a URL in an img tag
- **CVE-2004-1967** [https://www.cve.org/CVERecord?id=CVE-2004-1967](https://www.cve.org/CVERecord?id=CVE-2004-1967): Arbitrary code execution by specifying the code in a crafted img tag or URL
- **CVE-2004-1842** [https://www.cve.org/CVERecord?id=CVE-2004-1842](https://www.cve.org/CVERecord?id=CVE-2004-1842): Gain administrative privileges via a URL in an img tag
- **CVE-2005-1947** [https://www.cve.org/CVERecord?id=CVE-2005-1947](https://www.cve.org/CVERecord?id=CVE-2005-1947): Delete a victim's information via a URL or an img tag
- **CVE-2005-2059** [https://www.cve.org/CVERecord?id=CVE-2005-2059](https://www.cve.org/CVERecord?id=CVE-2005-2059): Change another user's settings via a URL or an img tag
- **CVE-2005-1674** [https://www.cve.org/CVERecord?id=CVE-2005-1674](https://www.cve.org/CVERecord?id=CVE-2005-1674): Perform actions as administrator via a URL or an img tag
- **CVE-2009-3520** [https://www.cve.org/CVERecord?id=CVE-2009-3520](https://www.cve.org/CVERecord?id=CVE-2009-3520): modify password for the administrator
- **CVE-2009-3022** [https://www.cve.org/CVERecord?id=CVE-2009-3022](https://www.cve.org/CVERecord?id=CVE-2009-3022): CMS allows modification of configuration via CSRF attack against the administrator
- **CVE-2009-3759** [https://www.cve.org/CVERecord?id=CVE-2009-3759](https://www.cve.org/CVERecord?id=CVE-2009-3759): web interface allows password changes or stopping a virtual machine via CSRF


# Relevant CWE Specifications

## CWE-352: Cross-Site Request Forgery (CSRF)
**Abstraction:** Compound
**Status:** Stable

### Description
The web application does not, or can not, sufficiently verify whether a well-formed, valid, consistent request was intentionally provided by the user who submitted the request.

### Extended Description
When a web server is designed to receive a request from a client without any mechanism for verifying that it was intentionally sent, then it might be possible for an attacker to trick a client into making an unintentional request to the web server which will be treated as an authentic request. This can be done via a URL, image load, XMLHttpRequest, etc. and can result in exposure of data or unintended code execution.

### Alternative Terms
Session Riding
Cross Site Reference Forgery
XSRF

### Relationships
ChildOf -> CWE-345
ChildOf -> CWE-345
Requires -> CWE-346
Requires -> CWE-441
Requires -> CWE-642
Requires -> CWE-613
CanFollow -> CWE-1275

### Mapping Guidance
**Usage:** Allowed
**Rationale:** This is a well-known Composite of multiple weaknesses that must all occur simultaneously, although it is attack-oriented in nature.
**Comments:** While attack-oriented composites are supported in CWE, they have not been a focus of research. There is a chance that future research or CWE scope clarifications will change or deprecate them. Perform root-cause analysis to determine if other weaknesses allow CSRF attacks to occur, and map to those weaknesses. For example, predictable CSRF tokens might allow bypass of CSRF protection mechanisms; if this occurs, they might be better characterized as randomness/predictability weaknesses.
**Reasons:**
- Other


### Potential Mitigations
**Mitigation 1:**
- **Phase:** Architecture and Design
- **Strategy:** Libraries or Frameworks
- **Description:** 

Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.


For example, use anti-CSRF packages such as the OWASP CSRFGuard. [REF-330]


Another example is the ESAPI Session Management control, which includes a component for CSRF. [REF-45]


**Mitigation 2:**
- **Phase:** Implementation
- **Description:** Ensure that the application is free of cross-site scripting issues (CWE-79), because most CSRF defenses can be bypassed using attacker-controlled script.

**Mitigation 3:**
- **Phase:** Architecture and Design
- **Description:** Generate a unique nonce for each form, place the nonce into the form, and verify the nonce upon receipt of the form. Be sure that the nonce is not predictable (CWE-330). [REF-332]



### Additional Notes
**[Relationship]** 

There can be a close relationship between XSS and CSRF (CWE-352). An attacker might use CSRF in order to trick the victim into submitting requests to the server in which the requests contain an XSS payload. A well-known example of this was the Samy worm on MySpace [REF-956]. The worm used XSS to insert malicious HTML sequences into a user's profile and add the attacker as a MySpace friend. MySpace friends of that victim would then execute the payload to modify their own profiles, causing the worm to propagate exponentially. Since the victims did not intentionally insert the malicious script themselves, CSRF was a root cause.


**[Theoretical]** 

The CSRF topology is multi-channel:


  - Attacker (as outsider) to intermediary (as user). The interaction point is either an external or internal channel.

  - Intermediary (as user) to server (as victim). The activation point is an internal channel.





### Observed Examples
- **CVE-2004-1703:** Add user accounts via a URL in an img tag
- **CVE-2004-1995:** Add user accounts via a URL in an img tag
- **CVE-2004-1967:** Arbitrary code execution by specifying the code in a crafted img tag or URL



## CWE-116: Improper Encoding or Escaping of Output
**Abstraction:** Class
**Status:** Draft

### Description
The product prepares a structured message for communication with another component, but encoding or escaping of the data is either missing or done incorrectly. As a result, the intended structure of the message is not preserved.

### Extended Description


Improper encoding or escaping can allow attackers to change the commands that are sent to another component, inserting malicious commands instead.


Most products follow a certain protocol that uses structured messages for communication between components, such as queries or commands. These structured messages can contain raw data interspersed with metadata or control information. For example, "GET /index.html HTTP/1.1" is a structured message containing a command ("GET") with a single argument ("/index.html") and metadata about which protocol version is being used ("HTTP/1.1").


If an application uses attacker-supplied inputs to construct a structured message without properly encoding or escaping, then the attacker could insert special characters that will cause the data to be interpreted as control information or metadata. Consequently, the component that receives the output will perform the wrong operations, or otherwise interpret the data incorrectly.


### Alternative Terms
Output Sanitization
Output Validation
Output Encoding

### Relationships
ChildOf -> CWE-707
CanPrecede -> CWE-74
ParentOf -> CWE-117
ParentOf -> CWE-644
ParentOf -> CWE-838

### Mapping Guidance
**Usage:** Allowed-with-Review
**Rationale:** This CWE entry is a Class and might have Base-level children that would be more appropriate
**Comments:** Examine children of this entry to see if there is a better fit
**Reasons:**
- Abstraction


### Potential Mitigations
**Mitigation 1:**
- **Phase:** Architecture and Design
- **Strategy:** Libraries or Frameworks
- **Description:** 

Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.


For example, consider using the ESAPI Encoding control [REF-45] or a similar tool, library, or framework. These will help the programmer encode outputs in a manner less prone to error.


Alternately, use built-in functions, but consider using wrappers in case those functions are discovered to have a vulnerability.


**Mitigation 2:**
- **Phase:** Architecture and Design
- **Strategy:** Parameterization
- **Description:** 

If available, use structured mechanisms that automatically enforce the separation between data and code. These mechanisms may be able to provide the relevant quoting, encoding, and validation automatically, instead of relying on the developer to provide this capability at every point where output is generated.


For example, stored procedures can enforce database query structure and reduce the likelihood of SQL injection.


**Mitigation 3:**
- **Phase:** Architecture and Design, Implementation
- **Description:** Understand the context in which your data will be used and the encoding that will be expected. This is especially important when transmitting data between different components, or when generating outputs that can contain multiple encodings at the same time, such as web pages or multi-part mail messages. Study all expected communication protocols and data representations to determine the required encoding strategies.



### Additional Notes
**[Relationship]** This weakness is primary to all weaknesses related to injection (CWE-74) since the inherent nature of injection involves the violation of structured messages.

**[Relationship]** 

CWE-116 and CWE-20 have a close association because, depending on the nature of the structured message, proper input validation can indirectly prevent special characters from changing the meaning of a structured message. For example, by validating that a numeric ID field should only contain the 0-9 characters, the programmer effectively prevents injection attacks.


However, input validation is not always sufficient, especially when less stringent data types must be supported, such as free-form text. Consider a SQL injection scenario in which a last name is inserted into a query. The name "O'Reilly" would likely pass the validation step since it is a common last name in the English language. However, it cannot be directly inserted into the database because it contains the "'" apostrophe character, which would need to be escaped or otherwise neutralized. In this case, stripping the apostrophe might reduce the risk of SQL injection, but it would produce incorrect behavior because the wrong name would be recorded.


**[Terminology]** The usage of the "encoding" and "escaping" terms varies widely. For example, in some programming languages, the terms are used interchangeably, while other languages provide APIs that use both terms for different tasks. This overlapping usage extends to the Web, such as the "escape" JavaScript function whose purpose is stated to be encoding. The concepts of encoding and escaping predate the Web by decades. Given such a context, it is difficult for CWE to adopt a consistent vocabulary that will not be misinterpreted by some constituency.

**[Theoretical]** This is a data/directive boundary error in which data boundaries are not sufficiently enforced before it is sent to a different control sphere.

**[Research Gap]** While many published vulnerabilities are related to insufficient output encoding, there is such an emphasis on input validation as a protection mechanism that the underlying causes are rarely described. Within CVE, the focus is primarily on well-understood issues like cross-site scripting and SQL injection. It is likely that this weakness frequently occurs in custom protocols that support multiple encodings, which are not necessarily detectable with automated techniques.



### Observed Examples
- **CVE-2021-41232:** Chain: authentication routine in Go-based agile development product does not escape user name (CWE-116), allowing LDAP injection (CWE-90)
- **CVE-2008-4636:** OS command injection in backup software using shell metacharacters in a filename; correct behavior would require that this filename could not be changed.
- **CVE-2008-0769:** Web application does not set the charset when sending a page to a browser, allowing for XSS exploitation when a browser chooses an unexpected encoding.



## CWE-74: Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')
**Abstraction:** Class
**Status:** Incomplete

### Description
The product constructs all or part of a command, data structure, or record using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify how it is parsed or interpreted when it is sent to a downstream component.

### Extended Description
Software or other automated logic has certain assumptions about what constitutes data and control respectively. It is the lack of verification of these assumptions for user-controlled input that leads to injection problems. Injection problems encompass a wide variety of issues -- all mitigated in very different ways and usually attempted in order to alter the control flow of the process. For this reason, the most effective way to discuss these weaknesses is to note the distinct features that classify them as injection weaknesses. The most important issue to note is that all injection problems share one thing in common -- i.e., they allow for the injection of control plane data into the user-controlled data plane. This means that the execution of the process may be altered by sending code in through legitimate data channels, using no other mechanism. While buffer overflows, and many other flaws, involve the use of some further issue to gain execution, injection problems need only for the data to be parsed.

### Alternative Terms
None

### Relationships
ChildOf -> CWE-707
CanFollow -> CWE-116
ParentOf -> CWE-1236
CanFollow -> CWE-20
ParentOf -> CWE-75
ParentOf -> CWE-77
ParentOf -> CWE-78
ParentOf -> CWE-79
ParentOf -> CWE-88
ParentOf -> CWE-89
ParentOf -> CWE-91
ParentOf -> CWE-917
ParentOf -> CWE-93
ParentOf -> CWE-94
ParentOf -> CWE-943
ParentOf -> CWE-99

### Mapping Guidance
**Usage:** Discouraged
**Rationale:** CWE-74 is high-level and often misused when lower-level weaknesses are more appropriate.
**Comments:** Examine the children and descendants of this entry to find a more precise mapping.
**Reasons:**
- Frequent Misuse
- Abstraction


### Potential Mitigations
**Mitigation 1:**
- **Phase:** Requirements
- **Description:** Programming languages and supporting technologies might be chosen which are not subject to these issues.

**Mitigation 2:**
- **Phase:** Implementation
- **Description:** Utilize an appropriate mix of allowlist and denylist parsing to filter control-plane syntax from all input.



### Additional Notes
**[Theoretical]** Many people treat injection only as an input validation problem (CWE-20) because many people do not distinguish between the consequence/attack (injection) and the protection mechanism that prevents the attack from succeeding. However, input validation is only one potential protection mechanism (output encoding is another), and there is a chaining relationship between improper input validation and the improper enforcement of the structure of messages to other components. Other issues not directly related to input validation, such as race conditions, could similarly impact message structure.



### Observed Examples
- **CVE-2024-5184:** API service using a large generative AI model allows direct prompt injection to leak hard-coded system prompts or execute other prompts.
- **CVE-2022-36069:** Python-based dependency management tool avoids OS command injection when generating Git commands but allows injection of optional arguments with input beginning with a dash (CWE-88), potentially allowing for code execution.
- **CVE-1999-0067:** Canonical example of OS command injection. CGI program does not neutralize "|" metacharacter when invoking a phonebook program.



## CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')
**Abstraction:** Base
**Status:** Stable

### Description
The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.

### Extended Description


Cross-site scripting (XSS) vulnerabilities occur when:


  1. Untrusted data enters a web application, typically from a web request.

  1. The web application dynamically generates a web page that contains this untrusted data.

  1. During page generation, the application does not prevent the data from containing content that is executable by a web browser, such as JavaScript, HTML tags, HTML attributes, mouse events, Flash, ActiveX, etc.

  1. A victim visits the generated web page through a web browser, which contains malicious script that was injected using the untrusted data.

  1. Since the script comes from a web page that was sent by the web server, the victim's web browser executes the malicious script in the context of the web server's domain.

  1. This effectively violates the intention of the web browser's same-origin policy, which states that scripts in one domain should not be able to access resources or run code in a different domain.

There are three main kinds of XSS:

  -  **Type 1: Reflected XSS (or Non-Persistent)**  - The server reads data directly from the HTTP request and reflects it back in the HTTP response. Reflected XSS exploits occur when an attacker causes a victim to supply dangerous content to a vulnerable web application, which is then reflected back to the victim and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or e-mailed directly to the victim. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces a victim to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the victim, the content is executed by the victim's browser.

  -  **Type 2: Stored XSS (or Persistent)**  - The application stores dangerous data in a database, message forum, visitor log, or other trusted data store. At a later time, the dangerous data is subsequently read back into the application and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user. For example, the attacker might inject XSS into a log message, which might not be handled properly when an administrator views the logs. 

  -  **Type 0: DOM-Based XSS**  - In DOM-based XSS, the client performs the injection of XSS into the page; in the other types, the server performs the injection. DOM-based XSS generally involves server-controlled, trusted script that is sent to the client, such as Javascript that performs sanity checks on a form before the user submits it. If the server-supplied script processes user-supplied data and then injects it back into the web page (such as with dynamic HTML), then DOM-based XSS is possible. 

Once the malicious script is injected, the attacker can perform a variety of malicious activities. The attacker could transfer private information, such as cookies that may include session information, from the victim's machine to the attacker. The attacker could send malicious requests to a web site on behalf of the victim, which could be especially dangerous to the site if the victim has administrator privileges to manage that site. Phishing attacks could be used to emulate trusted web sites and trick the victim into entering a password, allowing the attacker to compromise the victim's account on that web site. Finally, the script could exploit a vulnerability in the web browser itself possibly taking over the victim's machine, sometimes referred to as "drive-by hacking."

In many cases, the attack can be launched without the victim even being aware of it. Even with careful users, attackers frequently use a variety of methods to encode the malicious portion of the attack, such as URL encoding or Unicode, so the request looks less suspicious.


### Alternative Terms
XSS: A common abbreviation for Cross-Site Scripting.
HTML Injection: Used as a synonym of stored (Type 2) XSS.
CSS: In the early years after initial discovery of XSS, "CSS" was a commonly-used acronym. However, this would cause confusion with "Cascading Style Sheets," so usage of this acronym has declined significantly.

### Relationships
ChildOf -> CWE-74
ChildOf -> CWE-74
CanPrecede -> CWE-494
PeerOf -> CWE-352
CanFollow -> CWE-113
CanFollow -> CWE-184
ParentOf -> CWE-80
ParentOf -> CWE-81
ParentOf -> CWE-83
ParentOf -> CWE-84
ParentOf -> CWE-85
ParentOf -> CWE-86
ParentOf -> CWE-87

### Mapping Guidance
**Usage:** Allowed
**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.
**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.
**Reasons:**
- Acceptable-Use


### Potential Mitigations
**Mitigation 1:**
- **Phase:** Architecture and Design
- **Strategy:** Libraries or Frameworks
- **Description:** 

Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.


Examples of libraries and frameworks that make it easier to generate properly encoded output include Microsoft's Anti-XSS library, the OWASP ESAPI Encoding module, and Apache Wicket.


**Mitigation 2:**
- **Phase:** Implementation, Architecture and Design
- **Description:** 

Understand the context in which your data will be used and the encoding that will be expected. This is especially important when transmitting data between different components, or when generating outputs that can contain multiple encodings at the same time, such as web pages or multi-part mail messages. Study all expected communication protocols and data representations to determine the required encoding strategies.


For any data that will be output to another web page, especially any data that was received from external inputs, use the appropriate encoding on all non-alphanumeric characters.


Parts of the same output document may require different encodings, which will vary depending on whether the output is in the:


  - HTML body

  - Element attributes (such as src="XYZ")

  - URIs

  - JavaScript sections

  - Cascading Style Sheets and style property

etc. Note that HTML Entity Encoding is only appropriate for the HTML body.

Consult the XSS Prevention Cheat Sheet [REF-724] for more details on the types of encoding and escaping that are needed.


**Mitigation 3:**
- **Phase:** Architecture and Design, Implementation
- **Effectiveness:** Limited
- **Strategy:** Attack Surface Reduction
- **Description:** Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, filenames, databases, and any external systems that provide data to the application. Remember that such inputs may be obtained indirectly through API calls.



### Additional Notes
**[Relationship]** 

There can be a close relationship between XSS and CSRF (CWE-352). An attacker might use CSRF in order to trick the victim into submitting requests to the server in which the requests contain an XSS payload. A well-known example of this was the Samy worm on MySpace [REF-956]. The worm used XSS to insert malicious HTML sequences into a user's profile and add the attacker as a MySpace friend. MySpace friends of that victim would then execute the payload to modify their own profiles, causing the worm to propagate exponentially. Since the victims did not intentionally insert the malicious script themselves, CSRF was a root cause.


**[Applicable Platform]** 

XSS flaws are very common in web applications, since they require a great deal of developer discipline to avoid them.




### Observed Examples
- **CVE-2021-25926:** Python Library Manager did not sufficiently neutralize a user-supplied search term, allowing reflected XSS.
- **CVE-2021-25963:** Python-based e-commerce platform did not escape returned content on error pages, allowing for reflected Cross-Site Scripting attacks.
- **CVE-2021-1879:** Universal XSS in mobile operating system, as exploited in the wild per CISA KEV.

