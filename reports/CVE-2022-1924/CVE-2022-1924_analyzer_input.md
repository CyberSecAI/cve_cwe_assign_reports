# Vulnerability Information: CVE-2022-1924

## Vulnerability Description
DOS / potential heap overwrite in mkv demuxing using lzo decompression. Integer overflow in matroskademux element in lzo decompression function which causes a segfault, or could cause a heap overwrite, depending on libc and OS. Depending on the libc used, and the underlying OS capabilities, it could be just a segfault or a heap overwrite. If the libc uses mmap for large chunks, and the OS supports mmap, then it is just a segfault (because the realloc before the **integer overflow** will use mremap to reduce the size of the chunk, and it will start to write to unmapped memory). However, if using a libc implementation that does not use mmap, or if the OS does not support mmap while using libc, then this could result in a heap overwrite.

### Vulnerability Description Key Phrases
- **rootcause:** **integer overflow**
- **impact:** segfault or heap overwrite
- **vector:** mkv demuxing using lzo decompression
- **product:** matroskademux element
- **component:** lzo decompression function

### CWE for similar CVE Descriptions
### Primary CWE Match
CWE-190

#### Top CWEs
- CWE-190 (Count: 12)

## CVE Reference Links Content Summary
Based on the provided content, here's an analysis of CVE-2022-1924:

**Root cause of vulnerability:**

- The vulnerability stems from an integer overflow during the decoding of zlib-encoded data within the `gst_matroska_decompress_data` function of the GStreamer's Matroska demuxer.
- Specifically, the `zstream` data counters use 64-bit integers, while the `gst_matroska_decompress_data` function uses 32-bit integers to store the size, causing a potential overflow when a large decompressed size is encountered.
- The provided proof-of-concept (POC) MKV file contains a block that, when decompressed, results in a size of 0x100000000 which overflows a 32 bit int.

**Weaknesses/vulnerabilities present:**

- **Integer Overflow:** The primary weakness is an integer overflow in the `new_size` variable within the `gst_matroska_decompress_data` function.
- **Heap Overflow/Overwrite:** When a large decompressed size is encountered, the overflow leads to an incorrect allocation size calculation. Depending on the libc implementation and OS support for memory mapping using mmap, this can result in a segmentation fault or heap memory corruption/overwrite if realloc doesn't use mmap for large allocations.

**Impact of exploitation:**

- **Denial of Service (DoS):** A primary impact is a segmentation fault, which leads to a crash of the application, resulting in a denial of service.
- **Potential Heap Memory Corruption:** In certain configurations where the libc does not use `mmap` for large memory allocation or if the OS does not support `mmap`, a heap overflow may occur leading to memory corruption which could be exploited further.
- **Potentially Arbitrary Code Execution:** While not explicitly stated in this content, memory corruption vulnerabilities like this have the potential to lead to arbitrary code execution by an attacker with sufficient control of the heap.

**Attack vectors:**

- **Malicious Media File:** The attack vector is a crafted Matroska (MKV) file containing a zlib-compressed data block with a size that, when decompressed, will cause the integer overflow.

**Required attacker capabilities/position:**

- **File Delivery:** An attacker needs to be able to provide a crafted MKV file to a vulnerable application using Gstreamer. This could involve tricking a user into opening the malicious file through various means like websites, email or removable media.
- **No Special Permissions Required:** The vulnerability does not require any special user privileges for the exploit to occur.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage | Combined Score | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|---------------|------------|-------------------|
| 1 | CWE-190 | Integer Overflow or Wraparound | Base | Allowed | 1.1031 | dense, sparse, graph | dense: 0.552, sparse: 1.000, graph: 0.712 |
| 2 | CWE-789 | Memory Allocation with Excessive Size Value | Variant | Allowed | 0.8011 | dense, sparse, graph | dense: 0.488, sparse: 0.606, graph: 0.773 |
| 3 | CWE-191 | Integer Underflow (Wrap or Wraparound) | Base | Allowed | 0.7666 | dense, sparse, graph | dense: 0.485, sparse: 0.547, graph: 0.591 |
| 4 | CWE-1284 | Improper Validation of Specified Quantity in Input | Base | Allowed | 0.7075 | sparse, graph | sparse: 0.612, graph: 1.000 |
| 5 | CWE-125 | Out-of-bounds Read | Base | Allowed | 0.5573 | dense, sparse | dense: 0.456, sparse: 0.576 |
| 6 | CWE-197 | Numeric Truncation Error | Base | Allowed | 0.5513 | dense, sparse | dense: 0.463, sparse: 0.559 |
| 7 | CWE-122 | Heap-based Buffer Overflow | Variant | Allowed | 0.5500 | dense, sparse | dense: 0.528, sparse: 0.580 |
| 8 | CWE-193 | Off-by-one Error | Base | Allowed | 0.5491 | dense, sparse | dense: 0.458, sparse: 0.559 |
| 9 | CWE-839 | Numeric Range Comparison Without Minimum Check | Base | Allowed | 0.5234 | sparse, graph | sparse: 0.539, graph: 0.602 |
| 10 | CWE-195 | Signed to Unsigned Conversion Error | Variant | Allowed | 0.5224 | sparse, graph | sparse: 0.541, graph: 0.717 |

