# Vulnerability Information: CVE-2021-29529

## Vulnerability Description
TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a **heap buffer overflow** in `tf.raw_ops.QuantizedResizeBilinear` by manipulating input values so that **float rounding results in off-by-one error** in accessing image elements. This is because the implementation(https//github.com/tensorflow/tensorflow/blob/44b7f486c0143f68b56c34e2d01e146ee445134a/tensorflow/core/kernels/quantized_resize_bilinear_op.cc#L62-L66) computes two integers (representing the upper and lower bounds for interpolation) by ceiling and flooring a floating point value. For some values of `in`, `interpolation->upper[i]` might be smaller than `interpolation->lower[i]`. This is an issue if `interpolation->upper[i]` is capped at `in_size-1` as it means that `interpolation->lower[i]` points outside of the image. Then, in the interpolation code(https//github.com/tensorflow/tensorflow/blob/44b7f486c0143f68b56c34e2d01e146ee445134a/tensorflow/core/kernels/quantized_resize_bilinear_op.cc#L245-L264), this would result in **heap buffer overflow**. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.

### Vulnerability Description Key Phrases
- **rootcause:** **float rounding results in off-by-one error**
- **weakness:** **heap buffer overflow**
- **product:** TensorFlow
- **version:** 2.5.0
- **component:** tf.raw_ops.QuantizedResizeBilinear

## CVE Reference Links Content Summary
Based on the provided content, here's an analysis of CVE-2021-29529:

**Root Cause:**
The vulnerability stems from a floating-point rounding error during the calculation of interpolation bounds in the `tf.raw_ops.QuantizedResizeBilinear` operation. When resizing images, the code calculates lower and upper bounds for interpolation using `floor` and `ceil` operations on a floating-point value representing the input coordinate. Due to floating-point imprecision, the calculated upper bound can become less than the lower bound. This, combined with clamping the upper bound to `in_size - 1`, could lead to out-of-bounds memory access.

**Weaknesses/Vulnerabilities:**
- Heap buffer overflow: The core vulnerability is a heap buffer overflow in the `OutputLerpForChannels` function.
- Off-by-one error: This arises because incorrect interpolation bounds are calculated due to rounding issues, leading to an out-of-bounds read.
- Incorrect boundary checks: The clamping of the upper bound to `in_size - 1` combined with the rounding issue, created the conditions for out-of-bounds access.

**Impact of Exploitation:**
- An attacker can trigger a heap buffer overflow, which can lead to a crash, denial of service, or potentially arbitrary code execution. The provided description and sample code demonstrate how specific input parameters can trigger this overflow.

**Attack Vectors:**
- By crafting specific input values (image data, size, min, max, and alignment parameters) to `tf.raw_ops.QuantizedResizeBilinear`, an attacker can manipulate the internal floating-point values to induce the rounding error.

**Required Attacker Capabilities/Position:**
- The attacker needs to be able to provide input to the `tf.raw_ops.QuantizedResizeBilinear` function and control the relevant input parameters, such as the images, the target size, the quantization range, and the alignment settings.

**More Details:**

The provided content includes a code snippet that demonstrates how to trigger the vulnerability:
```python
import tensorflow as tf

l = [256, 328, 361, 17, 361, 361, 361, 361, 361, 361, 361, 361, 361, 361, 384]
images = tf.constant(l, shape=[1, 1, 15, 1], dtype=tf.qint32)
size = tf.constant([12, 6], shape=[2], dtype=tf.int32)
min = tf.constant(80.22522735595703)
max = tf.constant(80.39215850830078)

tf.raw_ops.QuantizedResizeBilinear(images=images, size=size, min=min, max=max,
                                   align_corners=True, half_pixel_centers=True)
```
This code highlights how specific combinations of input values can trigger the vulnerability, especially when `align_corners` and `half_pixel_centers` are set to True, which is necessary for the bug to be exploitable.

The fix introduces a check that enforces that the lower bound (`interpolation->lower[i]`) is less or equal to the upper bound `interpolation->upper[i]`:
```c++
interpolation->lower[i] = std::max(static_cast<int64>(in_f), static_cast<int64>(0));
interpolation->upper[i] = std::min(static_cast<int64>(std::ceil(in)), in_size - 1);
interpolation->lower[i] = std::min(interpolation->lower[i], interpolation->upper[i]);
```
This ensures the lower bound is capped by the upper bound, preventing the out-of-bounds access.

The affected versions are < 2.5.0. Patched versions include 2.1.4, 2.2.3, 2.3.3, and 2.4.2.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage | Combined Score | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|---------------|------------|-------------------|
| 1 | CWE-190 | Integer Overflow or Wraparound | Base | Allowed | 1.1713 | dense, sparse, graph | dense: 0.554, sparse: 1.000, graph: 0.900 |
| 2 | CWE-193 | Off-by-one Error | Base | Allowed | 1.0902 | dense, sparse, graph | dense: 0.498, sparse: 1.000, graph: 0.752 |
| 3 | CWE-681 | Incorrect Conversion between Numeric Types | Base | Allowed | 1.0879 | dense, sparse, graph | dense: 0.523, sparse: 1.000, graph: 0.710 |
| 4 | CWE-1284 | Improper Validation of Specified Quantity in Input | Base | Allowed | 1.0447 | dense, sparse, graph | dense: 0.530, sparse: 1.000, graph: 0.580 |
| 5 | CWE-824 | Access of Uninitialized Pointer | Base | Allowed | 1.0397 | dense, sparse, graph | dense: 0.510, sparse: 1.000, graph: 0.594 |
| 6 | CWE-787 | Out-of-bounds Write | Base | Allowed | 0.9192 | sparse, graph | sparse: 1.000, graph: 0.971 |
| 7 | CWE-191 | Integer Underflow (Wrap or Wraparound) | Base | Allowed | 0.8250 | dense, sparse | dense: 0.505, sparse: 1.000 |
| 8 | CWE-122 | Heap-based Buffer Overflow | Variant | Allowed | 0.7802 | dense, sparse | dense: 0.546, sparse: 1.000 |
| 9 | CWE-125 | Out-of-bounds Read | Base | Allowed | 0.7674 | sparse, graph | sparse: 1.000, graph: 0.546 |
| 10 | CWE-617 | Reachable Assertion | Base | Allowed | 0.7660 | sparse, graph | sparse: 1.000, graph: 0.543 |

