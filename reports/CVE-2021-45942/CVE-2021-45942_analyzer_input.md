# Vulnerability Information: CVE-2021-45942

## Vulnerability Description
OpenEXR 3.1.x before 3.1.4 has a **heap-based buffer overflow** in Imf_3_1LineCompositeTaskexecute (called from IlmThread_3_1NullThreadPoolProvideraddTask and IlmThread_3_1ThreadPooladdGlobalTask). NOTE db217f2 may be inapplicable.

### Vulnerability Description Key Phrases
- **weakness:** **heap-based buffer overflow**
- **product:** OpenEXR
- **version:** 3.1.x before 3.1.4
- **component:** Imf_3_1LineCompositeTaskexecute

## CVE Reference Links Content Summary
Based on the provided information, here's an analysis of CVE-2021-45942:

**Root Cause of Vulnerability:**
The vulnerability is a heap-based buffer overflow that exists in the `Imf_3_1::LineCompositeTask::execute` function within the OpenEXR library. This function is responsible for compositing deep scanline images. The vulnerability occurs when the `CompositeDeepScanLine::setFrameBuffer` method doesn't properly validate the `xSampling` and `ySampling` values of the input `FrameBuffer`. Specifically it assumes these must be equal to 1.

**Weaknesses/Vulnerabilities Present:**
- Heap-based buffer overflow: The lack of proper input validation allows an attacker to provide a specially crafted EXR file where the sampling is not 1, which leads to writing data beyond the allocated buffer in `Imf_3_1::LineCompositeTask::execute`.
- Missing input validation: The `CompositeDeepScanLine::setFrameBuffer` method fails to enforce the requirement that the FrameBuffer passed to it should have xSampling and ySampling set to 1.

**Impact of Exploitation:**
- Denial of Service (DoS): The buffer overflow can lead to a crash of the application processing the crafted OpenEXR file.
- Potential Arbitrary Code Execution: While not explicitly stated, a heap-based buffer overflow can potentially lead to arbitrary code execution if exploited carefully by an attacker.

**Attack Vectors:**
- Maliciously crafted OpenEXR files: An attacker can create a specially crafted EXR image file that triggers the vulnerability when opened by a vulnerable application or library.
- The vulnerability is present when reading deep scanline images with chroma subsampling. Specifically, files that have "Y" and "BY" channels, both with sampling set to 1, and the RgbaInputFile API composites the deep data to a regular scanline image, then attempts a FromYCA conversion, which requires "BY" and "RY" have sampling set to 2.

**Required Attacker Capabilities/Position:**
- Ability to create or modify EXR files.
- The attacker needs to be able to pass this malicious file to a vulnerable application for processing. This may be achieved through various means like file uploads, or processing in a server backend.

**Additional Details:**
- The vulnerability was discovered through OSS-Fuzz, a Google project that uses fuzzing to find bugs in software.
- The fix involves adding a check in  `CompositeDeepScanLine::setFrameBuffer` method to ensure that  `xSampling` and `ySampling` are both equal to 1.
- The fix was included in OpenEXR version 3.1.4.
- The vulnerability affects applications that use OpenEXR to process deep scanline images using the RgbaInputFile API or similar functionality.
- There are reports of the fix being backported to older versions of OpenEXR (e.g. 2.5.5-6.fc34 for Fedora 34).
- A related commit,  [db217f2](https://github.com/AcademySoftwareFoundation/openexr/commit/db217f29dfb24f6b4b5100c24ac5e7490e1c57d0), addresses a similar vulnerability by improving chunk size handling in `ImfDeepScanLineInputFile.cpp`. While not directly related to CVE-2021-45942, it does highlight an additional area of concern for buffer overflow vulnerabilities when processing OpenEXR files.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage | Combined Score | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|---------------|------------|-------------------|
| 1 | CWE-125 | Out-of-bounds Read | Base | Allowed | 0.6577 | dense, sparse, graph | dense: 0.507, sparse: 0.135, graph: 0.914 |
| 2 | CWE-193 | Off-by-one Error | Base | Allowed | 0.6564 | dense, sparse, graph | dense: 0.509, sparse: 0.131, graph: 0.913 |
| 3 | CWE-190 | Integer Overflow or Wraparound | Base | Allowed | 0.6365 | dense, sparse, graph | dense: 0.563, sparse: 0.154, graph: 0.746 |
| 4 | CWE-126 | Buffer Over-read | Variant | Allowed | 0.5587 | dense, sparse, graph | dense: 0.545, sparse: 0.137, graph: 0.711 |
| 5 | CWE-122 | Heap-based Buffer Overflow | Variant | Allowed | 0.3471 | dense, sparse | dense: 0.566, sparse: 0.162 |
| 6 | CWE-170 | Improper Null Termination | Base | Allowed | 0.3458 | sparse, graph | sparse: 0.111, graph: 0.789 |
| 7 | CWE-131 | Incorrect Calculation of Buffer Size | Base | Allowed | 0.3361 | dense, sparse | dense: 0.529, sparse: 0.125 |
| 8 | CWE-124 | Buffer Underwrite ('Buffer Underflow') | Base | Allowed | 0.3255 | dense, sparse | dense: 0.519, sparse: 0.115 |
| 9 | CWE-191 | Integer Underflow (Wrap or Wraparound) | Base | Allowed | 0.3241 | dense, sparse | dense: 0.521, sparse: 0.111 |
| 10 | CWE-121 | Stack-based Buffer Overflow | Variant | Allowed | 0.3152 | dense, sparse | dense: 0.537, sparse: 0.127 |

