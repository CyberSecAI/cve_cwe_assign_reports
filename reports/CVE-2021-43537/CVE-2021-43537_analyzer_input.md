# Vulnerability Information: CVE-2021-43537

## Vulnerability Description
An **incorrect type conversion of sizes from 64bit to 32bit integers** allowed an attacker to corrupt memory leading to a potentially exploitable crash. This vulnerability affects Thunderbird < 91.4.0, Firefox ESR < 91.4.0, and Firefox < 95.

### Vulnerability Description Key Phrases
- **rootcause:** **incorrect type conversion of sizes from 64bit to 32bit integers**
- **impact:** crash
- **attacker:** attacker
- **product:** Thunderbird and Firefox ESR and Firefox
- **version:** < 91.4.0 and < 91.4.0 and < 95

## CVE Reference Links Content Summary
Based on the provided information, here's a breakdown of CVE-2021-43537:

**Root cause of vulnerability:**

- The vulnerability stems from an incorrect type conversion within the `nsStructuredCloneContainer::GetDataAsBase64` function. A 64-bit integer representing a size was being cast to a 32-bit integer without proper bounds checking. This led to an integer overflow.

**Weaknesses/vulnerabilities present:**

- **Integer overflow:** The core issue is an integer overflow when converting a 64-bit size value to a 32-bit integer.
- **Heap buffer overflow:** The integer overflow results in a smaller-than-needed buffer being allocated and subsequently written to, leading to a heap buffer overflow.
- **Memory corruption:** The overflow corrupts memory on the heap.

**Impact of exploitation:**

- **Potentially exploitable crash:** The memory corruption caused by the heap buffer overflow could lead to a crash.
- **Arbitrary code execution:** If carefully crafted, this overflow can allow for arbitrary code execution due to the memory corruption on the heap.

**Attack vectors:**

- The vulnerability can be triggered by exploiting the structured clone mechanism, which is used to serialize data in web browsers.
- The specific function `nsStructuredCloneContainer::GetDataAsBase64` is the vulnerable function.
- A crafted JavaScript can trigger the overflow.

**Required attacker capabilities/position:**

- An attacker needs to be able to execute JavaScript within the context of the vulnerable application (e.g., via a malicious website).
- The attacker needs to be able to influence the size parameters in order to cause an integer overflow when calling the structured clone API.

**Technical Details:**
- The vulnerable code is within the `nsStructuredCloneContainer::GetDataAsBase64` function. Specifically, at line marked as `#1` in the provided code, an integer `v10` of type `unsigned __int64` is converted to a 32 bit integer and passed as the length parameter to `nsTSubstring_char_::SetLength`.
```
  if ( (unsigned __int8)nsTSubstring_char_::SetLength(&v20, (unsigned int)v10, &std::nothrow) ) #1
```
- The `v10` value comes from `v8[7]`, where v8 points to a structured clone object.
- The vulnerability can be triggered by crafting a large size and passing it through structured clone, triggering the integer overflow.
- The integer overflow causes `SetLength` to allocate a smaller buffer than needed.
- Subsequently, when the application copies data using `memcpy_0`, the size value is still based on the un-truncated 64 bit value causing the overflow.
- The crash occurs inside `memcpy` because the destination buffer is smaller than the amount of data to be copied.
- The crash analysis showed the overflow happening at `VCRUNTIME140!memcpy+0x22e`

**Additional notes:**

- The bug was discovered by `bo13oy of Cyber Kunlun Lab`.
- The vulnerability is assigned `sec-high` severity in Bugzilla.
- The fix involves checking for the overflow before calling SetLength, ensuring correct buffer allocation.
- The issue is present in Firefox, Firefox ESR, and Thunderbird.
- Patches have been applied to Firefox 95, Firefox ESR 91.4, and Thunderbird 91.4.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage | Combined Score | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|---------------|------------|-------------------|
| 1 | CWE-787 | Out-of-bounds Write | Base | Allowed | 0.7303 | dense, sparse, graph | dense: 0.587, sparse: 0.266, graph: 0.796 |
| 2 | CWE-843 | Access of Resource Using Incompatible Type ('Type Confusion') | Base | Allowed | 0.7060 | dense, sparse, graph | dense: 0.511, sparse: 0.227, graph: 0.897 |
| 3 | CWE-190 | Integer Overflow or Wraparound | Base | Allowed | 0.6920 | dense, sparse, graph | dense: 0.543, sparse: 0.204, graph: 0.849 |
| 4 | CWE-125 | Out-of-bounds Read | Base | Allowed | 0.4613 | sparse, graph | sparse: 0.236, graph: 0.912 |
| 5 | CWE-124 | Buffer Underwrite ('Buffer Underflow') | Base | Allowed | 0.3839 | dense, sparse | dense: 0.514, sparse: 0.221 |
| 6 | CWE-197 | Numeric Truncation Error | Base | Allowed | 0.3705 | dense, sparse | dense: 0.504, sparse: 0.207 |
| 7 | CWE-681 | Incorrect Conversion between Numeric Types | Base | Allowed | 0.3686 | dense, sparse | dense: 0.499, sparse: 0.208 |
| 8 | CWE-416 | Use After Free | Variant | Allowed | 0.3665 | dense, sparse | dense: 0.539, sparse: 0.222 |
| 9 | CWE-457 | Use of Uninitialized Variable | Variant | Allowed | 0.3577 | sparse, graph | sparse: 0.229, graph: 0.717 |
| 10 | CWE-704 | Incorrect Type Conversion or Cast | Class | Allowed-with-Review | 0.3014 | dense, sparse | dense: 0.533, sparse: 0.431 |

