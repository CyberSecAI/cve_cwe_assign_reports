# Vulnerability Information: CVE-2020-14354

## Vulnerability Description
A possible **use-after-free and double-free** in c-ares lib version 1.16.0 if ares_destroy() is called prior to ares_getaddrinfo() completing. This flaw possibly allows an attacker to crash the service that uses c-ares lib. The highest threat from this vulnerability is to this service availability.

### Vulnerability Description Key Phrases
- **rootcause:** **use-after-free and double-free**
- **impact:** crash the service
- **attacker:** attacker
- **product:** c-ares lib
- **version:** 1.16.0

## CVE Reference Links Content Summary
Based on the provided content, here's an analysis of CVE-2020-14354:

**Verification:**

The content from multiple sources, including the Fedora bug tracker, the c-ares changelog, and a GitHub commit, directly reference CVE-2020-14354 and its description, confirming the relevance of this content.

**Vulnerability Details:**

*   **Root Cause:** A use-after-free vulnerability exists in the `ares_getaddrinfo()` function of the c-ares library when `ares_destroy()` is called before `ares_getaddrinfo()` has completed.

*   **Weaknesses/Vulnerabilities Present:**
    *   Use-after-free: The `host_callback` function might access freed memory if `ares_destroy` is called prematurely.
    *   Double-free: The `end_hquery` function could be called twice, leading to a double-free condition.

*  **Impact of Exploitation:**
    *   **Crash:** The vulnerability can cause a crash in the application using the c-ares library.
    *   **Denial of Service:** An attacker could potentially trigger this vulnerability to cause a denial-of-service by crashing the affected service.

*   **Attack Vectors:**
    *   The vulnerability is triggered by calling `ares_destroy()` while there are still pending asynchronous requests created by `ares_getaddrinfo()`.

*   **Required Attacker Capabilities/Position:**
    *   An attacker needs to be able to trigger the termination of a c-ares channel while there are pending `ares_getaddrinfo()` requests.
    *   This may be achievable via normal interaction with the service using the library.
*  **Additional Information:**
  *  The issue was introduced in c-ares version 1.16.0 with the introduction of the `ares_getaddrinfo` API and fixed in version 1.16.1.
  *  A mitigation is to ensure `wait_ares(channel)` is called before `ares_destroy()`.

**Summary of findings:**

The vulnerability lies in how c-ares handles the destruction of a channel when asynchronous address resolution requests are still pending using the new `ares_getaddrinfo` API. Specifically, if `ares_destroy()` is called before an `ares_getaddrinfo()` request completes, the callback function for the request could end up using already freed memory, and also free the memory a second time. This can lead to crashes or denial-of-service conditions. The vulnerability is fixed in c-ares 1.16.1.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage | Combined Score | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|---------------|------------|-------------------|
| 1 | CWE-415 | Double Free | Variant | Allowed | 0.8090 | dense, sparse, graph | dense: 0.528, sparse: 0.445, graph: 1.000 |
| 2 | CWE-416 | Use After Free | Variant | Allowed | 0.6748 | dense, sparse, graph | dense: 0.511, sparse: 0.263, graph: 0.909 |
| 3 | CWE-364 | Signal Handler Race Condition | Base | Allowed | 0.5169 | sparse, graph | sparse: 0.279, graph: 1.000 |
| 4 | CWE-911 | Improper Update of Reference Count | Base | Allowed | 0.4736 | sparse, graph | sparse: 0.273, graph: 0.889 |
| 5 | CWE-908 | Use of Uninitialized Resource | Base | Allowed | 0.3953 | dense, sparse | dense: 0.491, sparse: 0.261 |
| 6 | CWE-401 | Missing Release of Memory after Effective Lifetime | Variant | Allowed | 0.3873 | dense, sparse | dense: 0.500, sparse: 0.296 |
| 7 | CWE-770 | Allocation of Resources Without Limits or Throttling | Base | Allowed | 0.3726 | dense, sparse | dense: 0.480, sparse: 0.231 |
| 8 | CWE-362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | Allowed-with-Review | 0.2875 | sparse, graph | sparse: 0.286, graph: 0.911 |
| 9 | CWE-367 | Time-of-check Time-of-use (TOCTOU) Race Condition | Base | Allowed | 0.1426 | sparse | sparse: 0.249 |
| 10 | CWE-824 | Access of Uninitialized Pointer | Base | Allowed | 0.1394 | sparse | sparse: 0.244 |

