# Critic Input for CVE-2020-11279



# Original Analyzer Input
## Vulnerability Description
Memory corruption while processing crafted SDES packets due to **improper length check** in sdes packets recieved in Snapdragon Auto, Snapdragon Compute, Snapdragon Connectivity, Snapdragon Consumer IOT, Snapdragon Industrial IOT, Snapdragon IoT, Snapdragon Mobile, Snapdragon Voice & Music, Snapdragon Wearables

### Vulnerability Description Key Phrases
- **rootcause:** **improper length check**
- **weakness:** **memory corruption**
- **product:** Snapdragon Auto, Snapdragon Compute, Snapdragon Connectivity, Snapdragon Consumer IOT, Snapdragon Industrial IOT, Snapdragon IoT, Snapdragon Mobile, Snapdragon Voice & Music, Snapdragon Wearables
- **component:** sdes packets recieved

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage | Combined Score | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|---------------|------------|-------------------|
| 1 | CWE-822 | Untrusted Pointer Dereference | Base | Allowed | 0.9541 | dense, sparse, graph | dense: 0.553, sparse: 0.620, graph: 0.902 |
| 2 | CWE-823 | Use of Out-of-range Pointer Offset | Base | Allowed | 0.8754 | dense, sparse, graph | dense: 0.526, sparse: 0.597, graph: 0.757 |
| 3 | CWE-131 | Incorrect Calculation of Buffer Size | Base | Allowed | 0.8610 | dense, sparse, graph | dense: 0.553, sparse: 0.477, graph: 0.870 |
| 4 | CWE-1285 | Improper Validation of Specified Index, Position, or Offset in Input | Base | Allowed | 0.7916 | dense, sparse, graph | dense: 0.589, sparse: 0.489, graph: 0.606 |
| 5 | CWE-367 | Time-of-check Time-of-use (TOCTOU) Race Condition | Base | Allowed | 0.5968 | sparse, graph | sparse: 0.570, graph: 0.757 |
| 6 | CWE-126 | Buffer Over-read | Variant | Allowed | 0.5932 | dense, sparse | dense: 0.535, sparse: 0.656 |
| 7 | CWE-1314 | Missing Write Protection for Parametric Data Values | Base | Allowed | 0.5656 | dense, sparse | dense: 0.529, sparse: 0.526 |
| 8 | CWE-787 | Out-of-bounds Write | Base | Allowed | 0.5449 | sparse, graph | sparse: 0.459, graph: 0.789 |
| 9 | CWE-415 | Double Free | Variant | Allowed | 0.5173 | sparse, graph | sparse: 0.567, graph: 0.660 |
| 10 | CWE-413 | Improper Resource Locking | Base | Allowed | 0.5086 | dense, sparse | dense: 0.533, sparse: 0.423 |



# Analysis to Review
# Summary
| CWE ID | CWE Name | Confidence | CWE Abstraction Level | CWE Vulnerability Mapping Label | CWE-Vulnerability Mapping Notes |
|---|---|---|---|---|---|
| CWE-131 | Incorrect Calculation of Buffer Size | 0.85 | Base | Allowed | Root cause of memory corruption due to **improper length check** |
| CWE-125 | Out-of-bounds Read | 0.65 | Base | Allowed | Secondary, as a potential consequence of the incorrect buffer size calculation. |
| CWE-787 | Out-of-bounds Write | 0.65 | Base | Allowed | Secondary, as a potential consequence of the incorrect buffer size calculation. |

## Evidence and Confidence

*   **Confidence Score:** 0.75
*   **Evidence Strength:** MEDIUM

- **Analysis and Justification:**  
  - *Explanation:* The vulnerability description states "**Memory corruption** while processing crafted SDES packets due to **improper length check** in sdes packets". This clearly indicates an issue with how the length of the SDES packets is being handled, leading to memory corruption. CWE-131 (Incorrect Calculation of Buffer Size) directly addresses the root cause of "**improper length check**" that leads to **memory corruption**. The retriever results also support this, with CWE-131 having a high combined score. It is a base level CWE and the Usage is Allowed.
  CWE-125 (Out-of-bounds Read) and CWE-787 (Out-of-bounds Write) are included as secondary CWEs because **improper length check** can lead to reading or writing beyond the allocated buffer, causing memory corruption.

  - *Relationship Analysis:* CWE-131 can lead to memory corruption, which is the high level symptom. CWE-125 (Out-of-bounds Read) and CWE-787 (Out-of-bounds Write) are potential impacts resulting from the incorrect buffer size calculation. CWE-131 is a child of CWE-682 (Incorrect Calculation).

- **Confidence Score:**  
  - Confidence: 0.85 (High confidence due to clear description of **improper length check** leading to **memory corruption**, aligning well with CWE-131.
  - Confidence: 0.65 for CWE-125 and CWE-787 as secondary issues due to the possibility of reading or writing beyond buffer limits.

---

# CWE Examples from Database


## Known Examples for CWE-125: Out-of-bounds Read
### Observed Examples
- **CVE-2023-1018** [https://www.cve.org/CVERecord?id=CVE-2023-1018](https://www.cve.org/CVERecord?id=CVE-2023-1018): The reference implementation code for a Trusted Platform Module does not implement length checks on data, allowing for an attacker to read 2 bytes past the end of a buffer.
- **CVE-2020-11899** [https://www.cve.org/CVERecord?id=CVE-2020-11899](https://www.cve.org/CVERecord?id=CVE-2020-11899): Out-of-bounds read in IP stack used in embedded systems, as exploited in the wild per CISA KEV.
- **CVE-2014-0160** [https://www.cve.org/CVERecord?id=CVE-2014-0160](https://www.cve.org/CVERecord?id=CVE-2014-0160): Chain: "Heartbleed" bug receives an inconsistent length parameter (CWE-130) enabling an out-of-bounds read (CWE-126), returning memory that could include private cryptographic keys and other sensitive data.
- **CVE-2021-40985** [https://www.cve.org/CVERecord?id=CVE-2021-40985](https://www.cve.org/CVERecord?id=CVE-2021-40985): HTML conversion package has a buffer under-read, allowing a crash
- **CVE-2018-10887** [https://www.cve.org/CVERecord?id=CVE-2018-10887](https://www.cve.org/CVERecord?id=CVE-2018-10887): Chain: unexpected sign extension (CWE-194) leads to integer overflow (CWE-190), causing an out-of-bounds read (CWE-125)
- **CVE-2009-2523** [https://www.cve.org/CVERecord?id=CVE-2009-2523](https://www.cve.org/CVERecord?id=CVE-2009-2523): Chain: product does not handle when an input string is not NULL terminated (CWE-170), leading to buffer over-read (CWE-125) or heap-based buffer overflow (CWE-122).
- **CVE-2018-16069** [https://www.cve.org/CVERecord?id=CVE-2018-16069](https://www.cve.org/CVERecord?id=CVE-2018-16069): Chain: series of floating-point precision errors (CWE-1339) in a web browser rendering engine causes out-of-bounds read (CWE-125), giving access to cross-origin data
- **CVE-2004-0112** [https://www.cve.org/CVERecord?id=CVE-2004-0112](https://www.cve.org/CVERecord?id=CVE-2004-0112): out-of-bounds read due to improper length check
- **CVE-2004-0183** [https://www.cve.org/CVERecord?id=CVE-2004-0183](https://www.cve.org/CVERecord?id=CVE-2004-0183): packet with large number of specified elements cause out-of-bounds read.
- **CVE-2004-0221** [https://www.cve.org/CVERecord?id=CVE-2004-0221](https://www.cve.org/CVERecord?id=CVE-2004-0221): packet with large number of specified elements cause out-of-bounds read.


# Relevant CWE Specifications

## CWE-125: Out-of-bounds Read
**Abstraction:** Base
**Status:** Draft

### Description
The product reads data past the end, or before the beginning, of the intended buffer.

### Extended Description
Not provided

### Alternative Terms
OOB read: Shorthand for "Out of bounds" read

### Relationships
ChildOf -> CWE-119
ChildOf -> CWE-119
ChildOf -> CWE-119
ChildOf -> CWE-119
ParentOf -> CWE-126
ParentOf -> CWE-127
CanFollow -> CWE-822
CanFollow -> CWE-823
CanFollow -> CWE-824
CanFollow -> CWE-825

### Mapping Guidance
**Usage:** Allowed
**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.
**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.
**Reasons:**
- Acceptable-Use


### Potential Mitigations
**Mitigation 1:**
- **Phase:** Implementation
- **Strategy:** Input Validation
- **Description:** 

Assume all input is malicious. Use an "accept known good" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.


When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, "boat" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as "red" or "blue."


Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.


To reduce the likelihood of introducing an out-of-bounds read, ensure that you validate and ensure correct calculations for any length argument, buffer size calculation, or offset. Be especially careful of relying on a sentinel (i.e. special character such as NUL) in untrusted inputs.


**Mitigation 2:**
- **Phase:** Architecture and Design
- **Strategy:** Language Selection
- **Description:** Use a language that provides appropriate memory abstractions.




### Observed Examples
- **CVE-2023-1018:** The reference implementation code for a Trusted Platform Module does not implement length checks on data, allowing for an attacker to read 2 bytes past the end of a buffer.
- **CVE-2020-11899:** Out-of-bounds read in IP stack used in embedded systems, as exploited in the wild per CISA KEV.
- **CVE-2014-0160:** Chain: "Heartbleed" bug receives an inconsistent length parameter (CWE-130) enabling an out-of-bounds read (CWE-126), returning memory that could include private cryptographic keys and other sensitive data.



## CWE-682: Incorrect Calculation
**Abstraction:** Pillar
**Status:** Draft

### Description
The product performs a calculation that generates incorrect or unintended results that are later used in security-critical decisions or resource management.

### Extended Description
When product performs a security-critical calculation incorrectly, it might lead to incorrect resource allocations, incorrect privilege assignments, or failed comparisons among other things. Many of the direct results of an incorrect calculation can lead to even larger problems such as failed protection mechanisms or even arbitrary code execution.

### Alternative Terms
None

### Relationships
CanPrecede -> CWE-170
ParentOf -> CWE-128
ParentOf -> CWE-131
ParentOf -> CWE-1335
ParentOf -> CWE-1339
ParentOf -> CWE-135
ParentOf -> CWE-190
ParentOf -> CWE-191
ParentOf -> CWE-193
ParentOf -> CWE-369
ParentOf -> CWE-468
ParentOf -> CWE-469
CanFollow -> CWE-681
CanFollow -> CWE-839

### Mapping Guidance
**Usage:** Discouraged
**Rationale:** This CWE entry is extremely high-level, a Pillar. In many cases, lower-level children or descendants are more appropriate. However, sometimes this weakness is forced to be used due to the lack of in-depth weakness research. See Research Gaps.
**Comments:** Where feasible, consider children or descendants of this entry instead.
**Reasons:**
- Abstraction


### Potential Mitigations
**Mitigation 1:**
- **Phase:** Implementation
- **Description:** Understand your programming language's underlying representation and how it interacts with numeric calculation. Pay close attention to byte size discrepancies, precision, signed/unsigned distinctions, truncation, conversion and casting between types, "not-a-number" calculations, and how your language handles numbers that are too large or too small for its underlying representation.

**Mitigation 2:**
- **Phase:** Implementation
- **Strategy:** Input Validation
- **Description:** Perform input validation on any numeric input by ensuring that it is within the expected range. Enforce that the input meets both the minimum and maximum requirements for the expected range.

**Mitigation 3:**
- **Phase:** Implementation
- **Description:** Use the appropriate type for the desired action. For example, in C/C++, only use unsigned types for values that could never be negative, such as height, width, or other numbers related to quantity.



### Additional Notes
**[Research Gap]** 

Weaknesses related to this Pillar appear to be under-studied, especially with respect to classification schemes. Input from academic and other communities could help identify and resolve gaps or organizational difficulties within CWE.




### Observed Examples
- **CVE-2020-0022:** chain: mobile phone Bluetooth implementation does not include offset when calculating packet length (CWE-682), leading to out-of-bounds write (CWE-787)
- **CVE-2004-1363:** substitution overflow: buffer overflow using environment variables that are expanded after the length check is performed



## CWE-787: Out-of-bounds Write
**Abstraction:** Base
**Status:** Draft

### Description
The product writes data past the end, or before the beginning, of the intended buffer.

### Extended Description
Not provided

### Alternative Terms
Memory Corruption: Often used to describe the consequences of writing to memory outside the bounds of a buffer, or to memory that is otherwise invalid.

### Relationships
ChildOf -> CWE-119
ChildOf -> CWE-119
ChildOf -> CWE-119
ChildOf -> CWE-119
ParentOf -> CWE-121
ParentOf -> CWE-122
ParentOf -> CWE-123
ParentOf -> CWE-124
CanFollow -> CWE-822
CanFollow -> CWE-823
CanFollow -> CWE-824
CanFollow -> CWE-825

### Mapping Guidance
**Usage:** Allowed
**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.
**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.
**Reasons:**
- Acceptable-Use


### Potential Mitigations
**Mitigation 1:**
- **Phase:** Requirements
- **Strategy:** Language Selection
- **Description:** 

Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.


For example, many languages that perform their own memory management, such as Java and Perl, are not subject to buffer overflows. Other languages, such as Ada and C#, typically provide overflow protection, but the protection can be disabled by the programmer.


Be wary that a language's interface to native code may still be subject to overflows, even if the language itself is theoretically safe.


**Mitigation 2:**
- **Phase:** Architecture and Design
- **Strategy:** Libraries or Frameworks
- **Description:** 

Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.


Examples include the Safe C String Library (SafeStr) by Messier and Viega [REF-57], and the Strsafe.h library from Microsoft [REF-56]. These libraries provide safer versions of overflow-prone string-handling functions.


**Mitigation 3:**
- **Phase:** Operation, Build and Compilation
- **Effectiveness:** Defense in Depth
- **Strategy:** Environment Hardening
- **Description:** 

Use automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking. 


 D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail. 





### Observed Examples
- **CVE-2023-1017:** The reference implementation code for a Trusted Platform Module does not implement length checks on data, allowing for an attacker to write 2 bytes past the end of a buffer.
- **CVE-2021-21220:** Chain: insufficient input validation (CWE-20) in browser allows heap corruption (CWE-787), as exploited in the wild per CISA KEV.
- **CVE-2021-28664:** GPU kernel driver allows memory corruption because a user can obtain read/write access to read-only pages, as exploited in the wild per CISA KEV.



## CWE-131: Incorrect Calculation of Buffer Size
**Abstraction:** Base
**Status:** Draft

### Description
The product does not correctly calculate the size to be used when allocating a buffer, which could lead to a buffer overflow.

### Extended Description
Not provided

### Alternative Terms
None

### Relationships
ChildOf -> CWE-682
ChildOf -> CWE-682
ChildOf -> CWE-682
ChildOf -> CWE-682
CanPrecede -> CWE-119
ParentOf -> CWE-467

### Mapping Guidance
**Usage:** Allowed
**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.
**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.
**Reasons:**
- Acceptable-Use


### Potential Mitigations
**Mitigation 1:**
- **Phase:** Implementation
- **Description:** When allocating a buffer for the purpose of transforming, converting, or encoding an input, allocate enough memory to handle the largest possible encoding. For example, in a routine that converts "&" characters to "&amp;" for HTML entity encoding, the output buffer needs to be at least 5 times as large as the input buffer.

**Mitigation 2:**
- **Phase:** Implementation
- **Description:** 

Understand the programming language's underlying representation and how it interacts with numeric calculation (CWE-681). Pay close attention to byte size discrepancies, precision, signed/unsigned distinctions, truncation, conversion and casting between types, "not-a-number" calculations, and how the language handles numbers that are too large or too small for its underlying representation. [REF-7]


Also be careful to account for 32-bit, 64-bit, and other potential differences that may affect the numeric representation.


**Mitigation 3:**
- **Phase:** Implementation
- **Strategy:** Input Validation
- **Description:** Perform input validation on any numeric input by ensuring that it is within the expected range. Enforce that the input meets both the minimum and maximum requirements for the expected range.



### Additional Notes
**[Maintenance]** 

This is a broad category. Some examples include:


  - simple math errors,

  - incorrectly updating parallel counters,

  - not accounting for size differences when "transforming" one input to another format (e.g. URL canonicalization or other transformation that can generate a result that's larger than the original input, i.e. "expansion").

This level of detail is rarely available in public reports, so it is difficult to find good examples.

**[Maintenance]** 

This weakness may be a composite or a chain. It also may contain layering or perspective differences.


This issue may be associated with many different types of incorrect calculations (CWE-682), although the integer overflow (CWE-190) is probably the most prevalent. This can be primary to resource consumption problems (CWE-400), including uncontrolled memory allocation (CWE-789). However, its relationship with out-of-bounds buffer access (CWE-119) must also be considered.




### Observed Examples
- **CVE-2020-17087:** Chain: integer truncation (CWE-197) causes small buffer allocation (CWE-131) leading to out-of-bounds write (CWE-787) in kernel pool, as exploited in the wild per CISA KEV.
- **CVE-2004-1363:** substitution overflow: buffer overflow using environment variables that are expanded after the length check is performed
- **CVE-2004-0747:** substitution overflow: buffer overflow using expansion of environment variables

