# Critic Input for CVE-2021-31933



# Original Analyzer Input
## Vulnerability Description
A remote code execution vulnerability exists in Chamilo through 1.11.14 due to **improper input sanitization** of a parameter used for file uploads, and improper file-extension filtering for certain filenames (e.g., .phar or .pht). A remote authenticated administrator is able to upload a file containing arbitrary PHP code into specific directories via main/inc/lib/fileUpload.lib.php directory traversal to achieve PHP code execution.

### Vulnerability Description Key Phrases
- **rootcause:** **improper input sanitization**
- **impact:** remote code execution
- **vector:** directory traversal
- **attacker:** remote authenticated administrator
- **product:** Chamilo
- **version:** through 1.11.14
- **component:** main/inc/lib/fileUpload.lib.php

## CVE Reference Links Content Summary
Based on the provided content, here's a breakdown of the security vulnerability addressed in the commits, which seems to correspond to CVE-2021-31933:

**Root Cause of Vulnerability:**

- The primary issue was the ability to execute PHP code within the `web/` directory, posing a significant security risk. This was due to insufficient restrictions on where PHP files could be executed, allowing for potential arbitrary code execution.
- Additionally, an unused upload form (`/main/upload/upload.document.php`) was present which could be a vulnerability if accessed.
- Uploaded files were not sufficiently validated which could lead to malicious code execution or path traversal vulnerabilities.

**Weaknesses/Vulnerabilities Present:**

- **Arbitrary Code Execution:** The most critical weakness was the lack of restrictions on PHP execution within the `web/` directory. An attacker could potentially upload a malicious PHP file and execute arbitrary code on the server.
- **Insecure File Upload:** The file upload functionality lacked proper validation of the destination path, which could lead to path traversal attacks, allowing attackers to write files outside the intended directory.
- **Unused functionality:** Presence of unused upload form at `/main/upload/upload.document.php` could be a potential vulnerability.
- **Missing checks:** Lack of API access control and user validations could be abused by attackers.

**Impact of Exploitation:**

- **Full System Compromise:** By exploiting the arbitrary code execution vulnerability, an attacker could gain complete control of the web server, leading to data breaches, defacement, and other malicious activities.
- **Data Manipulation:** Successful exploitation could allow attackers to modify or delete sensitive data stored within the application.
- **Denial of Service:** Attackers could potentially cause a denial of service by overloading the server with malicious requests or by corrupting system files.

**Attack Vectors:**

- **Malicious File Upload:** An attacker could upload a specially crafted PHP file to a vulnerable directory (e.g. under web/) and gain arbitrary code execution.
- **Path Traversal:** By manipulating the upload path, attackers could potentially save malicious files to arbitrary locations outside the course directory.
- **Direct access to unused script:** By directly accessing `/main/upload/upload.document.php` an attacker could potentially use the file upload form.

**Required Attacker Capabilities/Position:**

- **Web Access:** The attacker needs to have network access to the Chamilo instance.
- **Upload Capabilities:** The attacker needs to be able to upload files using the application's upload functionality.
- **Knowledge of Vulnerable Areas:** The attacker needs to be aware of the vulnerable directories or files where PHP execution is possible.

**Mitigation/Fixes (from commit `f65d065`):**

- **.htaccess Update:** The `.htaccess` file was updated to disallow PHP execution within the `web/` directory. Previously, it only blocked PHP in `web/css`.
- **Unused upload form disabled:** The unused upload form `/main/upload/upload.document.php` was disabled by adding an `exit;` at the beginning of the script.
- **`phar` extension added:** The `php2phps()` function was updated to include the `phar` extension.
- **Path Validation:** Added `Security::check_abs_path` to ensure that the destination path for file uploads is within the allowed course directory.
- **API Protection:** Introduced the `api_protect_course_script()` function to add API access controls.
- **User Validation:** Added course/user validations to prevent unauthorized access.

**Additional Details:**

- The commit `2293021` included a modification of the `.htaccess` file, disallowing PHP execution inside the web/ folder, but this was only part of the fix.
- The commit `f65d065` included multiple fixes as described above which addressed multiple attack vectors.
- The provided documentation also mentions a "Secure Development Policy" which may have been violated.

In summary, the vulnerability stemmed from insufficient restrictions on PHP file execution and insecure file uploads within the Chamilo LMS. The fix involved updating `.htaccess` rules, disabling an unused upload script, adding path validation checks, and implementing API protection.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage | Combined Score | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|---------------|------------|-------------------|
| 1 | CWE-79 | Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting') | Base | Allowed | 0.7705 | dense, sparse, graph | dense: 0.588, sparse: 0.258, graph: 0.920 |
| 2 | CWE-22 | Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal') | Base | Allowed | 0.7653 | dense, sparse, graph | dense: 0.545, sparse: 0.290, graph: 0.914 |
| 3 | CWE-434 | Unrestricted Upload of File with Dangerous Type | Base | Allowed | 0.7587 | dense, sparse, graph | dense: 0.634, sparse: 0.316, graph: 0.729 |
| 4 | CWE-96 | Improper Neutralization of Directives in Statically Saved Code ('Static Code Injection') | Base | Allowed | 0.6553 | dense, sparse, graph | dense: 0.639, sparse: 0.242, graph: 0.551 |
| 5 | CWE-94 | Improper Control of Generation of Code ('Code Injection') | Base | Allowed-with-Review | 0.5757 | dense, sparse, graph | dense: 0.553, sparse: 0.267, graph: 0.485 |
| 6 | CWE-646 | Reliance on File Name or Extension of Externally-Supplied File | Variant | Allowed | 0.5738 | dense, sparse | dense: 0.655, sparse: 0.514 |
| 7 | CWE-23 | Relative Path Traversal | Base | Allowed | 0.4801 | sparse, graph | sparse: 0.288, graph: 0.882 |
| 8 | CWE-1336 | Improper Neutralization of Special Elements Used in a Template Engine | Base | Allowed | 0.4291 | dense, sparse | dense: 0.575, sparse: 0.247 |
| 9 | CWE-89 | Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection') | Base | Allowed | 0.4220 | dense, sparse | dense: 0.571, sparse: 0.239 |
| 10 | CWE-502 | Deserialization of Untrusted Data | Base | Allowed | 0.4181 | dense, sparse | dense: 0.558, sparse: 0.242 |



# Analysis to Review
# Summary
| CWE ID | CWE Name | Confidence | CWE Abstraction Level | CWE Vulnerability Mapping Label | CWE-Vulnerability Mapping Notes |
|---|---|---|---|---|---|
| CWE-434 | Unrestricted Upload of File with Dangerous Type | 0.95 | Base | Allowed | Primary CWE |
| CWE-22 | Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal') | 0.85 | Base | Allowed | Secondary Candidate |
| CWE-94 | Improper Control of Generation of Code ('Code Injection') | 0.75 | Base | Allowed-with-Review | Secondary Candidate |

## Evidence and Confidence

*   **Confidence Score:** 0.9
*   **Evidence Strength:** HIGH

- **Analysis and Justification:**
  - *Explanation:* The primary weakness is the **unrestricted upload of a file with a dangerous type** (CWE-434). The vulnerability description states that there is **improper input sanitization** of a parameter used for file uploads and **improper file-extension filtering**, which allows an authenticated administrator to upload a file containing arbitrary PHP code. The "CVE Reference Links Content Summary" confirms this, mentioning that uploaded files were not sufficiently validated, potentially leading to malicious code execution. This aligns perfectly with CWE-434, which describes allowing the upload of dangerous file types that are automatically processed. The usage is ALLOWED, and it's a Base level of abstraction, as preferred.

  - *Relationship Analysis:* The vulnerability also involves **path traversal** (CWE-22), as the administrator can upload the file into specific directories via directory traversal. Additionally, the ability to upload arbitrary PHP code directly relates to **code injection** (CWE-94). CWE-434 can precede weaknesses like CWE-73 (External Control of File Name or Path), as an attacker might control the filename and path to exploit other vulnerabilities after the file upload.

- **Confidence Score:**
  - Confidence: 0.95 (Strong evidence from the vulnerability description and CVE reference materials directly supports CWE-434 as the primary weakness).

---
- **Analysis and Justification:**
  - *Explanation:* The vulnerability description mentions directory traversal to achieve PHP code execution. The "CVE Reference Links Content Summary" also specifies that the file upload functionality lacked proper validation of the destination path, which could lead to path traversal attacks (CWE-22), allowing attackers to write files outside the intended directory. This directly aligns with the description of CWE-22, which involves using external input to construct a pathname outside of a restricted directory. The "Mitigation/Fixes" section mentions that path validation was added using `Security::check_abs_path`.
  - *Relationship Analysis:* CWE-22 is related to other path-related weaknesses like CWE-23 (Relative Path Traversal). It can precede weaknesses such as CWE-73 (External Control of File Name or Path), where control over the file path can lead to further exploitation.

- **Confidence Score:**
  - Confidence: 0.85 (The evidence supports CWE-22 as a secondary contributing factor, although the primary issue is the dangerous file upload).
---
- **Analysis and Justification:**
  - *Explanation:* The vulnerability allows for the upload of arbitrary PHP code, which, when executed, leads to code injection (CWE-94). The "CVE Reference Links Content Summary" highlights the arbitrary code execution weakness and the ability to upload malicious PHP files. While the root cause is **improper input sanitization** and **improper file-extension filtering**, the end result is the execution of injected code.
  - *Relationship Analysis:* CWE-94 is a parent of CWE-95 (Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')) and CWE-96 (Improper Neutralization of Directives in Statically Saved Code ('Static Code Injection')). In this case, the injected code is statically saved, making CWE-96 a more specific variant but the initial injection point begins with code injection. The MITRE mapping guidance for CWE-94 suggests reviewing the usage, as it's frequently misused. In this case, the vulnerability leads to code execution, and since we identified the root cause as CWE-434 and CWE-22, CWE-94 should be considered as a contributing factor.

- **Confidence Score:**
  - Confidence: 0.75 (The evidence supports CWE-94 as a consequence of the initial vulnerability related to unrestricted file upload.)

# CWE Examples from Database


## Known Examples for CWE-434: Unrestricted Upload of File with Dangerous Type
### Observed Examples
- **CVE-2023-5227** [https://www.cve.org/CVERecord?id=CVE-2023-5227](https://www.cve.org/CVERecord?id=CVE-2023-5227): PHP-based FAQ management app does not check the MIME type for uploaded images
- **CVE-2001-0901** [https://www.cve.org/CVERecord?id=CVE-2001-0901](https://www.cve.org/CVERecord?id=CVE-2001-0901): Web-based mail product stores ".shtml" attachments that could contain SSI
- **CVE-2002-1841** [https://www.cve.org/CVERecord?id=CVE-2002-1841](https://www.cve.org/CVERecord?id=CVE-2002-1841): PHP upload does not restrict file types
- **CVE-2005-1868** [https://www.cve.org/CVERecord?id=CVE-2005-1868](https://www.cve.org/CVERecord?id=CVE-2005-1868): upload and execution of .php file
- **CVE-2005-1881** [https://www.cve.org/CVERecord?id=CVE-2005-1881](https://www.cve.org/CVERecord?id=CVE-2005-1881): upload file with dangerous extension
- **CVE-2005-0254** [https://www.cve.org/CVERecord?id=CVE-2005-0254](https://www.cve.org/CVERecord?id=CVE-2005-0254): program does not restrict file types
- **CVE-2004-2262** [https://www.cve.org/CVERecord?id=CVE-2004-2262](https://www.cve.org/CVERecord?id=CVE-2004-2262): improper type checking of uploaded files
- **CVE-2006-4558** [https://www.cve.org/CVERecord?id=CVE-2006-4558](https://www.cve.org/CVERecord?id=CVE-2006-4558): Double "php" extension leaves an active php extension in the generated filename.
- **CVE-2006-6994** [https://www.cve.org/CVERecord?id=CVE-2006-6994](https://www.cve.org/CVERecord?id=CVE-2006-6994): ASP program allows upload of .asp files by bypassing client-side checks
- **CVE-2005-3288** [https://www.cve.org/CVERecord?id=CVE-2005-3288](https://www.cve.org/CVERecord?id=CVE-2005-3288): ASP file upload


# Relevant CWE Specifications

## CWE-434: Unrestricted Upload of File with Dangerous Type
**Abstraction:** Base
**Status:** Draft

### Description
The product allows the upload or transfer of dangerous file types that are automatically processed within its environment.

### Extended Description
Not provided

### Alternative Terms
Unrestricted File Upload: Used in vulnerability databases and elsewhere, but it is insufficiently precise. The phrase could be interpreted as the lack of restrictions on the size or number of uploaded files, which is a resource consumption issue.

### Relationships
ChildOf -> CWE-669
ChildOf -> CWE-669
PeerOf -> CWE-351
PeerOf -> CWE-436
PeerOf -> CWE-430
CanFollow -> CWE-183
CanFollow -> CWE-184
CanFollow -> CWE-73

### Mapping Guidance
**Usage:** Allowed
**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.
**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.
**Reasons:**
- Acceptable-Use


### Potential Mitigations
**Mitigation 1:**
- **Phase:** Architecture and Design
- **Description:** Generate a new, unique filename for an uploaded file instead of using the user-supplied filename, so that no external input is used at all.[REF-422] [REF-423]

**Mitigation 2:**
- **Phase:** Architecture and Design
- **Strategy:** Enforcement by Conversion
- **Description:** When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.

**Mitigation 3:**
- **Phase:** Architecture and Design
- **Description:** Consider storing the uploaded files outside of the web document root entirely. Then, use other mechanisms to deliver the files dynamically. [REF-423]



### Additional Notes
**[Relationship]** 

This can have a chaining relationship with incomplete denylist / permissive allowlist errors when the product tries, but fails, to properly limit which types of files are allowed (CWE-183, CWE-184).


This can also overlap multiple interpretation errors for intermediaries, e.g. anti-virus products that do not remove or quarantine attachments with certain file extensions that can be processed by client systems.




### Observed Examples
- **CVE-2023-5227:** PHP-based FAQ management app does not check the MIME type for uploaded images
- **CVE-2001-0901:** Web-based mail product stores ".shtml" attachments that could contain SSI
- **CVE-2002-1841:** PHP upload does not restrict file types



## CWE-23: Relative Path Traversal
**Abstraction:** Base
**Status:** Draft

### Description
The product uses external input to construct a pathname that should be within a restricted directory, but it does not properly neutralize sequences such as ".." that can resolve to a location that is outside of that directory.

### Extended Description
This allows attackers to traverse the file system to access files or directories that are outside of the restricted directory.

### Alternative Terms
Zip Slip: "Zip slip" is an attack that uses file archives (e.g., ZIP, tar, rar, etc.) that contain filenames with path traversal sequences that cause the files to be written outside of the directory under which the archive is expected to be extracted [REF-1282]. It is most commonly used for relative path traversal (CWE-23) and link following (CWE-59).

### Relationships
ChildOf -> CWE-22
ChildOf -> CWE-22
ChildOf -> CWE-22
ParentOf -> CWE-24
ParentOf -> CWE-25
ParentOf -> CWE-26
ParentOf -> CWE-27
ParentOf -> CWE-28
ParentOf -> CWE-29
ParentOf -> CWE-30
ParentOf -> CWE-31
ParentOf -> CWE-32
ParentOf -> CWE-33
ParentOf -> CWE-34
ParentOf -> CWE-35

### Mapping Guidance
**Usage:** Allowed
**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.
**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.
**Reasons:**
- Acceptable-Use


### Potential Mitigations
**Mitigation 1:**
- **Phase:** Implementation
- **Strategy:** Input Validation
- **Description:** 

Assume all input is malicious. Use an "accept known good" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.


When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, "boat" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as "red" or "blue."


Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.


When validating filenames, use stringent allowlists that limit the character set to be used. If feasible, only allow a single "." character in the filename to avoid weaknesses such as CWE-23, and exclude directory separators such as "/" to avoid CWE-36. Use a list of allowable file extensions, which will help to avoid CWE-434.


Do not rely exclusively on a filtering mechanism that removes potentially dangerous characters. This is equivalent to a denylist, which may be incomplete (CWE-184). For example, filtering "/" is insufficient protection if the filesystem also supports the use of "\" as a directory separator. Another possible error could occur when the filtering is applied in a way that still produces dangerous data (CWE-182). For example, if "../" sequences are removed from the ".../...//" string in a sequential fashion, two instances of "../" would be removed from the original string, but the remaining characters would still form the "../" string.


**Mitigation 2:**
- **Phase:** Implementation
- **Strategy:** Input Validation
- **Description:** 

Inputs should be decoded and canonicalized to the application's current internal representation before being validated (CWE-180). Make sure that the application does not decode the same input twice (CWE-174). Such errors could be used to bypass allowlist validation schemes by introducing dangerous inputs after they have been checked.


Use a built-in path canonicalization function (such as realpath() in C) that produces the canonical version of the pathname, which effectively removes ".." sequences and symbolic links (CWE-23, CWE-59). This includes:


  - realpath() in C

  - getCanonicalPath() in Java

  - GetFullPath() in ASP.NET

  - realpath() or abs_path() in Perl

  - realpath() in PHP






### Observed Examples
- **CVE-2024-37032:** Large language model (LLM) management tool does not validate the format of a digest value (CWE-1287) from a private, untrusted model registry, enabling relative path traversal (CWE-23), a.k.a. Probllama
- **CVE-2022-45918:** Chain: a learning management tool debugger uses external input to locate previous session logs (CWE-73) and does not properly validate the given path (CWE-20), allowing for filesystem path traversal using "../" sequences (CWE-24)
- **CVE-2019-20916:** Python package manager does not correctly restrict the filename specified in a Content-Disposition header, allowing arbitrary file read using path traversal sequences such as "../"



## CWE-73: External Control of File Name or Path
**Abstraction:** Base
**Status:** Draft

### Description
The product allows user input to control or influence paths or file names that are used in filesystem operations.

### Extended Description


This could allow an attacker to access or modify system files or other files that are critical to the application.


Path manipulation errors occur when the following two conditions are met:

```
		1. An attacker can specify a path used in an operation on the filesystem.
		2. By specifying the resource, the attacker gains a capability that would not otherwise be permitted.
```
For example, the program may give the attacker the ability to overwrite the specified file or run with a configuration controlled by the attacker.

### Alternative Terms
None

### Relationships
ChildOf -> CWE-642
ChildOf -> CWE-610
ChildOf -> CWE-20
CanPrecede -> CWE-22
CanPrecede -> CWE-41
CanPrecede -> CWE-98
CanPrecede -> CWE-434
CanPrecede -> CWE-59
ParentOf -> CWE-114

### Mapping Guidance
**Usage:** Allowed
**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.
**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.
**Reasons:**
- Acceptable-Use


### Potential Mitigations
**Mitigation 1:**
- **Phase:** Architecture and Design
- **Description:** When the set of filenames is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames, and reject all other inputs. For example, ID 1 could map to "inbox.txt" and ID 2 could map to "profile.txt". Features such as the ESAPI AccessReferenceMap provide this capability.

**Mitigation 2:**
- **Phase:** Architecture and Design, Operation
- **Description:** 

Run your code in a "jail" or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict all access to files within a particular directory.


Examples include the Unix chroot jail and AppArmor. In general, managed code may provide some protection.


This may not be a feasible solution, and it only limits the impact to the operating system; the rest of your application may still be subject to compromise.


Be careful to avoid CWE-243 and other weaknesses related to jails.


**Mitigation 3:**
- **Phase:** Architecture and Design
- **Description:** For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.



### Additional Notes
**[Maintenance]** CWE-114 is a Class, but it is listed a child of CWE-73 in view 1000. This suggests some abstraction problems that should be resolved in future versions.

**[Relationship]** 

The external control of filenames can be the primary link in chains with other file-related weaknesses, as seen in the CanPrecede relationships. This is because software systems use files for many different purposes: to execute programs, load code libraries, to store application data, to store configuration settings, record temporary data, act as signals or semaphores to other processes, etc.


However, those weaknesses do not always require external control. For example, link-following weaknesses (CWE-59) often involve pathnames that are not controllable by the attacker at all.


The external control can be resultant from other issues. For example, in PHP applications, the register_globals setting can allow an attacker to modify variables that the programmer thought were immutable, enabling file inclusion (CWE-98) and path traversal (CWE-22). Operating with excessive privileges (CWE-250) might allow an attacker to specify an input filename that is not directly readable by the attacker, but is accessible to the privileged program. A buffer overflow (CWE-119) might give an attacker control over nearby memory locations that are related to pathnames, but were not directly modifiable by the attacker.




### Observed Examples
- **CVE-2022-45918:** Chain: a learning management tool debugger uses external input to locate previous session logs (CWE-73) and does not properly validate the given path (CWE-20), allowing for filesystem path traversal using "../" sequences (CWE-24)
- **CVE-2008-5748:** Chain: external control of values for user's desired language and theme enables path traversal.
- **CVE-2008-5764:** Chain: external control of user's target language enables remote file inclusion.



## CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')
**Abstraction:** Base
**Status:** Stable

### Description
The product uses external input to construct a pathname that is intended to identify a file or directory that is located underneath a restricted parent directory, but the product does not properly neutralize special elements within the pathname that can cause the pathname to resolve to a location that is outside of the restricted directory.

### Extended Description


Many file operations are intended to take place within a restricted directory. By using special elements such as ".." and "/" separators, attackers can escape outside of the restricted location to access files or directories that are elsewhere on the system. One of the most common special elements is the "../" sequence, which in most modern operating systems is interpreted as the parent directory of the current location. This is referred to as relative path traversal. Path traversal also covers the use of absolute pathnames such as "/usr/local/bin" to access unexpected files. This is referred to as absolute path traversal.


### Alternative Terms
Directory traversal
Path traversal: "Path traversal" is preferred over "directory traversal," but both terms are attack-focused.

### Relationships
ChildOf -> CWE-706
ChildOf -> CWE-706
ChildOf -> CWE-668
CanFollow -> CWE-172
CanFollow -> CWE-20
ParentOf -> CWE-23
ParentOf -> CWE-36
CanFollow -> CWE-73

### Mapping Guidance
**Usage:** Allowed
**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.
**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.
**Reasons:**
- Acceptable-Use


### Potential Mitigations
**Mitigation 1:**
- **Phase:** Implementation
- **Strategy:** Input Validation
- **Description:** 

Assume all input is malicious. Use an "accept known good" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.


When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, "boat" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as "red" or "blue."


Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.


When validating filenames, use stringent allowlists that limit the character set to be used. If feasible, only allow a single "." character in the filename to avoid weaknesses such as CWE-23, and exclude directory separators such as "/" to avoid CWE-36. Use a list of allowable file extensions, which will help to avoid CWE-434.


Do not rely exclusively on a filtering mechanism that removes potentially dangerous characters. This is equivalent to a denylist, which may be incomplete (CWE-184). For example, filtering "/" is insufficient protection if the filesystem also supports the use of "\" as a directory separator. Another possible error could occur when the filtering is applied in a way that still produces dangerous data (CWE-182). For example, if "../" sequences are removed from the ".../...//" string in a sequential fashion, two instances of "../" would be removed from the original string, but the remaining characters would still form the "../" string.


**Mitigation 2:**
- **Phase:** Architecture and Design
- **Description:** For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.

**Mitigation 3:**
- **Phase:** Implementation
- **Strategy:** Input Validation
- **Description:** 

Inputs should be decoded and canonicalized to the application's current internal representation before being validated (CWE-180). Make sure that the application does not decode the same input twice (CWE-174). Such errors could be used to bypass allowlist validation schemes by introducing dangerous inputs after they have been checked.


Use a built-in path canonicalization function (such as realpath() in C) that produces the canonical version of the pathname, which effectively removes ".." sequences and symbolic links (CWE-23, CWE-59). This includes:


  - realpath() in C

  - getCanonicalPath() in Java

  - GetFullPath() in ASP.NET

  - realpath() or abs_path() in Perl

  - realpath() in PHP





### Additional Notes
**[Other]** In many programming languages, the injection of a null byte (the 0 or NUL) may allow an attacker to truncate a generated filename to apply to a wider range of files. For example, the product may add ".txt" to any pathname, thus limiting the attacker to text files, but a null injection may effectively remove this restriction.

**[Relationship]** Pathname equivalence can be regarded as a type of canonicalization error.

**[Relationship]** Some pathname equivalence issues are not directly related to directory traversal, rather are used to bypass security-relevant checks for whether a file/directory can be accessed by the attacker (e.g. a trailing "/" on a filename could bypass access rules that don't expect a trailing /, causing a server to provide the file when it normally would not).

**[Terminology]** 

Like other weaknesses, terminology is often based on the types of manipulations used, instead of the underlying weaknesses. Some people use "directory traversal" only to refer to the injection of ".." and equivalent sequences whose specific meaning is to traverse directories.


Other variants like "absolute pathname" and "drive letter" have the *effect* of directory traversal, but some people may not call it such, since it doesn't involve ".." or equivalent.


**[Research Gap]** Many variants of path traversal attacks are probably under-studied with respect to root cause. CWE-790 and CWE-182 begin to cover part of this gap.

**[Research Gap]** 

Incomplete diagnosis or reporting of vulnerabilities can make it difficult to know which variant is affected. For example, a researcher might say that "..\" is vulnerable, but not test "../" which may also be vulnerable.


Any combination of directory separators ("/", "\", etc.) and numbers of "." (e.g. "....") can produce unique variants; for example, the "//../" variant is not listed (CVE-2004-0325). See this entry's children and lower-level descendants.




### Observed Examples
- **CVE-2024-37032:** Large language model (LLM) management tool does not validate the format of a digest value (CWE-1287) from a private, untrusted model registry, enabling relative path traversal (CWE-23), a.k.a. Probllama
- **CVE-2024-4315:** Chain: API for text generation using Large Language Models (LLMs) does not include the "\" Windows folder separator in its denylist (CWE-184) when attempting to prevent Local File Inclusion via path traversal (CWE-22), allowing deletion of arbitrary files on Windows systems.
- **CVE-2022-45918:** Chain: a learning management tool debugger uses external input to locate previous session logs (CWE-73) and does not properly validate the given path (CWE-20), allowing for filesystem path traversal using "../" sequences (CWE-24)



## CWE-94: Improper Control of Generation of Code ('Code Injection')
**Abstraction:** Base
**Status:** Draft

### Description
The product constructs all or part of a code segment using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the syntax or behavior of the intended code segment.

### Extended Description


When a product allows a user's input to contain code syntax, it might be possible for an attacker to craft the code in such a way that it will alter the intended control flow of the product. Such an alteration could lead to arbitrary code execution.


Injection problems encompass a wide variety of issues -- all mitigated in very different ways. For this reason, the most effective way to discuss these weaknesses is to note the distinct features which classify them as injection weaknesses. The most important issue to note is that all injection problems share one thing in common -- i.e., they allow for the injection of control plane data into the user-controlled data plane. This means that the execution of the process may be altered by sending code in through legitimate data channels, using no other mechanism. While buffer overflows, and many other flaws, involve the use of some further issue to gain execution, injection problems need only for the data to be parsed. The most classic instantiations of this category of weakness are SQL injection and format string vulnerabilities.


### Alternative Terms
None

### Relationships
ChildOf -> CWE-74
ChildOf -> CWE-74
ChildOf -> CWE-913
ParentOf -> CWE-1336
ParentOf -> CWE-95
ParentOf -> CWE-96
CanFollow -> CWE-98

### Mapping Guidance
**Usage:** Allowed-with-Review
**Rationale:** This entry is frequently misused for vulnerabilities with a technical impact of "code execution," which does not by itself indicate a root cause weakness, since dozens of weaknesses can enable code execution.
**Comments:** This weakness only applies when the product's functionality intentionally constructs all or part of a code segment. It could be that executing code could be the result of other weaknesses that do not involve the construction of code segments.
**Reasons:**
- Frequent Misuse
- Frequent Misinterpretation


### Potential Mitigations
**Mitigation 1:**
- **Phase:** Architecture and Design
- **Description:** Refactor your program so that you do not have to dynamically generate code.

**Mitigation 2:**
- **Phase:** Architecture and Design
- **Description:** 

Run your code in a "jail" or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which code can be executed by your product.


Examples include the Unix chroot jail and AppArmor. In general, managed code may provide some protection.


This may not be a feasible solution, and it only limits the impact to the operating system; the rest of your application may still be subject to compromise.


Be careful to avoid CWE-243 and other weaknesses related to jails.


**Mitigation 3:**
- **Phase:** Implementation
- **Strategy:** Input Validation
- **Description:** 

Assume all input is malicious. Use an "accept known good" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.


When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, "boat" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as "red" or "blue."


Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.


To reduce the likelihood of code injection, use stringent allowlists that limit which constructs are allowed. If you are dynamically constructing code that invokes a function, then verifying that the input is alphanumeric might be insufficient. An attacker might still be able to reference a dangerous function that you did not intend to allow, such as system(), exec(), or exit().





### Observed Examples
- **CVE-2023-29374:** Math component in an LLM framework translates user input into a Python expression that is input into the Python exec() method, allowing code execution - one variant of a "prompt injection" attack.
- **CVE-2024-5565:** Python-based library uses an LLM prompt containing user input to dynamically generate code that is then fed as input into the Python exec() method, allowing code execution - one variant of a "prompt injection" attack.
- **CVE-2024-4181:** Framework for LLM applications allows eval injection via a crafted response from a hosting provider.



## CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')
**Abstraction:** Variant
**Status:** Incomplete

### Description
The product receives input from an upstream component, but it does not neutralize or incorrectly neutralizes code syntax before using the input in a dynamic evaluation call (e.g. "eval").

### Extended Description
This may allow an attacker to execute arbitrary code, or at least modify what code can be executed.

### Alternative Terms
None

### Relationships
ChildOf -> CWE-94

### Mapping Guidance
**Usage:** Allowed
**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.
**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.
**Reasons:**
- Acceptable-Use


### Potential Mitigations
**Mitigation 1:**
- **Phase:** Architecture and Design, Implementation
- **Description:** If possible, refactor your code so that it does not need to use eval() at all.

**Mitigation 2:**
- **Phase:** Implementation
- **Strategy:** Input Validation
- **Description:** 

Assume all input is malicious. Use an "accept known good" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.


When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, "boat" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as "red" or "blue."


Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.


**Mitigation 3:**
- **Phase:** Implementation
- **Description:** 

Inputs should be decoded and canonicalized to the application's current internal representation before being validated (CWE-180, CWE-181). Make sure that your application does not inadvertently decode the same input twice (CWE-174). Such errors could be used to bypass allowlist schemes by introducing dangerous inputs after they have been checked. Use libraries such as the OWASP ESAPI Canonicalization control.


Consider performing repeated canonicalization until your input does not change any more. This will avoid double-decoding and similar scenarios, but it might inadvertently modify inputs that are allowed to contain properly-encoded dangerous content.




### Additional Notes
**[Other]** Factors: special character errors can play a role in increasing the variety of code that can be injected, although some vulnerabilities do not require special characters at all, e.g. when a single function without arguments can be referenced and a terminator character is not necessary.



### Observed Examples
- **CVE-2024-4181:** Framework for LLM applications allows eval injection via a crafted response from a hosting provider.
- **CVE-2022-2054:** Python compiler uses eval() to execute malicious strings as Python code.
- **CVE-2021-22204:** Chain: regex in EXIF processor code does not correctly determine where a string ends (CWE-625), enabling eval injection (CWE-95), as exploited in the wild per CISA KEV.



## CWE-96: Improper Neutralization of Directives in Statically Saved Code ('Static Code Injection')
**Abstraction:** Base
**Status:** Draft

### Description
The product receives input from an upstream component, but it does not neutralize or incorrectly neutralizes code syntax before inserting the input into an executable resource, such as a library, configuration file, or template.

### Extended Description
Not provided

### Alternative Terms
None

### Relationships
ChildOf -> CWE-94
ParentOf -> CWE-97

### Mapping Guidance
**Usage:** Allowed
**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.
**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.
**Reasons:**
- Acceptable-Use


### Potential Mitigations
**Mitigation 1:**
- **Phase:** Implementation
- **Strategy:** Input Validation
- **Description:** 

Assume all input is malicious. Use an "accept known good" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.


When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, "boat" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as "red" or "blue."


Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.


**Mitigation 2:**
- **Phase:** Implementation
- **Strategy:** Output Encoding
- **Description:** Perform proper output validation and escaping to neutralize all code syntax from data written to code files.



### Additional Notes
**[Relationship]** "HTML injection" (see CWE-79: XSS) could be thought of as an example of this, but the code is injected and executed on the client side, not the server side. Server-Side Includes (SSI) are an example of direct static code injection.



### Observed Examples
- **CVE-2002-0495:** Perl code directly injected into CGI library file from parameters to another CGI program.
- **CVE-2005-1876:** Direct PHP code injection into supporting template file.
- **CVE-2005-1894:** Direct code injection into PHP script that can be accessed by attacker.

