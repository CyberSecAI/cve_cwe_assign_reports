# Critic Input for CVE-2021-20109



# Original Analyzer Input
## Vulnerability Description
Due to the Asset Explorer agent not validating HTTPS certificates, an attacker on the network can statically configure their IP address to match the Asset Explorers Server IP address. This will allow an attacker to send a NEWSCAN request to a listening agent on the network as well as receive the agents HTTP request verifying its authtoken. In AEAgent.cpp, the agent responding back over HTTP is vulnerable to a Heap Overflow if the POST payload response is too large. The POST payload response is converted to Unicode using vswprintf. This is written to a buffer only 0x2000 bytes big. If POST payload is larger, then **heap overflow** will occur.

### Vulnerability Description Key Phrases
- **weakness:** **heap overflow**
- **product:** Asset Explorer agent
- **component:** AEAgent.cpp

## CVE Reference Links Content Summary
Based on the provided content, here's an analysis of CVE-2021-20109:

**Root Cause of Vulnerability:**
The vulnerability stems from a heap overflow in the ManageEngine Asset Explorer agent (AEAgent.cpp). Specifically, the agent's HTTP response handling is flawed when processing a large POST payload. The payload is converted to Unicode using `vswprintf` and written to a fixed-size buffer of 0x2000 bytes. If the POST payload is larger than this buffer, a heap overflow occurs.

**Weaknesses/Vulnerabilities Present:**

*   **Heap Overflow:** The primary vulnerability is a heap overflow caused by insufficient buffer size to accommodate the converted POST payload.
*   **Lack of HTTPS Certificate Validation:** The agent does not validate HTTPS certificates, allowing an attacker to impersonate the Asset Explorer server by configuring a matching IP address.
*   **Insecure Authtoken Handling:** The agent sends its authtoken over HTTP, allowing it to be intercepted by an attacker who has positioned themselves as a MITM.

**Impact of Exploitation:**

*   **Arbitrary Code Execution:** Although the provided text does not explicitly state it, heap overflows can lead to arbitrary code execution by overwriting critical memory regions. This is a typical consequence of successful heap overflow exploitation.
*   **Loss of Integrity:** The vulnerability allows an attacker to manipulate the agent's behavior, potentially compromising the integrity of scanned assets data.
*   **Man-in-the-middle attack:** An attacker on the network can send a NEWSCAN request to a listening agent and intercept the agent's authtoken.

**Attack Vectors:**

*   **Network-based Attack:** An attacker on the same network as the vulnerable Asset Explorer agent can exploit the vulnerability.
*   **Man-in-the-middle:** An attacker can perform a MITM attack by impersonating the Asset Explorer server.
*   **Malicious POST Request:** The attacker sends a crafted `NEWSCAN` request with an excessively large POST payload to trigger the heap overflow on a vulnerable agent.

**Required Attacker Capabilities/Position:**

*   **Network Access:** The attacker must be on the same network as the vulnerable ManageEngine Asset Explorer agent.
*   **IP Address Spoofing:** The attacker needs the capability to statically configure their IP address to match the Asset Explorer server's IP address, which is a pre-requisite to sending a malicious NEWSCAN request.
*   **Understanding of the Protocol:** The attacker must know how to form a `NEWSCAN` request to the asset explorer agent and how to structure the POST payload to trigger the overflow.

**Additional Details:**
*   The vulnerability was found in Manage Engine Asset Explorer Agent version 1.0.34.
*   Tenable disclosed the issue to ManageEngine on March 26, 2021 and publicly released the information on July 16, 2021, with the vendor having issued a patch during that time.
*   The vulnerability is rated as High severity.
*   CVSS v2 score is 7.8 (AV:N/AC:L/Au:N/C:N/I:C/A:N)
*   CVSS v3 score is 7.5 (AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N)

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage | Combined Score | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|---------------|------------|-------------------|
| 1 | CWE-295 | Improper Certificate Validation | Base | Allowed | 0.9220 | dense, sparse, graph | dense: 0.479, sparse: 0.797, graph: 0.633 |
| 2 | CWE-789 | Memory Allocation with Excessive Size Value | Variant | Allowed | 0.6542 | dense, sparse, graph | dense: 0.472, sparse: 0.421, graph: 0.647 |
| 3 | CWE-1284 | Improper Validation of Specified Quantity in Input | Base | Allowed | 0.6254 | sparse, graph | sparse: 0.468, graph: 1.000 |
| 4 | CWE-193 | Off-by-one Error | Base | Allowed | 0.6178 | sparse, graph | sparse: 0.455, graph: 1.000 |
| 5 | CWE-770 | Allocation of Resources Without Limits or Throttling | Base | Allowed | 0.6157 | sparse, graph | sparse: 0.451, graph: 1.000 |
| 6 | CWE-190 | Integer Overflow or Wraparound | Base | Allowed | 0.5757 | sparse, graph | sparse: 0.453, graph: 0.885 |
| 7 | CWE-121 | Stack-based Buffer Overflow | Variant | Allowed | 0.4584 | dense, sparse | dense: 0.480, sparse: 0.448 |
| 8 | CWE-120 | Buffer Copy without Checking Size of Input ('Classic Buffer Overflow') | Base | Allowed-with-Review | 0.4413 | sparse, graph | sparse: 0.414, graph: 0.631 |
| 9 | CWE-125 | Out-of-bounds Read | Base | Allowed | 0.2475 | sparse | sparse: 0.433 |
| 10 | CWE-918 | Server-Side Request Forgery (SSRF) | Base | Allowed | 0.2467 | sparse | sparse: 0.431 |



# Analysis to Review
# Summary
| CWE ID | CWE Name | Confidence | CWE Abstraction Level | CWE Vulnerability Mapping Label | CWE-Vulnerability Mapping Notes |
|---|---|---|---|---|---|
| CWE-122 | Heap-based Buffer Overflow | 0.95 | Variant | Allowed | Primary CWE |
| CWE-770 | Allocation of Resources Without Limits or Throttling | 0.70 | Base | Allowed | Secondary Candidate |
| CWE-295 | Improper Certificate Validation | 0.65 | Base | Allowed | Secondary Candidate |

## Evidence and Confidence

*   **Confidence Score:** 0.90
*   **Evidence Strength:** HIGH

- **Analysis and Justification:**  
  - *Explanation:* The vulnerability description clearly states that the "agent responding back over HTTP is vulnerable to a **Heap Overflow** if the POST payload response is too large." The description goes on to explain how the POST payload is converted to Unicode and written to a buffer of fixed size (0x2000 bytes), and if the payload exceeds this size, a **heap overflow** occurs. This aligns directly with CWE-122 (Heap-based Buffer Overflow), which is a Variant of buffer overflow that occurs in the heap portion of memory. The CVE Reference Links Content Summary reinforces this by stating, "The primary vulnerability is a heap overflow caused by insufficient buffer size to accommodate the converted POST payload."
CWE-122 is preferred over the base CWE-119 because it is more specific about the location of the buffer.

  - *Relationship Analysis:* CWE-122 is a variant of CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer). It is also related to CWE-120 (Buffer Copy without Checking Size of Input) but CWE-122 is more specific about the heap allocation.

- **Confidence Score:**  
  - Confidence: 0.95 (High evidence from the vulnerability description and CVE reference materials)

---

- **Analysis and Justification:**  
  - *Explanation:* The vulnerability description mentions that the "Asset Explorer agent not validating HTTPS certificates" allows an attacker to configure their IP address and intercept the agent's HTTP request. While the primary issue is the heap overflow, the lack of certificate validation is a contributing factor that allows the attacker to position themselves to exploit the overflow. This maps to CWE-295 (Improper Certificate Validation), which describes the condition where a product does not validate or incorrectly validates a certificate. This allows an attacker to perform a man-in-the-middle attack.

  - *Relationship Analysis:* CWE-295 is a base level CWE.

- **Confidence Score:**  
  - Confidence: 0.65 (The lack of certificate validation is a contributing factor to the exploit, but not the primary vulnerability)

---

- **Analysis and Justification:**  
  - *Explanation:* The **heap overflow** occurs because the product does not impose any restrictions on the size of the POST payload response. Thus, an attacker can send an arbitrary amount of data which the software attempts to allocate memory for, leading to the **heap overflow**. This aligns with CWE-770 Allocation of Resources Without Limits or Throttling.

  - *Relationship Analysis:* CWE-770 is a base level CWE.

- **Confidence Score:**  
  - Confidence: 0.70 (The improper resource allocation enables the **heap overflow**, but the **heap overflow** is the more immediate cause of the crash.)

---

# CWE Examples from Database


## Known Examples for CWE-770: Allocation of Resources Without Limits or Throttling
### Observed Examples
- **CVE-2022-21668** [https://www.cve.org/CVERecord?id=CVE-2022-21668](https://www.cve.org/CVERecord?id=CVE-2022-21668): Chain: Python library does not limit the resources used to process images that specify a very large number of bands (CWE-1284), leading to excessive memory consumption (CWE-789) or an integer overflow (CWE-190).
- **CVE-2009-4017** [https://www.cve.org/CVERecord?id=CVE-2009-4017](https://www.cve.org/CVERecord?id=CVE-2009-4017): Language interpreter does not restrict the number of temporary files being created when handling a MIME request with a large number of parts..
- **CVE-2009-2726** [https://www.cve.org/CVERecord?id=CVE-2009-2726](https://www.cve.org/CVERecord?id=CVE-2009-2726): Driver does not use a maximum width when invoking sscanf style functions, causing stack consumption.
- **CVE-2009-2540** [https://www.cve.org/CVERecord?id=CVE-2009-2540](https://www.cve.org/CVERecord?id=CVE-2009-2540): Large integer value for a length property in an object causes a large amount of memory allocation.
- **CVE-2009-2054** [https://www.cve.org/CVERecord?id=CVE-2009-2054](https://www.cve.org/CVERecord?id=CVE-2009-2054): Product allows exhaustion of file descriptors when processing a large number of TCP packets.
- **CVE-2008-5180** [https://www.cve.org/CVERecord?id=CVE-2008-5180](https://www.cve.org/CVERecord?id=CVE-2008-5180): Communication product allows memory consumption with a large number of SIP requests, which cause many sessions to be created.
- **CVE-2008-1700** [https://www.cve.org/CVERecord?id=CVE-2008-1700](https://www.cve.org/CVERecord?id=CVE-2008-1700): Product allows attackers to cause a denial of service via a large number of directives, each of which opens a separate window.
- **CVE-2005-4650** [https://www.cve.org/CVERecord?id=CVE-2005-4650](https://www.cve.org/CVERecord?id=CVE-2005-4650): CMS does not restrict the number of searches that can occur simultaneously, leading to resource exhaustion.
- **CVE-2020-15100** [https://www.cve.org/CVERecord?id=CVE-2020-15100](https://www.cve.org/CVERecord?id=CVE-2020-15100): web application scanner attempts to read an excessively large file created by a user, causing process termination
- **CVE-2020-7218** [https://www.cve.org/CVERecord?id=CVE-2020-7218](https://www.cve.org/CVERecord?id=CVE-2020-7218): Go-based workload orchestrator does not limit resource usage with unauthenticated connections, allowing a DoS by flooding the service


# Relevant CWE Specifications

## CWE-770: Allocation of Resources Without Limits or Throttling
**Abstraction:** Base
**Status:** Incomplete

### Description
The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.

### Extended Description


Code frequently has to work with limited resources, so programmers must be careful to ensure that resources are not consumed too quickly, or too easily. Without use of quotas, resource limits, or other protection mechanisms, it can be easy for an attacker to consume many resources by rapidly making many requests, or causing larger resources to be used than is needed. When too many resources are allocated, or if a single resource is too large, then it can prevent the code from working correctly, possibly leading to a denial of service.


### Alternative Terms
None

### Relationships
ChildOf -> CWE-400
ChildOf -> CWE-665
ChildOf -> CWE-400
ParentOf -> CWE-1325
CanFollow -> CWE-20
ParentOf -> CWE-774
ParentOf -> CWE-789

### Mapping Guidance
**Usage:** Allowed
**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.
**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.
**Reasons:**
- Acceptable-Use


### Potential Mitigations
**Mitigation 1:**
- **Phase:** Requirements
- **Description:** Clearly specify the minimum and maximum expectations for capabilities, and dictate which behaviors are acceptable when resource allocation reaches limits.

**Mitigation 2:**
- **Phase:** Architecture and Design
- **Description:** Limit the amount of resources that are accessible to unprivileged users. Set per-user limits for resources. Allow the system administrator to define these limits. Be careful to avoid CWE-410.

**Mitigation 3:**
- **Phase:** Architecture and Design
- **Description:** Design throttling mechanisms into the system architecture. The best protection is to limit the amount of resources that an unauthorized user can cause to be expended. A strong authentication and access control model will help prevent such attacks from occurring in the first place, and it will help the administrator to identify who is committing the abuse. The login application should be protected against DoS attacks as much as possible. Limiting the database access, perhaps by caching result sets, can help minimize the resources expended. To further limit the potential for a DoS attack, consider tracking the rate of requests received from users and blocking requests that exceed a defined rate threshold.



### Additional Notes
**[Relationship]** This entry is different from uncontrolled resource consumption (CWE-400) in that there are other weaknesses that are related to inability to control resource consumption, such as holding on to a resource too long after use, or not correctly keeping track of active resources so that they can be managed and released when they are finished (CWE-771).

**[Theoretical]** Vulnerability theory is largely about how behaviors and resources interact. "Resource exhaustion" can be regarded as either a consequence or an attack, depending on the perspective. This entry is an attempt to reflect one of the underlying weaknesses that enable these attacks (or consequences) to take place.



### Observed Examples
- **CVE-2022-21668:** Chain: Python library does not limit the resources used to process images that specify a very large number of bands (CWE-1284), leading to excessive memory consumption (CWE-789) or an integer overflow (CWE-190).
- **CVE-2009-4017:** Language interpreter does not restrict the number of temporary files being created when handling a MIME request with a large number of parts..
- **CVE-2009-2726:** Driver does not use a maximum width when invoking sscanf style functions, causing stack consumption.



## CWE-295: Improper Certificate Validation
**Abstraction:** Base
**Status:** Draft

### Description
The product does not validate, or incorrectly validates, a certificate.

### Extended Description
When a certificate is invalid or malicious, it might allow an attacker to spoof a trusted entity by interfering in the communication path between the host and client. The product might connect to a malicious host while believing it is a trusted host, or the product might be deceived into accepting spoofed data that appears to originate from a trusted host.

### Alternative Terms
None

### Relationships
ChildOf -> CWE-287
ChildOf -> CWE-287
PeerOf -> CWE-322
ParentOf -> CWE-296
ParentOf -> CWE-297
ParentOf -> CWE-298
ParentOf -> CWE-299
ParentOf -> CWE-599

### Mapping Guidance
**Usage:** Allowed
**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.
**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.
**Reasons:**
- Acceptable-Use


### Potential Mitigations
**Mitigation 1:**
- **Phase:** Architecture and Design, Implementation
- **Description:** Certificates should be carefully managed and checked to assure that data are encrypted with the intended owner's public key.

**Mitigation 2:**
- **Phase:** Implementation
- **Description:** If certificate pinning is being used, ensure that all relevant properties of the certificate are fully validated before the certificate is pinned, including the hostname.




### Observed Examples
- **CVE-2019-12496:** A Go framework for robotics, drones, and IoT devices skips verification of root CA certificates by default.
- **CVE-2014-1266:** chain: incorrect "goto" in Apple SSL product bypasses certificate validation, allowing Adversary-in-the-Middle (AITM) attack (Apple "goto fail" bug). CWE-705 (Incorrect Control Flow Scoping) -> CWE-561 (Dead Code) -> CWE-295 (Improper Certificate Validation) -> CWE-393 (Return of Wrong Status Code) -> CWE-300 (Channel Accessible by Non-Endpoint).
- **CVE-2021-22909:** Chain: router's firmware update procedure uses curl with "-k" (insecure) option that disables certificate validation (CWE-295), allowing adversary-in-the-middle (AITM) compromise with a malicious firmware image (CWE-494).



## CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer
**Abstraction:** Class
**Status:** Stable

### Description
The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.

### Extended Description
Not provided

### Alternative Terms
Buffer Overflow: This term has many different meanings to different audiences. From a CWE mapping perspective, this term should be avoided where possible. Some researchers, developers, and tools intend for it to mean "write past the end of a buffer," whereas others use the same term to mean "any read or write outside the boundaries of a buffer, whether before the beginning of the buffer or after the end of the buffer." Others could mean "any action after the end of a buffer, whether it is a read or write." Since the term is commonly used for exploitation and for vulnerabilities, it further confuses things.
buffer overrun: Some prominent vendors and researchers use the term "buffer overrun," but most people use "buffer overflow." See the alternate term for "buffer overflow" for context.
memory safety: Generally used for techniques that avoid weaknesses related to memory access, such as those identified by CWE-119 and its descendants. However, the term is not formal, and there is likely disagreement between practitioners as to which weaknesses are implicitly covered by the "memory safety" term.

### Relationships
ChildOf -> CWE-118
ChildOf -> CWE-20
ParentOf -> CWE-120
ParentOf -> CWE-123
ParentOf -> CWE-125
CanFollow -> CWE-1257
CanFollow -> CWE-1260
CanFollow -> CWE-128
CanFollow -> CWE-129
ParentOf -> CWE-130
CanFollow -> CWE-131
CanFollow -> CWE-1339
CanFollow -> CWE-190
CanFollow -> CWE-193
CanFollow -> CWE-195
CanFollow -> CWE-20
ParentOf -> CWE-466
ParentOf -> CWE-786
ParentOf -> CWE-787
ParentOf -> CWE-788
ParentOf -> CWE-805
ParentOf -> CWE-822
ParentOf -> CWE-823
ParentOf -> CWE-824
ParentOf -> CWE-825
CanFollow -> CWE-839
CanFollow -> CWE-843

### Mapping Guidance
**Usage:** Discouraged
**Rationale:** CWE-119 is commonly misused in low-information vulnerability reports when lower-level CWEs could be used instead, or when more details about the vulnerability are available.
**Comments:** Look at CWE-119's children and consider mapping to CWEs such as CWE-787: Out-of-bounds Write, CWE-125: Out-of-bounds Read, or others.
**Reasons:**
- Frequent Misuse


### Potential Mitigations
**Mitigation 1:**
- **Phase:** Requirements
- **Strategy:** Language Selection
- **Description:** 

Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.


For example, many languages that perform their own memory management, such as Java and Perl, are not subject to buffer overflows. Other languages, such as Ada and C#, typically provide overflow protection, but the protection can be disabled by the programmer.


Be wary that a language's interface to native code may still be subject to overflows, even if the language itself is theoretically safe.


**Mitigation 2:**
- **Phase:** Architecture and Design
- **Strategy:** Libraries or Frameworks
- **Description:** 

Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.


Examples include the Safe C String Library (SafeStr) by Messier and Viega [REF-57], and the Strsafe.h library from Microsoft [REF-56]. These libraries provide safer versions of overflow-prone string-handling functions.


**Mitigation 3:**
- **Phase:** Operation, Build and Compilation
- **Effectiveness:** Defense in Depth
- **Strategy:** Environment Hardening
- **Description:** 

Use automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking. 


 D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail. 




### Additional Notes
**[Applicable Platform]** 

It is possible in any programming languages without memory management support to attempt an operation outside of the bounds of a memory buffer, but the consequences will vary widely depending on the language, platform, and chip architecture.




### Observed Examples
- **CVE-2021-22991:** Incorrect URI normalization in application traffic product leads to buffer overflow, as exploited in the wild per CISA KEV.
- **CVE-2020-29557:** Buffer overflow in Wi-Fi router web interface, as exploited in the wild per CISA KEV.
- **CVE-2009-2550:** Classic stack-based buffer overflow in media player using a long entry in a playlist



## CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')
**Abstraction:** Base
**Status:** Incomplete

### Description
The product copies an input buffer to an output buffer without verifying that the size of the input buffer is less than the size of the output buffer, leading to a buffer overflow.

### Extended Description
A buffer overflow condition exists when a product attempts to put more data in a buffer than it can hold, or when it attempts to put data in a memory area outside of the boundaries of a buffer. The simplest type of error, and the most common cause of buffer overflows, is the "classic" case in which the product copies the buffer without restricting how much is copied. Other variants exist, but the existence of a classic overflow strongly suggests that the programmer is not considering even the most basic of security protections.

### Alternative Terms
Classic Buffer Overflow: This term was frequently used by vulnerability researchers during approximately 1995 to 2005 to differentiate buffer copies without length checks (which had been known about for decades) from other emerging weaknesses that still involved invalid accesses of buffers, as vulnerability researchers began to develop advanced exploitation techniques.
Unbounded Transfer

### Relationships
ChildOf -> CWE-119
ChildOf -> CWE-119
ChildOf -> CWE-119
ChildOf -> CWE-119
CanPrecede -> CWE-123
ChildOf -> CWE-20
CanFollow -> CWE-170
CanFollow -> CWE-231
CanFollow -> CWE-416
CanFollow -> CWE-456
ParentOf -> CWE-785

### Mapping Guidance
**Usage:** Allowed-with-Review
**Rationale:** There are some indications that this CWE ID might be misused and selected simply because it mentions "buffer overflow" - an increasingly vague term. This CWE entry is only appropriate for "Buffer Copy" operations (not buffer reads), in which where there is no "Checking [the] Size of Input", and (by implication of the copy) writing past the end of the buffer.
**Comments:** If the vulnerability being analyzed involves out-of-bounds reads, then consider CWE-125 or descendants. For root cause analysis: if there is any input validation, consider children of CWE-20 such as CWE-1284. If there is a calculation error for buffer sizes, consider CWE-131 or similar.
**Reasons:**
- Frequent Misuse


### Potential Mitigations
**Mitigation 1:**
- **Phase:** Requirements
- **Strategy:** Language Selection
- **Description:** 

Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.


For example, many languages that perform their own memory management, such as Java and Perl, are not subject to buffer overflows. Other languages, such as Ada and C#, typically provide overflow protection, but the protection can be disabled by the programmer.


Be wary that a language's interface to native code may still be subject to overflows, even if the language itself is theoretically safe.


**Mitigation 2:**
- **Phase:** Architecture and Design
- **Strategy:** Libraries or Frameworks
- **Description:** 

Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.


Examples include the Safe C String Library (SafeStr) by Messier and Viega [REF-57], and the Strsafe.h library from Microsoft [REF-56]. These libraries provide safer versions of overflow-prone string-handling functions.


**Mitigation 3:**
- **Phase:** Operation, Build and Compilation
- **Effectiveness:** Defense in Depth
- **Strategy:** Environment Hardening
- **Description:** 

Use automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking. 


 D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail. 




### Additional Notes
**[Relationship]** At the code level, stack-based and heap-based overflows do not differ significantly, so there usually is not a need to distinguish them. From the attacker perspective, they can be quite different, since different techniques are required to exploit them.

**[Terminology]** Many issues that are now called "buffer overflows" are substantively different than the "classic" overflow, including entirely different bug types that rely on overflow exploit techniques, such as integer signedness errors, integer overflows, and format string bugs. This imprecise terminology can make it difficult to determine which variant is being reported.



### Observed Examples
- **CVE-2000-1094:** buffer overflow using command with long argument
- **CVE-1999-0046:** buffer overflow in local program using long environment variable
- **CVE-2002-1337:** buffer overflow in comment characters, when product increments a counter for a ">" but does not decrement for "<"



## CWE-122: Heap-based Buffer Overflow
**Abstraction:** Variant
**Status:** Draft

### Description
A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().

### Extended Description
Not provided

### Alternative Terms
None

### Relationships
ChildOf -> CWE-788
ChildOf -> CWE-787

### Mapping Guidance
**Usage:** Allowed
**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.
**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.
**Reasons:**
- Acceptable-Use


### Potential Mitigations
**Mitigation 1:**
- **Description:** Pre-design: Use a language or compiler that performs automatic bounds checking.

**Mitigation 2:**
- **Phase:** Architecture and Design
- **Description:** Use an abstraction library to abstract away risky APIs. Not a complete solution.

**Mitigation 3:**
- **Phase:** Operation, Build and Compilation
- **Effectiveness:** Defense in Depth
- **Strategy:** Environment Hardening
- **Description:** 

Use automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking. 


 D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail. 




### Additional Notes
**[Relationship]** Heap-based buffer overflows are usually just as dangerous as stack-based buffer overflows.



### Observed Examples
- **CVE-2021-43537:** Chain: in a web browser, an unsigned 64-bit integer is forcibly cast to a 32-bit integer (CWE-681) and potentially leading to an integer overflow (CWE-190). If an integer overflow occurs, this can cause heap memory corruption (CWE-122)
- **CVE-2007-4268:** Chain: integer signedness error (CWE-195) passes signed comparison, leading to heap overflow (CWE-122)
- **CVE-2009-2523:** Chain: product does not handle when an input string is not NULL terminated (CWE-170), leading to buffer over-read (CWE-125) or heap-based buffer overflow (CWE-122).

