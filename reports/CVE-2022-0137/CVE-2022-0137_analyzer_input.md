# Vulnerability Information: CVE-2022-0137

## Vulnerability Description
A **heap buffer overflow** in image_set_mask function of HTMLDOC before 1.9.15 allows an attacker to write outside the buffer boundaries.

### Vulnerability Description Key Phrases
- **rootcause:** **heap buffer overflow**
- **vector:** write outside the buffer boundaries
- **attacker:** attacker
- **product:** HTMLDOC
- **version:** before 1.9.15
- **component:** image_set_mask function

## CVE Reference Links Content Summary
Based on the provided content, here's an analysis of the vulnerability:

**Root Cause:**

The vulnerability is a heap-based buffer overflow in the `image_set_mask` function, which is triggered during the processing of GIF images in the htmldoc library. The root cause is an inconsistency in how image dimensions (`width` and `height`) are handled during the allocation and use of the mask buffer.

**Vulnerabilities/Weaknesses:**

1.  **Incorrect Buffer Size Calculation:** The `img->mask` buffer is allocated based on initial `width` and `height` values read from the GIF file. These values are used in `image_need_mask()`.
2. **Modified Image Dimensions:**  After the `img->mask` buffer is allocated, `img->width` and `img->height` are modified, potentially increasing their values.
3. **Out-of-Bounds Access:**  The `image_set_mask` function uses the potentially modified `img->height` to calculate an offset into the `img->mask` buffer. Since the buffer's size is based on older, potentially smaller dimensions, the calculation can lead to out-of-bounds writes to memory. Specifically, the following line in `image_set_mask` is vulnerable:
    ```c
    maskptr  = img->mask + y * img->maskwidth + x / 8;
    *maskptr |= masks[x & 7];
    ```

**Impact of Exploitation:**

*   **Heap-based buffer overflow:** An attacker can overwrite heap memory by providing a crafted GIF file, potentially leading to:
    *   **Arbitrary code execution:** By overwriting specific memory regions, an attacker might be able to control the program's execution flow.
    *   **Denial of service:** The overflow can crash the program due to a segmentation fault.

**Attack Vectors:**

*   **Malicious GIF file:** The primary attack vector is a specially crafted GIF file.
*   **Command-line tool:** The vulnerability can be exploited by processing a malicious GIF through the `htmldoc` command line tool, specifically using the `--webpage` option to parse HTML file containing the malicious GIF.

**Required Attacker Capabilities/Position:**

*   **Ability to provide a malicious GIF:** The attacker needs the ability to provide the vulnerable htmldoc application with a specially crafted GIF file. This can be achieved by supplying it as an embedded image in a crafted HTML file.
*   **User interaction:** The user must use the `htmldoc` tool to process the attacker-provided crafted HTML.

**More details than the CVE description:**
Yes, the provided content provides significant details of the vulnerability, including:
    * The specific vulnerable function `image_set_mask`.
    * The vulnerable code section in `image.cxx` file.
    * The root cause of the vulnerability is the change in image dimensions after mask buffer allocation.
    * How a crafted GIF file can be used to trigger the heap overflow.
    * The address sanitizer report that highlights the heap buffer overflow location.

The patch is also provided which fixes the vulnerability by recalculating the mask size based on the correct dimensions

```diff
--- a/htmldoc/image.cxx
+++ b/htmldoc/image.cxx
@@ -1343,13 +1343,6 @@
     image_need_mask(img);
   }
 
-  img->width  = (buf[5] << 8) | buf[4];
-  img->height = (buf[7] << 8) | buf[6];
-  img->depth  = gray ? 1 : 3;
-
-  if (img->width <= 0 || img->width > 32767 ||
-      img->height <= 0 || img->height > 32767)
-    return (-1);
 
   if (!load_data)
     return (0);
@@ -1784,7 +1777,7 @@
 
 
   if (img == NULL || img->mask == NULL || x < 0 || x >= img->width ||
-      y < 0 || y > img->height)
+      y < 0 || y >= img->height)
     return;
 
   if (img->maskscale == 8)
```

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage | Combined Score | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|---------------|------------|-------------------|
| 1 | CWE-193 | Off-by-one Error | Base | Allowed | 0.6866 | dense, sparse, graph | dense: 0.530, sparse: 0.161, graph: 0.920 |
| 2 | CWE-190 | Integer Overflow or Wraparound | Base | Allowed | 0.6312 | dense, sparse, graph | dense: 0.542, sparse: 0.163, graph: 0.746 |
| 3 | CWE-124 | Buffer Underwrite ('Buffer Underflow') | Base | Allowed | 0.6107 | dense, sparse, graph | dense: 0.532, sparse: 0.136, graph: 0.746 |
| 4 | CWE-126 | Buffer Over-read | Variant | Allowed | 0.5181 | dense, sparse, graph | dense: 0.541, sparse: 0.154, graph: 0.565 |
| 5 | CWE-1284 | Improper Validation of Specified Quantity in Input | Base | Allowed | 0.3948 | sparse, graph | sparse: 0.155, graph: 0.857 |
| 6 | CWE-122 | Heap-based Buffer Overflow | Variant | Allowed | 0.3682 | dense, sparse | dense: 0.587, sparse: 0.184 |
| 7 | CWE-839 | Numeric Range Comparison Without Minimum Check | Base | Allowed | 0.3607 | sparse, graph | sparse: 0.137, graph: 0.789 |
| 8 | CWE-120 | Buffer Copy without Checking Size of Input ('Classic Buffer Overflow') | Base | Allowed-with-Review | 0.3516 | sparse, graph | sparse: 0.140, graph: 0.807 |
| 9 | CWE-131 | Incorrect Calculation of Buffer Size | Base | Allowed | 0.3432 | dense, sparse | dense: 0.511, sparse: 0.153 |
| 10 | CWE-125 | Out-of-bounds Read | Base | Allowed | 0.3338 | dense, sparse | dense: 0.500, sparse: 0.146 |

