# Vulnerability Information: CVE-2021-41061

## Vulnerability Description
In RIOT-OS 2021.01, **nonce reuse** in 802.15.4 encryption in the ieee820154_security component allows attackers to break encryption by triggering reboots.

### Vulnerability Description Key Phrases
- **rootcause:** **nonce reuse**
- **impact:** break encryption
- **vector:** reboots
- **attacker:** attackers
- **product:** RIOT-OS
- **version:** 2021.01
- **component:** ieee820154_security component

## CVE Reference Links Content Summary
```
{
  "CVE_data_meta": {
    "ID": "CVE-2021-41061",
    "ASSIGNER": "cve@mitre.org"
  },
  "description": {
    "description_data": [
      {
        "lang": "en",
        "value": "The frame counter used with ieee802154_security is initialized with 0 at startup. While it is protected against overflow, it is not protected against being reset, and that reset happens whenever the device restarts. As the key is flashed into the device in ieee802154_security's normal operation, and the sender LL address is constant per device, the same nonce (varying only through the resetting frame counter) is used in the AES encryption multiple times. Reuse of the same (nonce, key) breaks confidentiality guarantees."
      }
    ]
  },
  "relevant_content": [
    {
      "source": "github.com_dfdaca53_20250115_134016.html",
      "vulnerability": "The security module introduced in [#15150](https://github.com/RIOT-OS/RIOT/pull/15150) was not intended for security-critical use, as it waives using a proper key store to mitigate complexity. This wasn't clear in the documentation, which could give the wrong impression."
    },
    {
      "source": "www.rfc-editor.org_a9ba5859_20250115_134020.html",
      "vulnerability": "This document describes a minimal mode of operation for an IPv6 over the TSCH mode of IEEE 802.15.4e (6TiSCH) network.  This minimal mode of operation specifies the baseline set of protocols that need to be supported and the recommended configurations and modes of operation sufficient to enable a 6TiSCH functional network.",
       "details": "Link-layer frames MUST be secured by the link-layer security mechanisms defined in IEEE Std 802.15.4. Link-layer authentication MUST be applied to the entire frame, including the 802.15.4 header.  Link-layer encryption MAY be applied to 802.15.4 Payload IEs and the 802.15.4 payload. This specification assumes the existence of two cryptographic keys: Key K1 is used to authenticate EBs and Key K2 is used to authenticate and encrypt DATA and ACKNOWLEDGMENT frames. In the event of a network reset, the new network MUST either use new cryptographic keys or ensure that the ASN remains monotonically increasing."
    },
     {
      "source": "datatracker.ietf.org_8db6d217_20250115_134018.html",
      "vulnerability": "This document describes a procedure for augmenting the authenticated Diffie-Hellman key exchange EDHOC with third-party assisted authorization targeting constrained IoT deployments (RFC 7228). The procedure involves a device, a domain authenticator, and an authorization server. The device and authenticator perform mutual authentication and authorization, assisted by the authorization server which provides relevant authorization information to the device (a 'voucher') and to the authenticator."
    },
    {
      "source": "github.com_09e22a56_20250115_134020.html",
      "vulnerability": "This pull request adds functions to read and set the next message ID in gcoap. This was needed to maintain the next message ID between reboots, which was causing issues when the server had a larger message cache. A randomly generated message ID, if reused after reboot, can cause a server to respond with a cached response from a previous request due to the same message ID. Although this is not technically wrong of the server, gcoap couldn't match the response due to token mismatch.",
      "details": "The next message ID is randomly generated during initialization, but this is not always wanted; a manual setting is sometimes needed. The API is named 'read' to make it clear that this is not part of gcoap's regular use case."
   },
   {
      "source": "github.com_211a9ec8_20250115_091133.html",
      "vulnerability": "The frame counter used with ieee802154_security is initialized with 0 at startup. While it is protected against overflow, it is not protected against being reset, and that reset happens whenever the device restarts. As the key is flashed into the device in ieee802154_security's normal operation, and the sender LL address is constant per device, the same nonce (varying only through the resetting frame counter) is used in the AES encryption multiple times. Reuse of the same (nonce, key) breaks confidentiality guarantees.",
     "details": "The issue was found by sniffing packets after rebooting, which showed the sequence numbers start from zero again and byte-wise identical requests in regions of equal content. The module in question has been marked as experimental, CVE-2021-41061 has been assigned to this issue. Fixing this issue is non trivial. A potential mitigation may involve a random initialization at startup. Backup RAM and RTC memory could be other backends to solve this. A key could also include an absolute timestamp."
    },
    {
      "source": "crypto.stackexchange.com_20b236ca_20250115_134014.html",
      "vulnerability": "Reusing an IV with AES/GCM even once, can be catastrophic, as it leaks the XOR of plaintexts. Moreover, with GCM, a single IV reuse leaks significant information about the key used for authentication, as it is a stream cipher and is malleable if the MAC fails. NIST's GCM is designed for 96-bit IVs, and if you specify a different-length one there are weaknesses in the function used to compute the 'real' IV."
    }
  ]
}
```

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage | Combined Score | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|---------------|------------|-------------------|
| 1 | CWE-323 | Reusing a Nonce, Key Pair in Encryption | Base | Allowed | 0.7043 | dense, sparse, graph | dense: 0.665, sparse: 0.302, graph: 0.556 |
| 2 | CWE-294 | Authentication Bypass by Capture-replay | Base | Allowed | 0.5127 | dense, sparse, graph | dense: 0.519, sparse: 0.103, graph: 0.543 |
| 3 | CWE-226 | Sensitive Information in Resource Not Removed Before Reuse | Base | Allowed | 0.5045 | dense, sparse, graph | dense: 0.505, sparse: 0.102, graph: 0.540 |
| 4 | CWE-1204 | Generation of Weak Initialization Vector (IV) | Base | Allowed | 0.5036 | dense, sparse, graph | dense: 0.491, sparse: 0.116, graph: 0.537 |
| 5 | CWE-757 | Selection of Less-Secure Algorithm During Negotiation ('Algorithm Downgrade') | Base | Allowed | 0.3013 | dense, sparse | dense: 0.488, sparse: 0.100 |
| 6 | CWE-321 | Use of Hard-coded Cryptographic Key | Variant | Allowed | 0.2827 | dense, sparse | dense: 0.506, sparse: 0.093 |
| 7 | CWE-327 | Use of a Broken or Risky Cryptographic Algorithm | Class | Allowed-with-Review | 0.2634 | dense, sparse, graph | dense: 0.489, sparse: 0.105, graph: 0.402 |
| 8 | CWE-1391 | Use of Weak Credentials | Class | Allowed-with-Review | 0.1802 | dense, sparse | dense: 0.497, sparse: 0.101 |
| 9 | CWE-613 | Insufficient Session Expiration | Base | Allowed | 0.0556 | sparse | sparse: 0.097 |
| 10 | CWE-257 | Storing Passwords in a Recoverable Format | Base | Allowed | 0.0546 | sparse | sparse: 0.095 |

