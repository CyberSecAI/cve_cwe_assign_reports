# Critic Input for CVE-2021-33195



# Original Analyzer Input
## Vulnerability Description
Go before 1.15.13 and 1.16.x before 1.16.5 has functions for DNS lookups that do not validate replies from DNS servers, and thus a return value may contain an **unsafe injection** (e.g., XSS) that does not conform to the RFC1035 format.

### Vulnerability Description Key Phrases
- **weakness:** **unsafe injection**
- **impact:** cross-site scripting
- **product:** Go
- **version:** before 1.15.13 and 1.16.x before 1.16.5
- **component:** DNS lookup functions

## CVE Reference Links Content Summary
```json
[
  {
    "related_to_CVE": "CVE-2021-33195",
    "root_cause": "The `net.Lookup{Addr,CNAME,Host}` functions, when using the pure Go resolver, don't filter returned host name string types, allowing invalid names to be returned to the caller. These names, if used in an unsanitized context, could lead to injection of unexpected content.",
    "weaknesses": [
      "Lack of input sanitization",
      "Improper validation of hostnames"
    ],
    "impact": "Injection of unexpected content due to using invalid hostnames in unsanitized contexts which can lead to information disclosure, data modification, or denial of service.",
    "attack_vectors": [
      "Network"
    ],
    "attacker_capabilities": "An attacker can exploit this vulnerability by controlling the DNS responses received by a vulnerable application, which may be achieved by controlling the DNS server or via a man-in-the-middle attack.",
    "additional_information": "The vulnerability is present in Go versions before 1.15.12 and 1.16.x before 1.16.5. The vulnerability is triggered when the pure Go resolver is used. The cgo resolver may impose its own filtering, but this cannot be relied upon. The `isDomainName` function, which applies RFC 1035 LDH rules, can be used to validate returned names."
  },
  {
    "related_to_CVE": "CVE-2021-33195",
    "root_cause": "Go versions prior to 1.15.13 and 1.16.x prior to 1.16.5 are susceptible to a vulnerability which, when successfully exploited, could lead to disclosure of sensitive information, addition or modification of data, or Denial of Service (DoS). This is due to the net.Lookup functions returning invalid hostnames.",
      "weaknesses": [
        "Improper input validation"
     ],
     "impact": "Disclosure of sensitive information, data modification, or denial of service (DoS).",
     "attack_vectors": [
      "Network"
    ],
    "attacker_capabilities": "An attacker may be able to manipulate DNS results returned to a vulnerable system.",
      "additional_information": "NetApp products are affected when they incorporate vulnerable versions of Golang. The provided link points to a Google Groups discussion related to Go 1.16.5 and 1.15.13 releases, which include security fixes."
  },
  {
     "related_to_CVE": "CVE-2021-33195",
    "root_cause": "The `net` package in Go does not properly validate hostnames returned by DNS lookups, allowing arbitrary values which do not follow RFC 1035 rules for domain names to be returned, leading to potential injection issues if used without sanitization.",
    "weaknesses": [
      "Improper input validation",
      "Lack of sanitization for DNS query responses"
    ],
    "impact": "The vulnerability can lead to injection of unexpected content if arbitrary values from DNS responses are used without proper sanitization, potentially resulting in data modification, information disclosure, or a denial of service.",
    "attack_vectors": [
      "Network"
    ],
     "attacker_capabilities": "An attacker capable of manipulating DNS responses can inject arbitrary data into the application using this vulnerability.",
     "additional_information": "This is issue #46241 in the golang/go repository, and it is also identified as CVE-2021-33195. The affected functions include `LookupCNAME`, `LookupSRV`, `LookupMX`, `LookupNS`, and `LookupAddr`. A possible fix involves checking returned names with the existing `isDomainName` function to ensure they conform to RFC 1035 LDH rules."
  },
    {
    "related_to_CVE": "CVE-2021-33195",
    "root_cause": "The vulnerability is caused by the use of the `net.Lookup{Addr,CNAME,Host}` functions with the pure Go resolver, which does not validate or filter returned host name strings, leading to the possibility of injecting unexpected content if not sanitized.",
    "weaknesses": [
      "Improper Input Validation",
      "Lack of output sanitization"
    ],
    "impact": "The impact is the injection of unexpected content. This could lead to a variety of consequences, including information disclosure, data modification, or denial of service, depending on the specific context where the unsanitized data is used.",
     "attack_vectors": [
       "Network"
      ],
    "attacker_capabilities": "An attacker would need to control DNS responses to inject arbitrary, invalid hostnames into the application that uses a vulnerable version of Go.",
     "additional_information": "The vulnerability is assigned CVE-2021-33195. The `net` package in Go, specifically when using the pure Go resolver, does not filter or validate host name string types. This can be mitigated by checking returned names with the existing `isDomainName` function."
  },
    {
    "related_to_CVE": "CVE-2021-33195",
    "root_cause": "The vulnerability arises from the fact that the `net.Lookup{Addr,CNAME,Host}` functions don't filter returned host name string types when using the pure Go resolver. This allows for invalid names to be returned, which, if used in unsanitized contexts, can lead to injection issues.",
    "weaknesses": [
      "Improper Input Validation",
     "Lack of Output Sanitization"
    ],
    "impact": "The impact is potential injection of unexpected content. This could lead to vulnerabilities such as Cross-Site Scripting (XSS), data modification, or denial of service, depending on how the invalid hostname string is used.",
    "attack_vectors": [
     "Network"
    ],
    "attacker_capabilities": "An attacker capable of manipulating DNS responses can exploit this vulnerability by injecting arbitrary, invalid hostnames.",
    "additional_information": "The affected functions are `net.Lookup{Addr, CNAME, Host}` when using the pure Go resolver. This issue is tracked as CVE-2021-33195. The recommended approach is to check the returned names using the `isDomainName` function, which applies RFC 1035 LDH rules."
  },
  {
    "related_to_CVE": "CVE-2021-33195",
    "root_cause": "The vulnerability stems from the way the `net.Lookup{Addr,CNAME,Host}` functions handle DNS responses when using the pure Go resolver. They do not validate or filter the returned host name strings, allowing for invalid names that can cause injection vulnerabilities.",
     "weaknesses": [
        "Improper Input Validation",
       "Lack of Output Sanitization"
      ],
    "impact": "The lack of validation allows for the injection of unexpected content, possibly leading to data modification, information disclosure, or denial of service (DoS) depending on how the application uses these names.",
    "attack_vectors": [
     "Network"
    ],
    "attacker_capabilities": "An attacker could exploit this by controlling the DNS server or performing a man-in-the-middle attack to provide responses containing invalid host names.",
     "additional_information": "The CVE ID for this vulnerability is CVE-2021-33195. The suggested remediation is to implement validation using the `isDomainName` function, which applies RFC 1035 LDH rules and filter out invalid names, or apply other sanitization techniques."
  },
  {
    "related_to_CVE": "CVE-2021-33195",
    "root_cause": "The net.Lookup functions return arbitrary values from DNS which do not follow the rules for domain names according to RFC 1035.",
    "weaknesses": [
      "Improper Input Validation",
      "Lack of Output Sanitization"
    ],
    "impact": "When the returned names are used without sanitization, for instance in HTML, they can allow injection of unexpected content.",
    "attack_vectors": [
     "Network"
    ],
     "attacker_capabilities": "An attacker with the ability to influence DNS responses can inject arbitrary content.",
     "additional_information": "This issue is identified as CVE-2021-33195, and it's noted that `LookupTXT` may still return arbitrary values that may require sanitization."
  },
    {
     "related_to_CVE": "CVE-2021-33195",
      "root_cause": "The `net.Lookup{Addr,CNAME,Host}` functions do not properly filter returned host names when using the pure Go resolver. This can allow for invalid names to be returned to the caller, which can lead to injection vulnerabilities if used in unsanitized contexts.",
      "weaknesses": [
        "Improper Input Validation",
       "Lack of Input Sanitization"
     ],
      "impact": "The use of invalid host names in an unsanitized context can lead to injection of unexpected content, potentially resulting in information disclosure, data modification, or denial of service.",
      "attack_vectors": [
      "Network"
      ],
      "attacker_capabilities": "An attacker capable of manipulating DNS responses can exploit this vulnerability.",
    "additional_information":"This vulnerability is identified as CVE-2021-33195. The issue occurs because returned names are not checked against the RFC 1035 LDH rules. The cgo resolver might do some filtering, but this is not consistent. The fix should involve checking the returned names using the `isDomainName` function."
  }
]
```

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage | Combined Score | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|---------------|------------|-------------------|
| 1 | CWE-115 | Misinterpretation of Input | Base | Allowed | 0.5761 | dense, sparse, graph | dense: 0.521, sparse: 0.176, graph: 0.601 |
| 2 | CWE-113 | Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Request/Response Splitting') | Variant | Allowed | 0.4574 | dense, sparse, graph | dense: 0.500, sparse: 0.181, graph: 0.397 |
| 3 | CWE-1286 | Improper Validation of Syntactic Correctness of Input | Base | Allowed | 0.4570 | sparse, graph | sparse: 0.279, graph: 0.832 |
| 4 | CWE-295 | Improper Certificate Validation | Base | Allowed | 0.4348 | sparse, graph | sparse: 0.177, graph: 0.932 |
| 5 | CWE-917 | Improper Neutralization of Special Elements used in an Expression Language Statement ('Expression Language Injection') | Base | Allowed | 0.4044 | sparse, graph | sparse: 0.187, graph: 0.832 |
| 6 | CWE-79 | Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting') | Base | Allowed | 0.3822 | sparse, graph | sparse: 0.175, graph: 0.789 |
| 7 | CWE-1336 | Improper Neutralization of Special Elements Used in a Template Engine | Base | Allowed | 0.2907 | sparse, graph | sparse: 0.169, graph: 0.543 |
| 8 | CWE-95 | Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection') | Variant | Allowed | 0.2593 | sparse, graph | sparse: 0.180, graph: 0.498 |
| 9 | CWE-22 | Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal') | Base | Allowed | 0.1007 | sparse | sparse: 0.176 |
| 10 | CWE-502 | Deserialization of Untrusted Data | Base | Allowed | 0.0999 | sparse | sparse: 0.175 |



# Analysis to Review
# Summary
| CWE ID | CWE Name | Confidence | CWE Abstraction Level | CWE Vulnerability Mapping Label | CWE-Vulnerability Mapping Notes |
|---|---|---|---|---|---|
| CWE-20 | Improper Input Validation | 0.85 | Class | Primary | Allowed |
| CWE-79 | Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting') | 0.70 | Base | Secondary | Allowed |

## Evidence and Confidence

*   **Confidence Score:** 0.80
*   **Evidence Strength:** HIGH

- **Analysis and Justification:**  
  - *Explanation:* The vulnerability lies in the Go programming language's DNS lookup functions (**net.Lookup{Addr,CNAME,Host}**), which do not properly validate responses from DNS servers. This **lack of validation** allows for the possibility of **unsafe injection**, potentially leading to XSS or other vulnerabilities if the returned values are used in an unsanitized context. The primary weakness is identified as **CWE-20 (Improper Input Validation)**, as the root cause stems from the failure to validate the DNS responses before using them. The vulnerability description and CVE reference links consistently emphasize the **lack of input sanitization** and **improper validation of hostnames**. Although the vulnerability could lead to XSS, mapping directly to **CWE-79** is less precise as the immediate cause is the missing validation step.
  
  - *Relationship Analysis:* **CWE-20** is a class-level weakness. Given that the issue involves a failure to validate DNS responses, it could be argued that a more specific CWE exists. However, the core issue is the general failure to validate external input. **CWE-79** is a child of **CWE-74 (Improper Neutralization of Special Elements)**, highlighting that the underlying problem is a lack of proper handling of special elements.

- **Confidence Score:**  
  - *Example:* Confidence: 0.85 (High evidence from technical description and CVE reference materials)

---
- **Analysis and Justification:**  
  - *Explanation:* A secondary CWE that can arise from this vulnerability is **CWE-79 (Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'))**. If the improperly validated DNS responses are used in web page output without proper sanitization, XSS can occur. While **CWE-20** captures the root cause (missing validation), **CWE-79** describes a potential impact if the invalid data is used in a web context. The vulnerability description mentions XSS as an example of an **unsafe injection**, supporting this mapping.

  - *Relationship Analysis:* **CWE-79** is a base-level CWE, which is a preferred level of abstraction. It is a child of **CWE-74 (Improper Neutralization of Special Elements)**, which is a class-level CWE. The relationship analysis reveals that **CWE-79 CanFollow CWE-20**, as improper input validation can lead to XSS vulnerabilities if the unvalidated input is used in web page generation.

- **Confidence Score:**  
  - *Example:* Confidence: 0.70 (Supporting evidence that XSS is an impact but not a direct root cause)

---

# CWE Examples from Database


## Known Examples for CWE-20: Improper Input Validation
### Observed Examples
- **CVE-2024-37032** [https://www.cve.org/CVERecord?id=CVE-2024-37032](https://www.cve.org/CVERecord?id=CVE-2024-37032): Large language model (LLM) management tool does not validate the format of a digest value (CWE-1287) from a private, untrusted model registry, enabling relative path traversal (CWE-23), a.k.a. Probllama
- **CVE-2022-45918** [https://www.cve.org/CVERecord?id=CVE-2022-45918](https://www.cve.org/CVERecord?id=CVE-2022-45918): Chain: a learning management tool debugger uses external input to locate previous session logs (CWE-73) and does not properly validate the given path (CWE-20), allowing for filesystem path traversal using "../" sequences (CWE-24)
- **CVE-2021-30860** [https://www.cve.org/CVERecord?id=CVE-2021-30860](https://www.cve.org/CVERecord?id=CVE-2021-30860): Chain: improper input validation (CWE-20) leads to integer overflow (CWE-190) in mobile OS, as exploited in the wild per CISA KEV.
- **CVE-2021-30663** [https://www.cve.org/CVERecord?id=CVE-2021-30663](https://www.cve.org/CVERecord?id=CVE-2021-30663): Chain: improper input validation (CWE-20) leads to integer overflow (CWE-190) in mobile OS, as exploited in the wild per CISA KEV.
- **CVE-2021-22205** [https://www.cve.org/CVERecord?id=CVE-2021-22205](https://www.cve.org/CVERecord?id=CVE-2021-22205): Chain: backslash followed by a newline can bypass a validation step (CWE-20), leading to eval injection (CWE-95), as exploited in the wild per CISA KEV.
- **CVE-2021-21220** [https://www.cve.org/CVERecord?id=CVE-2021-21220](https://www.cve.org/CVERecord?id=CVE-2021-21220): Chain: insufficient input validation (CWE-20) in browser allows heap corruption (CWE-787), as exploited in the wild per CISA KEV.
- **CVE-2020-9054** [https://www.cve.org/CVERecord?id=CVE-2020-9054](https://www.cve.org/CVERecord?id=CVE-2020-9054): Chain: improper input validation (CWE-20) in username parameter, leading to OS command injection (CWE-78), as exploited in the wild per CISA KEV.
- **CVE-2020-3452** [https://www.cve.org/CVERecord?id=CVE-2020-3452](https://www.cve.org/CVERecord?id=CVE-2020-3452): Chain: security product has improper input validation (CWE-20) leading to directory traversal (CWE-22), as exploited in the wild per CISA KEV.
- **CVE-2020-3161** [https://www.cve.org/CVERecord?id=CVE-2020-3161](https://www.cve.org/CVERecord?id=CVE-2020-3161): Improper input validation of HTTP requests in IP phone, as exploited in the wild per CISA KEV.
- **CVE-2020-3580** [https://www.cve.org/CVERecord?id=CVE-2020-3580](https://www.cve.org/CVERecord?id=CVE-2020-3580): Chain: improper input validation (CWE-20) in firewall product leads to XSS (CWE-79), as exploited in the wild per CISA KEV.


# Relevant CWE Specifications

## CWE-20: Improper Input Validation
**Abstraction:** Class
**Status:** Stable

### Description
The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.

### Extended Description


Input validation is a frequently-used technique for checking potentially dangerous inputs in order to ensure that the inputs are safe for processing within the code, or when communicating with other components. When software does not validate input properly, an attacker is able to craft the input in a form that is not expected by the rest of the application. This will lead to parts of the system receiving unintended input, which may result in altered control flow, arbitrary control of a resource, or arbitrary code execution.


Input validation is not the only technique for processing input, however. Other techniques attempt to transform potentially-dangerous input into something safe, such as filtering (CWE-790) - which attempts to remove dangerous inputs - or encoding/escaping (CWE-116), which attempts to ensure that the input is not misinterpreted when it is included in output to another component. Other techniques exist as well (see CWE-138 for more examples.)


Input validation can be applied to:


  - raw data - strings, numbers, parameters, file contents, etc.

  - metadata - information about the raw data, such as headers or size

Data can be simple or structured. Structured data can be composed of many nested layers, composed of combinations of metadata and raw data, with other simple or structured data.

Many properties of raw data or metadata may need to be validated upon entry into the code, such as:


  - specified quantities such as size, length, frequency, price, rate, number of operations, time, etc.

  - implied or derived quantities, such as the actual size of a file instead of a specified size

  - indexes, offsets, or positions into more complex data structures

  - symbolic keys or other elements into hash tables, associative arrays, etc.

  - well-formedness, i.e. syntactic correctness - compliance with expected syntax 

  - lexical token correctness - compliance with rules for what is treated as a token

  - specified or derived type - the actual type of the input (or what the input appears to be)

  - consistency - between individual data elements, between raw data and metadata, between references, etc.

  - conformance to domain-specific rules, e.g. business logic 

  - equivalence - ensuring that equivalent inputs are treated the same

  - authenticity, ownership, or other attestations about the input, e.g. a cryptographic signature to prove the source of the data

Implied or derived properties of data must often be calculated or inferred by the code itself. Errors in deriving properties may be considered a contributing factor to improper input validation. 

Note that "input validation" has very different meanings to different people, or within different classification schemes. Caution must be used when referencing this CWE entry or mapping to it. For example, some weaknesses might involve inadvertently giving control to an attacker over an input when they should not be able to provide an input at all, but sometimes this is referred to as input validation.


Finally, it is important to emphasize that the distinctions between input validation and output escaping are often blurred, and developers must be careful to understand the difference, including how input validation is not always sufficient to prevent vulnerabilities, especially when less stringent data types must be supported, such as free-form text. Consider a SQL injection scenario in which a person's last name is inserted into a query. The name "O'Reilly" would likely pass the validation step since it is a common last name in the English language. However, this valid name cannot be directly inserted into the database because it contains the "'" apostrophe character, which would need to be escaped or otherwise transformed. In this case, removing the apostrophe might reduce the risk of SQL injection, but it would produce incorrect behavior because the wrong name would be recorded.


### Alternative Terms
None

### Relationships
ChildOf -> CWE-707
PeerOf -> CWE-345
CanPrecede -> CWE-22
CanPrecede -> CWE-41
CanPrecede -> CWE-74
CanPrecede -> CWE-119
CanPrecede -> CWE-770
ParentOf -> CWE-102
ParentOf -> CWE-103
ParentOf -> CWE-104
ParentOf -> CWE-105
ParentOf -> CWE-106
ParentOf -> CWE-107
ParentOf -> CWE-108
ParentOf -> CWE-109
ParentOf -> CWE-110
ParentOf -> CWE-111
ParentOf -> CWE-112
ParentOf -> CWE-113
ParentOf -> CWE-114
ParentOf -> CWE-117
ParentOf -> CWE-1173
ParentOf -> CWE-119
ParentOf -> CWE-120
ParentOf -> CWE-1284
ParentOf -> CWE-1285
ParentOf -> CWE-1286
ParentOf -> CWE-1287
ParentOf -> CWE-1288
ParentOf -> CWE-1289
ParentOf -> CWE-129
ParentOf -> CWE-134
ParentOf -> CWE-15
ParentOf -> CWE-170
ParentOf -> CWE-179
ParentOf -> CWE-190
ParentOf -> CWE-466
ParentOf -> CWE-470
ParentOf -> CWE-622
ParentOf -> CWE-73
ParentOf -> CWE-785

### Mapping Guidance
**Usage:** Discouraged
**Rationale:** CWE-20 is commonly misused in low-information vulnerability reports when lower-level CWEs could be used instead, or when more details about the vulnerability are available [REF-1287]. It is not useful for trend analysis. It is also a level-1 Class (i.e., a child of a Pillar).
**Comments:** Consider lower-level children such as Improper Use of Validation Framework (CWE-1173) or improper validation involving specific types or properties of input such as Specified Quantity (CWE-1284); Specified Index, Position, or Offset (CWE-1285); Syntactic Correctness (CWE-1286); Specified Type (CWE-1287); Consistency within Input (CWE-1288); or Unsafe Equivalence (CWE-1289).
**Reasons:**
- Frequent Misuse
**Suggested Alternatives:**
- CWE-1284: Specified Quantity
- CWE-1285: Specified Index, Position, or Offset
- CWE-1286: Syntactic Correctness
- CWE-1287: Specified Type
- CWE-1288: Consistency within Input
- CWE-1289: Unsafe Equivalence
- CWE-116: Improper Encoding or Escaping of Output


### Potential Mitigations
**Mitigation 1:**
- **Phase:** Architecture and Design
- **Strategy:** Attack Surface Reduction
- **Description:** Consider using language-theoretic security (LangSec) techniques that characterize inputs using a formal language and build "recognizers" for that language. This effectively requires parsing to be a distinct layer that effectively enforces a boundary between raw input and internal data representations, instead of allowing parser code to be scattered throughout the program, where it could be subject to errors or inconsistencies that create weaknesses. [REF-1109] [REF-1110] [REF-1111]

**Mitigation 2:**
- **Phase:** Architecture and Design
- **Strategy:** Libraries or Frameworks
- **Description:** Use an input validation framework such as Struts or the OWASP ESAPI Validation API. Note that using a framework does not automatically address all input validation problems; be mindful of weaknesses that could arise from misusing the framework itself (CWE-1173).

**Mitigation 3:**
- **Phase:** Architecture and Design, Implementation
- **Strategy:** Attack Surface Reduction
- **Description:** Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, filenames, databases, and any external systems that provide data to the application. Remember that such inputs may be obtained indirectly through API calls.



### Additional Notes
**[Relationship]** 

CWE-116 and CWE-20 have a close association because, depending on the nature of the structured message, proper input validation can indirectly prevent special characters from changing the meaning of a structured message. For example, by validating that a numeric ID field should only contain the 0-9 characters, the programmer effectively prevents injection attacks.


**[Maintenance]** As of 2020, this entry is used more often than preferred, and it is a source of frequent confusion. It is being actively modified for CWE 4.1 and subsequent versions.

**[Maintenance]** Concepts such as validation, data transformation, and neutralization are being refined, so relationships between CWE-20 and other entries such as CWE-707 may change in future versions, along with an update to the Vulnerability Theory document.

**[Maintenance]** Input validation - whether missing or incorrect - is such an essential and widespread part of secure development that it is implicit in many different weaknesses. Traditionally, problems such as buffer overflows and XSS have been classified as input validation problems by many security professionals. However, input validation is not necessarily the only protection mechanism available for avoiding such problems, and in some cases it is not even sufficient. The CWE team has begun capturing these subtleties in chains within the Research Concepts view (CWE-1000), but more work is needed.

**[Terminology]** 

The "input validation" term is extremely common, but it is used in many different ways. In some cases its usage can obscure the real underlying weakness or otherwise hide chaining and composite relationships.


Some people use "input validation" as a general term that covers many different neutralization techniques for ensuring that input is appropriate, such as filtering, canonicalization, and escaping. Others use the term in a more narrow context to simply mean "checking if an input conforms to expectations without changing it." CWE uses this more narrow interpretation.




### Observed Examples
- **CVE-2024-37032:** Large language model (LLM) management tool does not validate the format of a digest value (CWE-1287) from a private, untrusted model registry, enabling relative path traversal (CWE-23), a.k.a. Probllama
- **CVE-2022-45918:** Chain: a learning management tool debugger uses external input to locate previous session logs (CWE-73) and does not properly validate the given path (CWE-20), allowing for filesystem path traversal using "../" sequences (CWE-24)
- **CVE-2021-30860:** Chain: improper input validation (CWE-20) leads to integer overflow (CWE-190) in mobile OS, as exploited in the wild per CISA KEV.



## CWE-74: Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')
**Abstraction:** Class
**Status:** Incomplete

### Description
The product constructs all or part of a command, data structure, or record using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify how it is parsed or interpreted when it is sent to a downstream component.

### Extended Description
Software or other automated logic has certain assumptions about what constitutes data and control respectively. It is the lack of verification of these assumptions for user-controlled input that leads to injection problems. Injection problems encompass a wide variety of issues -- all mitigated in very different ways and usually attempted in order to alter the control flow of the process. For this reason, the most effective way to discuss these weaknesses is to note the distinct features that classify them as injection weaknesses. The most important issue to note is that all injection problems share one thing in common -- i.e., they allow for the injection of control plane data into the user-controlled data plane. This means that the execution of the process may be altered by sending code in through legitimate data channels, using no other mechanism. While buffer overflows, and many other flaws, involve the use of some further issue to gain execution, injection problems need only for the data to be parsed.

### Alternative Terms
None

### Relationships
ChildOf -> CWE-707
CanFollow -> CWE-116
ParentOf -> CWE-1236
CanFollow -> CWE-20
ParentOf -> CWE-75
ParentOf -> CWE-77
ParentOf -> CWE-78
ParentOf -> CWE-79
ParentOf -> CWE-88
ParentOf -> CWE-89
ParentOf -> CWE-91
ParentOf -> CWE-917
ParentOf -> CWE-93
ParentOf -> CWE-94
ParentOf -> CWE-943
ParentOf -> CWE-99

### Mapping Guidance
**Usage:** Discouraged
**Rationale:** CWE-74 is high-level and often misused when lower-level weaknesses are more appropriate.
**Comments:** Examine the children and descendants of this entry to find a more precise mapping.
**Reasons:**
- Frequent Misuse
- Abstraction


### Potential Mitigations
**Mitigation 1:**
- **Phase:** Requirements
- **Description:** Programming languages and supporting technologies might be chosen which are not subject to these issues.

**Mitigation 2:**
- **Phase:** Implementation
- **Description:** Utilize an appropriate mix of allowlist and denylist parsing to filter control-plane syntax from all input.



### Additional Notes
**[Theoretical]** Many people treat injection only as an input validation problem (CWE-20) because many people do not distinguish between the consequence/attack (injection) and the protection mechanism that prevents the attack from succeeding. However, input validation is only one potential protection mechanism (output encoding is another), and there is a chaining relationship between improper input validation and the improper enforcement of the structure of messages to other components. Other issues not directly related to input validation, such as race conditions, could similarly impact message structure.



### Observed Examples
- **CVE-2024-5184:** API service using a large generative AI model allows direct prompt injection to leak hard-coded system prompts or execute other prompts.
- **CVE-2022-36069:** Python-based dependency management tool avoids OS command injection when generating Git commands but allows injection of optional arguments with input beginning with a dash (CWE-88), potentially allowing for code execution.
- **CVE-1999-0067:** Canonical example of OS command injection. CGI program does not neutralize "|" metacharacter when invoking a phonebook program.



## CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')
**Abstraction:** Base
**Status:** Stable

### Description
The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.

### Extended Description


Cross-site scripting (XSS) vulnerabilities occur when:


  1. Untrusted data enters a web application, typically from a web request.

  1. The web application dynamically generates a web page that contains this untrusted data.

  1. During page generation, the application does not prevent the data from containing content that is executable by a web browser, such as JavaScript, HTML tags, HTML attributes, mouse events, Flash, ActiveX, etc.

  1. A victim visits the generated web page through a web browser, which contains malicious script that was injected using the untrusted data.

  1. Since the script comes from a web page that was sent by the web server, the victim's web browser executes the malicious script in the context of the web server's domain.

  1. This effectively violates the intention of the web browser's same-origin policy, which states that scripts in one domain should not be able to access resources or run code in a different domain.

There are three main kinds of XSS:

  -  **Type 1: Reflected XSS (or Non-Persistent)**  - The server reads data directly from the HTTP request and reflects it back in the HTTP response. Reflected XSS exploits occur when an attacker causes a victim to supply dangerous content to a vulnerable web application, which is then reflected back to the victim and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or e-mailed directly to the victim. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces a victim to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the victim, the content is executed by the victim's browser.

  -  **Type 2: Stored XSS (or Persistent)**  - The application stores dangerous data in a database, message forum, visitor log, or other trusted data store. At a later time, the dangerous data is subsequently read back into the application and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user. For example, the attacker might inject XSS into a log message, which might not be handled properly when an administrator views the logs. 

  -  **Type 0: DOM-Based XSS**  - In DOM-based XSS, the client performs the injection of XSS into the page; in the other types, the server performs the injection. DOM-based XSS generally involves server-controlled, trusted script that is sent to the client, such as Javascript that performs sanity checks on a form before the user submits it. If the server-supplied script processes user-supplied data and then injects it back into the web page (such as with dynamic HTML), then DOM-based XSS is possible. 

Once the malicious script is injected, the attacker can perform a variety of malicious activities. The attacker could transfer private information, such as cookies that may include session information, from the victim's machine to the attacker. The attacker could send malicious requests to a web site on behalf of the victim, which could be especially dangerous to the site if the victim has administrator privileges to manage that site. Phishing attacks could be used to emulate trusted web sites and trick the victim into entering a password, allowing the attacker to compromise the victim's account on that web site. Finally, the script could exploit a vulnerability in the web browser itself possibly taking over the victim's machine, sometimes referred to as "drive-by hacking."

In many cases, the attack can be launched without the victim even being aware of it. Even with careful users, attackers frequently use a variety of methods to encode the malicious portion of the attack, such as URL encoding or Unicode, so the request looks less suspicious.


### Alternative Terms
XSS: A common abbreviation for Cross-Site Scripting.
HTML Injection: Used as a synonym of stored (Type 2) XSS.
CSS: In the early years after initial discovery of XSS, "CSS" was a commonly-used acronym. However, this would cause confusion with "Cascading Style Sheets," so usage of this acronym has declined significantly.

### Relationships
ChildOf -> CWE-74
ChildOf -> CWE-74
CanPrecede -> CWE-494
PeerOf -> CWE-352
CanFollow -> CWE-113
CanFollow -> CWE-184
ParentOf -> CWE-80
ParentOf -> CWE-81
ParentOf -> CWE-83
ParentOf -> CWE-84
ParentOf -> CWE-85
ParentOf -> CWE-86
ParentOf -> CWE-87

### Mapping Guidance
**Usage:** Allowed
**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.
**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.
**Reasons:**
- Acceptable-Use


### Potential Mitigations
**Mitigation 1:**
- **Phase:** Architecture and Design
- **Strategy:** Libraries or Frameworks
- **Description:** 

Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.


Examples of libraries and frameworks that make it easier to generate properly encoded output include Microsoft's Anti-XSS library, the OWASP ESAPI Encoding module, and Apache Wicket.


**Mitigation 2:**
- **Phase:** Implementation, Architecture and Design
- **Description:** 

Understand the context in which your data will be used and the encoding that will be expected. This is especially important when transmitting data between different components, or when generating outputs that can contain multiple encodings at the same time, such as web pages or multi-part mail messages. Study all expected communication protocols and data representations to determine the required encoding strategies.


For any data that will be output to another web page, especially any data that was received from external inputs, use the appropriate encoding on all non-alphanumeric characters.


Parts of the same output document may require different encodings, which will vary depending on whether the output is in the:


  - HTML body

  - Element attributes (such as src="XYZ")

  - URIs

  - JavaScript sections

  - Cascading Style Sheets and style property

etc. Note that HTML Entity Encoding is only appropriate for the HTML body.

Consult the XSS Prevention Cheat Sheet [REF-724] for more details on the types of encoding and escaping that are needed.


**Mitigation 3:**
- **Phase:** Architecture and Design, Implementation
- **Effectiveness:** Limited
- **Strategy:** Attack Surface Reduction
- **Description:** Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, filenames, databases, and any external systems that provide data to the application. Remember that such inputs may be obtained indirectly through API calls.



### Additional Notes
**[Relationship]** 

There can be a close relationship between XSS and CSRF (CWE-352). An attacker might use CSRF in order to trick the victim into submitting requests to the server in which the requests contain an XSS payload. A well-known example of this was the Samy worm on MySpace [REF-956]. The worm used XSS to insert malicious HTML sequences into a user's profile and add the attacker as a MySpace friend. MySpace friends of that victim would then execute the payload to modify their own profiles, causing the worm to propagate exponentially. Since the victims did not intentionally insert the malicious script themselves, CSRF was a root cause.


**[Applicable Platform]** 

XSS flaws are very common in web applications, since they require a great deal of developer discipline to avoid them.




### Observed Examples
- **CVE-2021-25926:** Python Library Manager did not sufficiently neutralize a user-supplied search term, allowing reflected XSS.
- **CVE-2021-25963:** Python-based e-commerce platform did not escape returned content on error pages, allowing for reflected Cross-Site Scripting attacks.
- **CVE-2021-1879:** Universal XSS in mobile operating system, as exploited in the wild per CISA KEV.

