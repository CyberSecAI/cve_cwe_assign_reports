# Vulnerability Information: CVE-2021-46023

## Vulnerability Description
An Untrusted Pointer Dereference was discovered in function mrb_vm_exec in mruby before 3.1.0-rc. The vulnerability causes a segmentation fault and application crash.

### Vulnerability Description Key Phrases
- **rootcause:** **untrusted pointer dereference**
- **impact:** segmentation fault and application crash
- **product:** mruby
- **version:** before 3.1.0-rc
- **component:** mrb_vm_exec function

## CVE Reference Links Content Summary
Based on the provided content, here's an analysis of the vulnerability:

**Root Cause:**

*   An untrusted pointer dereference in the `mrb_vm_exec()` function within the mruby virtual machine. This occurs due to incorrect handling of arguments within the `mrb_get_args()` function, specifically when used in conjunction with methods like `Array#shift`.

**Weaknesses/Vulnerabilities:**

*   **Untrusted Pointer Dereference:**  The core vulnerability is that `mrb_vm_exec()` attempts to dereference a pointer that may be invalid or point to freed memory.
*   **Reentrancy Issues:** The `mrb_get_args()` function was not designed to be reentrant to the mruby VM, which leads to incorrect state when functions like `mrb_as_int()` or `mrb_as_float()` are called within `mrb_get_args()`.
*   **Incorrect Argument Handling:** The length of arguments was not being correctly updated after the call to `mrb_get_args()`, leading to potential out-of-bounds access.

**Impact of Exploitation:**

*   **Segmentation Fault:**  The primary impact is a segmentation fault, which causes the application using mruby to crash.
*   **Denial of Service (DoS):** A crash of the application leads to a denial of service.
*   **Potential for further exploitation:** While not explicitly stated, if memory corruption occurs it could potentially be used for more severe exploitation.

**Attack Vectors:**

*   **Malicious mruby Script:** An attacker can craft a malicious mruby script that exploits the vulnerability. This script triggers the `Array#shift` or other affected methods with arguments that cause the problematic code to execute, leading to the pointer dereference and the crash.
*   **Input to mruby program:** Exploitation requires the processing of a specially crafted input.

**Required Attacker Capabilities/Position:**

*   **Ability to execute mruby code:** An attacker must be able to execute mruby code on the target system.
*   **Knowledge of vulnerable methods:** They need to know which specific methods (e.g. `Array#shift`, `Array#rotate`, `Array#rotate!`, `String#byteslice`) trigger the vulnerability.

**Additional Details:**

*   The vulnerability is triggered by methods that internally call `mrb_get_args()`, such as array manipulation methods and string manipulation methods.
*   The fixes involved adjusting the logic in `mrb_get_args()` to avoid reentrancy issues, correctly updating argument lengths and adjusting the stack frame after it enters the virtual machine.
*   The vulnerability was present in mruby version 3.0.0.
*   The issue was resolved by pull requests #5619 and #5620.

**Summary of Fixes:**

1.  **`mrb_ary_shift_m()` Fix:**
    *   The length of the arguments, `len`, is assigned *after* the call to `mrb_get_args()`, preventing the vulnerability.
2.  **`mrb_get_args()` Refactor:**
    *   The variables `argv` and `ci` are adjusted *after* `mrb_as_int()` and `mrb_as_float()`. This prevents a crash inside `mrb_get_args()`.
3.  **Stack Adjustment:**
    *   The stack is adjusted after entering the virtual machine to account for changes in context.
4.  **`mrb_as_float()` Fix:**
    *   The `mrb_as_float` function was modified to avoid calling `to_f` for generic objects and to only call it for `Rational` and `Complex` numbers.

The provided information provides a good overview of the vulnerability and its fixes.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage | Combined Score | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|---------------|------------|-------------------|
| 1 | CWE-822 | Untrusted Pointer Dereference | Base | Allowed | 0.7406 | dense, sparse, graph | dense: 0.546, sparse: 0.253, graph: 0.903 |
| 2 | CWE-476 | NULL Pointer Dereference | Base | Allowed | 0.6390 | dense, sparse, graph | dense: 0.475, sparse: 0.185, graph: 0.826 |
| 3 | CWE-823 | Use of Out-of-range Pointer Offset | Base | Allowed | 0.6136 | dense, sparse, graph | dense: 0.498, sparse: 0.142, graph: 0.791 |
| 4 | CWE-787 | Out-of-bounds Write | Base | Allowed | 0.4246 | sparse, graph | sparse: 0.117, graph: 1.000 |
| 5 | CWE-456 | Missing Initialization of a Variable | Variant | Allowed | 0.3782 | sparse, graph | sparse: 0.132, graph: 0.935 |
| 6 | CWE-252 | Unchecked Return Value | Base | Allowed | 0.3029 | dense, sparse | dense: 0.463, sparse: 0.125 |
| 7 | CWE-825 | Expired Pointer Dereference | Base | Allowed | 0.3005 | dense, sparse | dense: 0.477, sparse: 0.108 |
| 8 | CWE-824 | Access of Uninitialized Pointer | Base | Allowed | 0.2958 | dense, sparse | dense: 0.461, sparse: 0.114 |
| 9 | CWE-119 | Improper Restriction of Operations within the Bounds of a Memory Buffer | Class | Discouraged | 0.1812 | sparse, graph | sparse: 0.138, graph: 0.911 |
| 10 | CWE-909 | Missing Initialization of Resource | Class | Allowed-with-Review | 0.1715 | dense, sparse | dense: 0.461, sparse: 0.107 |

