# Vulnerability Information: CVE-2022-39293

## Vulnerability Description
Azure RTOS USBX is a high-performance USB host, device, and on-the-go (OTG) embedded stack, that is fully integrated with Azure RTOS ThreadX. The case is, in [_ux_host_class_pima_read](https//github.com/azure-rtos/usbx/blob/master/common/usbx_host_classes/src/ux_host_class_pima_read.c), there is data length from device response, returned in the very first packet, and read by [L165 code](https//github.com/azure-rtos/usbx/blob/082fd9db09a3669eca3358f10b8837a5c1635c0b/common/usbx_host_classes/src/ux_host_class_pima_read.c#L165), as header_length. Then in [L178 code](https//github.com/azure-rtos/usbx/blob/082fd9db09a3669eca3358f10b8837a5c1635c0b/common/usbx_host_classes/src/ux_host_class_pima_read.c#L178), there is a if branch, which check the expression of (header_length - UX_HOST_CLASS_PIMA_DATA_HEADER_SIZE) > data_length where if header_length is smaller than UX_HOST_CLASS_PIMA_DATA_HEADER_SIZE, calculation could overflow and then [L182 code](https//github.com/azure-rtos/usbx/blob/082fd9db09a3669eca3358f10b8837a5c1635c0b/common/usbx_host_classes/src/ux_host_class_pima_read.c#L182) the calculation of data_length is also overflow, this way the later [while loop start from L192](https//github.com/azure-rtos/usbx/blob/082fd9db09a3669eca3358f10b8837a5c1635c0b/common/usbx_host_classes/src/ux_host_class_pima_read.c#L192) can move data_pointer to unexpected address and cause write buffer overflow. The fix has been included in USBX release [6.1.12](https//github.com/azure-rtos/usbx/releases/tag/v6.1.12_rel). The following can be used as a workaround Add check of `header_length` 1. It must be greater than `UX_HOST_CLASS_PIMA_DATA_HEADER_SIZE`. 1. It should be greater or equal to the current returned data length (`transfer_request -> ux_transfer_request_actual_length`).

### Vulnerability Description Key Phrases
- **weakness:** **integer overflow**
- **impact:** write buffer overflow
- **vector:** crafted USB packet
- **product:** Azure RTOS USBX
- **version:** before 6.1.12
- **component:** ux_host_class_pima_read function

## CVE Reference Links Content Summary
Based on the provided information, here's a breakdown of the vulnerability:

**Root cause of vulnerability:**

- Integer underflow in the `_ux_host_class_pima_read` function when calculating data length.

**Weaknesses/vulnerabilities present:**

- The vulnerability arises from insufficient input validation in the PIMA read function.
- Specifically, the `header_length` value received from a device response is not checked to ensure it is greater or equal to the size of the PIMA data header (`UX_HOST_CLASS_PIMA_DATA_HEADER_SIZE`).
- When `header_length` is smaller than `UX_HOST_CLASS_PIMA_DATA_HEADER_SIZE` a subtraction operation `(header_length - UX_HOST_CLASS_PIMA_DATA_HEADER_SIZE)` results in an integer underflow and corrupts the `data_length` variable.

**Impact of exploitation:**

- The integer underflow leads to an incorrect `data_length` calculation.
- This incorrect value is then used to control a while loop, causing the `data_pointer` to move to an unexpected memory address.
- Subsequently, data is written to this incorrect address, leading to a buffer overflow.
- This can cause corruption and unexpected behavior of the system including possibly arbitrary code execution.

**Attack vectors:**

- The attacker controls a USB PIMA device which communicates with a vulnerable USB host running the affected code.
- By crafting a malicious PIMA response where the `header_length` is smaller than the `UX_HOST_CLASS_PIMA_DATA_HEADER_SIZE`, an attacker can trigger the underflow.

**Required attacker capabilities/position:**

- The attacker needs to control a malicious USB device that implements the PIMA protocol.
- The attacker must be able to send a crafted PIMA response to the USB host which causes the `header_length` to be smaller than `UX_HOST_CLASS_PIMA_DATA_HEADER_SIZE`.
- This malicious device must be plugged into the USB host system running the vulnerable USBX code.

**Additional details:**

- The vulnerability is located in `ux_host_class_pima_read.c`, specifically around lines 165, 178, 182 and the while loop starting at line 192.
- The fix for this issue is included in USBX release 6.1.12.
- A workaround involves adding a check to ensure the received `header_length` is greater than `UX_HOST_CLASS_PIMA_DATA_HEADER_SIZE` and also that it is greater or equal to the current returned data length.

This detailed explanation provides a thorough understanding of the vulnerability and its implications.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage | Combined Score | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|---------------|------------|-------------------|
| 1 | CWE-191 | Integer Underflow (Wrap or Wraparound) | Base | Allowed | 1.0864 | dense, sparse, graph | dense: 0.597, sparse: 1.000, graph: 0.603 |
| 2 | CWE-1284 | Improper Validation of Specified Quantity in Input | Base | Allowed | 1.0100 | dense, sparse, graph | dense: 0.469, sparse: 1.000, graph: 0.569 |
| 3 | CWE-130 | Improper Handling of Length Parameter Inconsistency | Base | Allowed | 0.9934 | dense, sparse, graph | dense: 0.484, sparse: 0.688, graph: 1.000 |
| 4 | CWE-190 | Integer Overflow or Wraparound | Base | Allowed | 0.9281 | dense, sparse, graph | dense: 0.489, sparse: 0.740, graph: 0.727 |
| 5 | CWE-122 | Heap-based Buffer Overflow | Variant | Allowed | 0.6603 | dense, sparse | dense: 0.474, sparse: 0.836 |
| 6 | CWE-824 | Access of Uninitialized Pointer | Base | Allowed | 0.6503 | sparse, graph | sparse: 0.775, graph: 0.579 |
| 7 | CWE-476 | NULL Pointer Dereference | Base | Allowed | 0.6482 | sparse, graph | sparse: 0.739, graph: 0.631 |
| 8 | CWE-681 | Incorrect Conversion between Numeric Types | Base | Allowed | 0.6232 | sparse, graph | sparse: 0.732, graph: 0.572 |
| 9 | CWE-125 | Out-of-bounds Read | Base | Allowed | 0.5986 | sparse, graph | sparse: 0.711, graph: 0.537 |
| 10 | CWE-126 | Buffer Over-read | Variant | Allowed | 0.5859 | dense, sparse | dense: 0.483, sparse: 0.687 |

