# Vulnerability Information: CVE-2021-21798

## Vulnerability Description
An exploitable return of stack variable address vulnerability exists in the JavaScript implementation of Nitro Pro PDF. A specially crafted document can cause a **stack variable to go out of scope**, resulting in the application dereferencing a stale pointer. This can lead to code execution under the context of the application. An attacker can convince a user to open a document to trigger the vulnerability.

### Vulnerability Description Key Phrases
- **weakness:** **stack variable to go out of scope**
- **impact:** code execution
- **vector:** specially crafted document
- **attacker:** attacker
- **product:** Nitro Pro PDF
- **component:** JavaScript implementation

## CVE Reference Links Content Summary
The provided content is a detailed vulnerability report for CVE-2021-21798, which is a stack-based use-after-free vulnerability in Nitro Pro PDF's JavaScript implementation.

**Root Cause of Vulnerability:**
The vulnerability arises from a combination of factors:
1.  The `Document.flattenPages` Javascript function in Nitro Pro PDF can raise a C++ exception due to incorrect annotation handling.
2.  When the exception is raised, the `JSStackFrame` created by `js32u.dll!js_Invoke` goes out of scope, but a pointer to this stack frame is left in the `JSContext.fp` field, leading to a dangling pointer.
3.  Later, when the SpiderMonkey library tries to evaluate javascript code, the library uses the stale `JSStackFrame` from `JSContext.fp` when setting up a new stack frame via the `js32u.dll!MaybeSetupFrame` function. This out-of-scope `JSStackFrame` pointer is written into the new linked list of `JSStackFrame` which will then later be written to, leading to a use-after-free condition.

**Weaknesses/Vulnerabilities Present:**
- **Use-After-Free:** A `JSStackFrame` object allocated on the stack is deallocated (goes out of scope) while a pointer to it is still stored in a `JSContext` structure. This dangling pointer is later dereferenced leading to a use-after-free.
- **C++ Exception Handling Issues:** Improper exception handling in the `Document.flattenPages` function prevents the `JSContext.fp` from being correctly restored by the `js32u.dll!js_Invoke` function, which normally deallocates the stack frame after executing Javascript bindings, leading to the dangling pointer.
- **Stack Variable Address Return:** The `JSStackFrame` structure is allocated on the stack and its address is later used, leading to the vulnerability when this stack space is later deallocated.

**Impact of Exploitation:**
- **Code Execution:** By exploiting the use-after-free, an attacker can overwrite memory within the context of the application, eventually leading to arbitrary code execution. The attacker can manipulate the stale `JSStackFrame` on the stack to control program flow and execute shellcode.
- **Application Crash:** The memory corruption may cause a crash if the overwritten memory leads to an invalid memory access.

**Attack Vectors:**
- **Specially Crafted PDF Document:** The vulnerability is triggered by opening a specially crafted PDF document containing malicious JavaScript code that calls `Document.flattenPages` with specific parameters that trigger the exception path.

**Required Attacker Capabilities/Position:**
- **User Interaction:** The attacker needs to convince a user to open the malicious PDF document. No other special privileges or network access is needed to trigger the vulnerability.

**Additional Notes:**
- The vulnerability report provides a detailed breakdown of the vulnerable code paths within the Nitro Pro PDF application as well as the underlying SpiderMonkey JavaScript library.
- It includes the specific function calls in `js32u.dll` and `np_java_script.dll` which cause the use-after-free condition.
- The report also shows how to use a debugger to observe the state of the program and reproduce the vulnerability using a proof-of-concept PDF file.
- The report also provides a mitigation measure by disabling JavaScript in the application preferences.
- The report also includes a timeline of the disclosure process, and patch release.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage | Combined Score | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|---------------|------------|-------------------|
| 1 | CWE-562 | Return of Stack Variable Address | Base | Allowed | 0.9346 | dense, sparse, graph | dense: 0.719, sparse: 0.573, graph: 0.691 |
| 2 | CWE-190 | Integer Overflow or Wraparound | Base | Allowed | 0.7442 | dense, sparse, graph | dense: 0.493, sparse: 0.364, graph: 0.808 |
| 3 | CWE-787 | Out-of-bounds Write | Base | Allowed | 0.6846 | dense, sparse, graph | dense: 0.499, sparse: 0.348, graph: 0.658 |
| 4 | CWE-457 | Use of Uninitialized Variable | Variant | Allowed | 0.4296 | dense, sparse | dense: 0.526, sparse: 0.354 |
| 5 | CWE-121 | Stack-based Buffer Overflow | Variant | Allowed | 0.4276 | dense, sparse | dense: 0.518, sparse: 0.356 |
| 6 | CWE-120 | Buffer Copy without Checking Size of Input ('Classic Buffer Overflow') | Base | Allowed-with-Review | 0.4005 | sparse, graph | sparse: 0.339, graph: 0.631 |
| 7 | CWE-193 | Off-by-one Error | Base | Allowed | 0.3982 | sparse, graph | sparse: 0.320, graph: 0.602 |
| 8 | CWE-789 | Memory Allocation with Excessive Size Value | Variant | Allowed | 0.3616 | sparse, graph | sparse: 0.321, graph: 0.583 |
| 9 | CWE-674 | Uncontrolled Recursion | Class | Allowed-with-Review | 0.2801 | dense, sparse | dense: 0.545, sparse: 0.357 |
| 10 | CWE-197 | Numeric Truncation Error | Base | Allowed | 0.2018 | sparse | sparse: 0.353 |

