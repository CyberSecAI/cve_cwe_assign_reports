# Vulnerability Information: CVE-2022-3028

## Vulnerability Description
A **race condition** was found in the Linux kernels IP framework for transforming packets (XFRM subsystem) when multiple calls to xfrm_probe_algs occurred simultaneously. This flaw could allow a local attacker to potentially trigger an out-of-bounds write or leak kernel heap memory by performing an out-of-bounds read and copying it into a socket.

### Vulnerability Description Key Phrases
- **rootcause:** **race condition**
- **impact:** out-of-bounds write and leak kernel heap memory
- **vector:** multiple calls to xfrm_probe_algs simultaneously
- **attacker:** local attacker
- **product:** Linux kernels
- **component:** IP framework for transforming packets (XFRM subsystem)

## CVE Reference Links Content Summary
Based on the provided content, here's an analysis of CVE-2022-3028:

**Root Cause of Vulnerability:**
- The vulnerability stems from a race condition within the `xfrm_probe_algs` function in the Linux kernel's AF_KEY subsystem.
- This function, responsible for probing and updating the availability of cryptographic algorithms, was previously called in a single-threaded manner.
- However, after the introduction of namespace support for `xfrm/afkey`, this function became multi-threaded, leading to concurrent access and modification of shared data structures.

**Weaknesses/Vulnerabilities Present:**
- **Race Condition:** Concurrent calls to `xfrm_probe_algs` without proper synchronization mechanisms could lead to data corruption.
- **Out-of-bounds Read/Write:** Due to the race condition, the code can calculate an incorrect number of available algorithms. This can lead to allocation of a buffer smaller than required, resulting in an out-of-bounds write during population of this buffer, or an out-of-bounds read, when accessing these algorithms.
- **Lack of Synchronization:** The core issue is the absence of a mutex or other locking mechanism to protect the shared algorithm lists accessed by `xfrm_probe_algs`.

**Impact of Exploitation:**
- **Denial of Service (DoS):** A local attacker could trigger the race condition to cause a system crash or memory corruption, resulting in DoS.
- **Information Disclosure:** The out-of-bounds read could potentially leak sensitive kernel memory.
- **Privilege Escalation:** The memory corruption caused by out-of-bounds write could potentially be leveraged for privilege escalation, allowing the attacker to gain root privileges, although this is not explicitly stated, it is hinted at in multiple documents.

**Attack Vectors:**
- The attack vector is **local**.
- A local user can trigger the vulnerable code by interacting with the AF_KEY subsystem.

**Required Attacker Capabilities/Position:**
- The attacker needs to be a local user with the ability to interact with the AF_KEY subsystem.
- No special capabilities are needed beyond the ability to execute system calls.

**Additional Details:**
- The vulnerability was introduced by commit `283bc9f35bbbcb0e9ab4e6d2427da7f9f710d52d` ("xfrm: Namespacify xfrm state/policy locks") which neglected to convert `xfrm_probe_algs` to namespaces.
- The fix involves adding a mutex lock around the `xfrm_probe_algs` call, ensuring that only one thread can access the shared resources at a time.
- The fix is implemented in commit `ba953a9d89a00c078b85f4b190bc1dde66fe16b5` ("af_key: Do not call xfrm_probe_algs in parallel").

In summary, CVE-2022-3028 is a race condition in the Linux kernel's AF_KEY subsystem that could be exploited by a local user to cause a DoS, information leak, or potentially achieve privilege escalation. The root cause was the concurrent access to shared resources after the introduction of namespace support, and the fix was achieved by adding a mutex lock.

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage | Combined Score | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|---------------|------------|-------------------|
| 1 | CWE-367 | Time-of-check Time-of-use (TOCTOU) Race Condition | Base | Allowed | 0.6373 | dense, sparse, graph | dense: 0.512, sparse: 0.283, graph: 0.613 |
| 2 | CWE-476 | NULL Pointer Dereference | Base | Allowed | 0.5285 | sparse, graph | sparse: 0.299, graph: 1.000 |
| 3 | CWE-787 | Out-of-bounds Write | Base | Allowed | 0.5222 | sparse, graph | sparse: 0.288, graph: 1.000 |
| 4 | CWE-125 | Out-of-bounds Read | Base | Allowed | 0.4945 | sparse, graph | sparse: 0.293, graph: 0.915 |
| 5 | CWE-190 | Integer Overflow or Wraparound | Base | Allowed | 0.4208 | dense, sparse | dense: 0.523, sparse: 0.278 |
| 6 | CWE-362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | Allowed-with-Review | 0.4154 | dense, sparse, graph | dense: 0.570, sparse: 0.338, graph: 0.638 |
| 7 | CWE-1285 | Improper Validation of Specified Index, Position, or Offset in Input | Base | Allowed | 0.4013 | dense, sparse | dense: 0.518, sparse: 0.248 |
| 8 | CWE-122 | Heap-based Buffer Overflow | Variant | Allowed | 0.3811 | dense, sparse | dense: 0.510, sparse: 0.275 |
| 9 | CWE-401 | Missing Release of Memory after Effective Lifetime | Variant | Allowed | 0.3798 | dense, sparse | dense: 0.522, sparse: 0.262 |
| 10 | CWE-1284 | Improper Validation of Specified Quantity in Input | Base | Allowed | 0.3786 | sparse, graph | sparse: 0.267, graph: 0.631 |

