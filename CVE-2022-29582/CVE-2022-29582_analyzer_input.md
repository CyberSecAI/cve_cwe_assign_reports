# Vulnerability Information: CVE-2022-29582

## Vulnerability Description
In the Linux kernel before 5.17.3, fs/io_uring.c has a **use-after-free** due to a **race condition** in io_uring timeouts. This can be triggered by a local user who has no access to any user namespace however, the **race condition** perhaps can only be exploited infrequently.

### Vulnerability Description Key Phrases
- **rootcause:** **race condition**
- **weakness:** **use-after-free**
- **attacker:** local user
- **product:** Linux kernel
- **version:** before 5.17.3
- **component:** fs/io_uring.c

## CVE Reference Links Content Summary
```json
{
  "guidelines_version": "4",
  "relevant": true,
  "cve": "CVE-2022-29582",
  "root_cause": "A use-after-free vulnerability exists due to a race condition between the timeout flush and removal in the Linux kernel's io_uring subsystem. When IORING_OP_TIMEOUT and IORING_OP_LINK_TIMEOUT opcodes are combined in a linked submission queue entry, and another request completes concurrently, T is cancelled, and LT is cancelled by its hrtimer at the same time. When T is cleaned up, it retains a dangling reference to LT, which has already been freed by another execution context.",
  "weaknesses": [
    "Use-after-free",
    "Race condition",
    "Dangling pointer"
  ],
  "impact": "Local privilege escalation to system root. An attacker can reallocate the freed memory of LT, deferring the UaF to another struct, such as a `struct file`. By doing so, it could gain arbitrary read/write access, or obtain code execution in kernel space, resulting in a full system takeover.",
  "attack_vectors": {
    "local": true
  },
  "required_capabilities": "No special privileges are required to trigger this vulnerability. It can be triggered from an unprivileged process, even inside a container.",
    "additional_details": "The vulnerability is triggered when an application combines IORING_OP_TIMEOUT and IORING_OP_LINK_TIMEOUT opcodes in a linked submission queue entry. Exploitation involves racing the cleanup routines for the two operations, such that the linked timeout structure is freed before the parent timeout is cleaned up."
}
```

## Retriever Results

### Top Combined Results

| Rank | CWE ID | Name | Abstraction | Usage | Combined Score | Retrievers | Individual Scores |
|------|--------|------|-------------|-------|---------------|------------|-------------------|
| 1 | CWE-364 | Signal Handler Race Condition | Base | Allowed | 0.8392 | dense, sparse, graph | dense: 0.505, sparse: 0.400, graph: 1.000 |
| 2 | CWE-911 | Improper Update of Reference Count | Base | Allowed | 0.7516 | dense, sparse, graph | dense: 0.502, sparse: 0.411, graph: 0.741 |
| 3 | CWE-367 | Time-of-check Time-of-use (TOCTOU) Race Condition | Base | Allowed | 0.7356 | dense, sparse, graph | dense: 0.529, sparse: 0.438, graph: 0.616 |
| 4 | CWE-366 | Race Condition within a Thread | Base | Allowed | 0.7258 | dense, sparse, graph | dense: 0.576, sparse: 0.376, graph: 0.623 |
| 5 | CWE-416 | Use After Free | Variant | Allowed | 0.7024 | dense, sparse, graph | dense: 0.541, sparse: 0.367, graph: 0.782 |
| 6 | CWE-362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | Allowed-with-Review | 0.4808 | dense, sparse, graph | dense: 0.573, sparse: 0.530, graph: 0.640 |
| 7 | CWE-413 | Improper Resource Locking | Base | Allowed | 0.4577 | dense, sparse | dense: 0.501, sparse: 0.362 |
| 8 | CWE-190 | Integer Overflow or Wraparound | Base | Allowed | 0.4395 | dense, sparse | dense: 0.498, sparse: 0.333 |
| 9 | CWE-415 | Double Free | Variant | Allowed | 0.4222 | sparse, graph | sparse: 0.388, graph: 0.659 |
| 10 | CWE-667 | Improper Locking | Class | Allowed-with-Review | 0.3097 | dense, sparse | dense: 0.542, sparse: 0.447 |

